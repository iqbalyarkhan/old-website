{"componentChunkName":"component---src-templates-post-js","path":"/topological-sort","result":{"data":{"markdownRemark":{"html":"<h3 id=\"table-of-contents\" style=\"position:relative;\"><a href=\"#table-of-contents\" aria-label=\"table of contents permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Table of Contents</h3>\n<ol>\n<li>\n<p><a href=\"#motivation\">Motivation</a></p>\n</li>\n<li>\n<p><a href=\"#logic\">Logic</a></p>\n</li>\n<li>\n<p><a href=\"#depth-first-orders\">Depth First Orders</a></p>\n</li>\n<li>\n<p><a href=\"#code\">Code</a></p>\n</li>\n<li>\n<p><a href=\"#explanation\">Explanation</a></p>\n</li>\n<li>\n<p><a href=\"#conclusion\">Conclusion</a></p>\n</li>\n<li>\n<p><a href=\"#digraphs-cycles-and-topological-sort\">Digraphs, Cycles and Topological Sort</a></p>\n</li>\n</ol>\n<p>In this post, I'll assume you have sufficient directed graph knowledge. If not, feel free to browse through my post on <a href=\"/directed-graphs\">directed graphs</a>.</p>\n<h3 id=\"motivation\" style=\"position:relative;\"><a href=\"#motivation\" aria-label=\"motivation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Motivation</h3>\n<p>The word topology literally means <strong>the way in which constituent parts are interrelated or arranged</strong>. Therefore, topological sort deals with the idea of sorting elements based on their arrangement or specified order. For example, we can use topological sort to come up with a curriculum for a typical CS student based on the classes required for graduation and their pre-requisites. The idea is that you can't enroll for advanced algorithms without completing introduction to computer science class.</p>\n<h3 id=\"logic\" style=\"position:relative;\"><a href=\"#logic\" aria-label=\"logic permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Logic</h3>\n<p>Let's say you're a math major and have this arrangement of required classes for your degree:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 494px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.64739884393063%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUklEQVQoz22S6Y6CQBCEef+HM26ifzRKwn0IeCuC1ubrdcissZOGoemjqqYDSbper7pcLurvdw2PByEdDwedz2f1fa/HO/Z6vf65i/kWjOOosiiUZZnatlXTNOZZmmq5XGq1WqmqKn2zz2ZTw7qulSaJuq7TbrfTfr+3dxLHKorCGt5uNxsEYhj5CH0PCEKJAijiDHk+n1aI8x8GKagXC2NyPB6/IraGFOPOaI77lEBZlqWiKJqkwTgDgnyjzAN6JPuTwzBUkiRW6OLu8igeh0FxHP9J1HU6vC8xcHTyPJ80JBFdN5uNwu3Wzj4DZy4X/dGdoQG0aEQR7hAyEc3iKLLzpzEA5KfTyRCDfNLQt2EYVFeVJULBGbdNjP3EafDNgs9FBS30f+Zze0MLSWg4m820Xq9tb90lfF0bf0mZDBWK2qaxb2QglmeZyYJeMPEbOoS/iQ5RrNDiefgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Topological-Sort-Image-1\"\n        title=\"Topological-Sort-Image-1\"\n        src=\"/static/3b8576a5278dd61e39ab4b5dad466138/d72d4/topologicalsort_1.png\"\n        srcset=\"/static/3b8576a5278dd61e39ab4b5dad466138/991de/topologicalsort_1.png 173w,\n/static/3b8576a5278dd61e39ab4b5dad466138/e4d6b/topologicalsort_1.png 345w,\n/static/3b8576a5278dd61e39ab4b5dad466138/d72d4/topologicalsort_1.png 494w\"\n        sizes=\"(max-width: 494px) 100vw, 494px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><a href=\"https://www.pearson.com/us/higher-education/program/Lafore-Data-Structures-and-Algorithms-in-Java-2nd-Edition/PGM32075.html\">Image Credit - La Fore Data Structures</a></p>\n<p>The directed graph above shows that before you enroll for Senior Seminar, you need to have passed Advanced Algebra and before you can enroll for Advanced Algebra, you need to have successfully passed Algebra. Therefore, one possible path to getting a degree is:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">CABFDEGH</code></pre></div>\n<p>Notice how we take the introductory courses first and then proceed to more advanced courses. There is no course taken out of order. Also, the arrangement of courses for a given degree plan might not be a unique solution. For example, instead of completing <code class=\"language-cpptext\">CAB</code> first in that order, one might choose to complete the requirements in this order:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">ABCFDEGH</code></pre></div>\n<p>Creating this course plan from possible courses' directed graph requires the use of topological sort. So think about the problem: we start our academic careers by signing up for classes that have no pre-reqs. In our graph, these classes are labelled A,B and C. Next, we're eligible to sign up for classes that come immediately AFTER those intro classes: D,E or F and the process continues until we graduate!</p>\n<p>So the idea is to start with the vertex that has no arrows going into it: no incoming edges. That would mean, these vertices are our starting point and then we'd have to somehow iterate over all the connected edges from these starting vertices. This iteration can be done using either <a href=\"/directed-graphs#depth-first-search\">depth first search</a> or you can also use breadth first search.</p>\n<p>Before we start operating on our digraph, let's convert it to its integer representation and have a look at its adjacency list as well:</p>\n<p>In the image below, all we've done is replace vertices labelled A-H to 0-7:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 401px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f23b61740af112c122b9c94e08b7409f/9144d/topologicalsort_2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.41040462427746%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABwklEQVQ4y41UXU/bMBTN394/2PMepmk8rxLSHraHVYIHNAodrZAqsg6o0DZQQFRrC0ns+CN27IPi4jRN2sGRrhLfax2fe3KdwFrAWOvCNsKjmTfWuP31mkcArBZN5NpAFWZrvU5UIwT2zsfojkMUUoNRBp5xkAXBh8MDfBocw8iiyksi0P0ZYu9ivEbqn47wazjC7uAEggioXEEKiZxJDP/e4Cy6hcm1y2mtMY9m6Bwd4/PpoNVy+QzqcjllYJRvbbFUmaXUuWSUAY3Jkggr0qDpg+QS6WMKrXSVU1K5XC7yiqCEYALJLF7z1CmUunDhYQqD+d0M4XWEP9N/4CmDMWatxeJ5/es6wruDfTwysfJwpz/Ax14POZUgMUGWUCzuH/C2+w2d4clGrxwKg/DqBu+PfiDhckU4iu4xiu6qzf70clMmVZWvz19pQ7JIoJ/rVcvNAX4Nyo9HY1qNcGnH2tj4m7LswuJyOkXCOGxh3BiVoYVC//cV+pMJFMtbIrwlQbPwkAm8+bKLw8sJDFegaQZGGMg8xU7vOzqnQ3gRLU+9wuZJt3EKrtSGq7aMTTekRbip2P5Z2P+SbVXYbOel9zrhE6JIjvY1NQuxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Topological-Sort-Image-2\"\n        title=\"Topological-Sort-Image-2\"\n        src=\"/static/f23b61740af112c122b9c94e08b7409f/9144d/topologicalsort_2.png\"\n        srcset=\"/static/f23b61740af112c122b9c94e08b7409f/991de/topologicalsort_2.png 173w,\n/static/f23b61740af112c122b9c94e08b7409f/e4d6b/topologicalsort_2.png 345w,\n/static/f23b61740af112c122b9c94e08b7409f/9144d/topologicalsort_2.png 401w\"\n        sizes=\"(max-width: 401px) 100vw, 401px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>The corresponding adjacency list would be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">0 -&gt; 3 -&gt; 4\n1 -&gt; 4\n2 -&gt; 5\n3 -&gt; 6\n4 -&gt; 6\n5 -&gt; 7\n6 -&gt; 7\n7</code></pre></div>\n<p>Ok,so if we run <a href=\"/directed-graphs#depth-first-search\">digraph dfs</a> on this graph, we'd get this output:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">0 3 6 7 4 1 2 5 </code></pre></div>\n<p>Although this actually follows the correct sequence of courses, it doesn't end at <code class=\"language-cpptext\">7</code> and also it's a coincidence that we start at 0 and it happens to be the vertex that is without any pre-reqs, otherwise it would've failed at that part too. So, it is clear that a simple DFS won't do.</p>\n<p>Also, topoligcal sort won't be possible for a graph that has a cycle. That is because if I need to complete <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span> before <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span> and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span> before <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span></span> and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span></span> before <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span>, then theer's a problem in the logic!</p>\n<p>Therefore, our topological sort algorithm should be able to do this: <strong>Given a digraph, put the vertices in an order such that all directed edges point from a vertex earlier in the sequence to a vertex later in the sequence. Otherwise return that such an arrangement is not possible.</strong></p>\n<h3 id=\"depth-first-orders\" style=\"position:relative;\"><a href=\"#depth-first-orders\" aria-label=\"depth first orders permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Depth First Orders</h3>\n<p>It turns out, topological sort is quite easy to implement using DFS. As we've already seen, <a href=\"directed-graphs#depth-first-search\">DFS</a> visits each vertex exactly once. For our reference, here is recursive DFS again:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber 0\" class=\"language-cppcpp line-numbers\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> <span class=\"token class-name\">Digraph</span><span class=\"token operator\">::</span><span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    visited<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> v <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> adjList<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> curr <span class=\"token operator\">=</span> adjList<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>visited<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            edgeTo<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>If we save the current vertex we're on in an appropriate data structure (<a href=\"/queue\">queue</a> or <a href=\"/stack\">stack</a>), and iterate over these populated data structures, we'd be able to get our vertices in a certain order based on the data structure used and the point in the <code class=\"language-cpptext\">RecursiveDFS()</code> function where we push the vertex on the said data structure. Having said that, there are 3 vertex orderings that can be generated:</p>\n<ul>\n<li>PreOrder</li>\n<li>PostOrder</li>\n<li>Reverse PostOrder</li>\n</ul>\n<p>We've already seen PreOrder and PostOrder in the <a href=\"/binary-search-trees#traversal\">binary search trees</a> post. Here's what this traversal order means for digraphs:</p>\n<ul>\n<li>PreOrder: Put the vertex on queue <strong>before</strong> recursive call: <strong>This is recording of vertices in order based on DFS calls made</strong></li>\n<li>PostOrder: Put the vertex on queue <strong>after</strong> recursive call: <strong>This is the recording of vertices in order based on which vertices are completed first</strong></li>\n<li>ReversePostOrder: Put the vertex on stack <strong>after</strong> recursive call: <strong>This generates a topological sort for us from the digraph</strong></li>\n</ul>\n<p>Why is it the case that reverse post order creates topological sort for us? Let's break it down. What is post order? Post order traversal is: visit left child, visit right child and then visit the node ie LRN. Now, if you run post-order on a tree, the last node to be printed is the root node ie the node with NO PARENTS. Now, if we place all the post-order elements on a stack, then the last one to be popped off is the root. Therefore, by placing the elements in <strong>post-order</strong> traversal on a stack, we've reversed the order of visits! Thus creating <strong>reverse post order</strong>. As a result, as we pop elements off the stack, the first element to be popped off would have NO PARENT (ie no dependencies, no pre-reqs, the introductory course!). Therefore, reverse post order allows us to generate a topological sorting for our graph!</p>\n<h3 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h3>\n<p>The code is exactly the same as what we've seen so far for directed graphs. The only difference is in the <code class=\"language-cpptext\">RecursiveDFS()</code> function and we've also created a helper function to print the depth first search in the order we discussed in the previous section. Here are the functions we updated:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber 0\" class=\"language-cppcpp line-numbers\"><code class=\"language-cppcpp\"><span class=\"token comment\">//Private instance variables for data structures:</span>\n    queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> pre<span class=\"token punctuation\">;</span>\n    queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> post<span class=\"token punctuation\">;</span>\n    stack<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> reversePost<span class=\"token punctuation\">;</span> \n\n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Digraph</span><span class=\"token operator\">::</span><span class=\"token function\">PrintOrder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Pre: \"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pre<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> pre<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n        pre<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Post: \"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>post<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> post<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n        post<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Reverse Post: \"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>reversePost<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> reversePost<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n        reversePost<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Digraph</span><span class=\"token operator\">::</span><span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> visited<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Digraph</span><span class=\"token operator\">::</span><span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    visited<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//    cout &lt;&lt; v &lt;&lt; \" \";</span>\n    pre<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> adjList<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> curr <span class=\"token operator\">=</span> adjList<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>visited<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            edgeTo<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    post<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    reversePost<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>As usual, we've got 2 <code class=\"language-cpptext\">RecursiveDFS()</code> functions: the one on line 27 is called by the client and it iterates over the visited array. This function then, for each unvisited vertex, calls the <code class=\"language-cpptext\">RecursiveDFS(int v)</code> function which then populates our <code class=\"language-cpptext\">pre</code>, <code class=\"language-cpptext\">post</code> and <code class=\"language-cpptext\">reversePost</code> data structures.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber 26\" class=\"language-cppcpp line-numbers\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> <span class=\"token class-name\">Digraph</span><span class=\"token operator\">::</span><span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> visited<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Digraph</span><span class=\"token operator\">::</span><span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    visited<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//    cout &lt;&lt; v &lt;&lt; \" \";</span>\n    pre<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> adjList<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> curr <span class=\"token operator\">=</span> adjList<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>visited<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            edgeTo<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    post<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    reversePost<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-cpptext\">pre</code> is populated as soon as we visit the vertex as denoted on line 38 by pushing the vertex to the queue.\n<code class=\"language-cpptext\">post</code> is populated after we're done processing a vertex and visiting all its neighbors as denoted on line 46 by pushing the vertex to the queue.\n<code class=\"language-cpptext\">reversePost</code> is populated after we're done processing a vertex and visiting all its neighbors as denoted on line 47 by pushing the vertex to the stack.</p>\n<h3 id=\"explanation\" style=\"position:relative;\"><a href=\"#explanation\" aria-label=\"explanation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Explanation</h3>\n<p>Let's look at how having <code class=\"language-cpptext\">reversePost</code> in that position and using a stack allows us to get a topologically sorted order of vertices:</p>\n<p>From the explanations earlier, it is clear that we want to start our academic career by taking a class that has no pre-requisites. Let's examine the vertices of our graph:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 401px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f23b61740af112c122b9c94e08b7409f/9144d/topologicalsort_2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.41040462427746%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABwklEQVQ4y41UXU/bMBTN394/2PMepmk8rxLSHraHVYIHNAodrZAqsg6o0DZQQFRrC0ns+CN27IPi4jRN2sGRrhLfax2fe3KdwFrAWOvCNsKjmTfWuP31mkcArBZN5NpAFWZrvU5UIwT2zsfojkMUUoNRBp5xkAXBh8MDfBocw8iiyksi0P0ZYu9ivEbqn47wazjC7uAEggioXEEKiZxJDP/e4Cy6hcm1y2mtMY9m6Bwd4/PpoNVy+QzqcjllYJRvbbFUmaXUuWSUAY3Jkggr0qDpg+QS6WMKrXSVU1K5XC7yiqCEYALJLF7z1CmUunDhYQqD+d0M4XWEP9N/4CmDMWatxeJ5/es6wruDfTwysfJwpz/Ax14POZUgMUGWUCzuH/C2+w2d4clGrxwKg/DqBu+PfiDhckU4iu4xiu6qzf70clMmVZWvz19pQ7JIoJ/rVcvNAX4Nyo9HY1qNcGnH2tj4m7LswuJyOkXCOGxh3BiVoYVC//cV+pMJFMtbIrwlQbPwkAm8+bKLw8sJDFegaQZGGMg8xU7vOzqnQ3gRLU+9wuZJt3EKrtSGq7aMTTekRbip2P5Z2P+SbVXYbOel9zrhE6JIjvY1NQuxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Topological-Sort-Image-2\"\n        title=\"Topological-Sort-Image-2\"\n        src=\"/static/f23b61740af112c122b9c94e08b7409f/9144d/topologicalsort_2.png\"\n        srcset=\"/static/f23b61740af112c122b9c94e08b7409f/991de/topologicalsort_2.png 173w,\n/static/f23b61740af112c122b9c94e08b7409f/e4d6b/topologicalsort_2.png 345w,\n/static/f23b61740af112c122b9c94e08b7409f/9144d/topologicalsort_2.png 401w\"\n        sizes=\"(max-width: 401px) 100vw, 401px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>which is represented by this adjacency list:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">0 -&gt; 3 -&gt; 4\n1 -&gt; 4\n2 -&gt; 5\n3 -&gt; 6\n4 -&gt; 6\n5 -&gt; 7\n6 -&gt; 7\n7</code></pre></div>\n<p>It is clear that we want to end at 7 (where 7 = degree attained). We can start with either 2,1 or 0 and then move on from there. Let's say we start our DFS function at vertex 0. DFS will continue searching away from 0 until it runs into a dead-end. That dead-end occurs for us at vertex 7. At this point we push 7 to our stack. We then unwind the recursive call and go to 6 which had called 7. 6 is only connected to 7 so 6's execution ends and we push 6 onto the stack. We keep doing this until we've run out of elements to push. So, this is what we see when we print <code class=\"language-cpptext\">reversePost</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">2 5 1 0 4 3 6 7</code></pre></div>\n<p>The key insight here is this: the last thing to go onto the <code class=\"language-cpptext\">reversePost</code> stack is the vertex that has no dependencies. So, when we start popping items off this stack, it'll be from the vertex that has no dependencies and continues until the last vertex.</p>\n<p>Let's step through the 2 functions and look at how <code class=\"language-cpptext\">reversePost</code> is populated:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber 26\" class=\"language-cppcpp line-numbers\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> <span class=\"token class-name\">Digraph</span><span class=\"token operator\">::</span><span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> visited<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Digraph</span><span class=\"token operator\">::</span><span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    visited<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    pre<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> adjList<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> curr <span class=\"token operator\">=</span> adjList<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>visited<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            edgeTo<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">RecursiveDFS</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    post<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    reversePost<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Ok, so the client calls <code class=\"language-cpptext\">RecursiveDFS()</code> on line 27 which starts our loop by checking <code class=\"language-cpptext\">visited</code>. Initially this is what our <code class=\"language-cpptext\">visited</code> array, call stack and <code class=\"language-cpptext\">reversePost</code> stack look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   F\n1   F\n2   F\n3   F\n4   F\n5   F\n6   F       ___________     ________________\n7   F       reversePost     call stack for v</code></pre></div>\n<p>We start with 0, and call <code class=\"language-cpptext\">RecursiveDFS(0)</code>. In this function we set <code class=\"language-cpptext\">visited[0]</code> to true and pick up <code class=\"language-cpptext\">0</code>'s adjacency list:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F\n2   F\n3   F\n4   F\n5   F                              0\n6   F       ___________     ________________\n7   F       reversePost     call stack for v</code></pre></div>\n<p>In <code class=\"language-cpptext\">0</code>'s adjacency list, we find <code class=\"language-cpptext\">3</code> which is also unvisited, so we halt <code class=\"language-cpptext\">0</code>'s execution and call <code class=\"language-cpptext\">RecursiveDFS(3)</code>. Here, we set <code class=\"language-cpptext\">visited[3]</code> as true and look at 3's adjacency list:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F\n2   F\n3   T\n4   F                              3\n5   F                              0\n6   F       ___________     ________________\n7   F       reversePost     call stack for v</code></pre></div>\n<p>In 3's adjacency list, we find <code class=\"language-cpptext\">6</code> which is unvisited as well so we call <code class=\"language-cpptext\">RecursiveDFS(6)</code>. Here, we set <code class=\"language-cpptext\">visited[6]</code> as true and look at 6's adjacency list:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F\n2   F\n3   T                              6\n4   F                              3\n5   F                              0\n6   T       ___________     ________________\n7   F       reversePost     call stack for v</code></pre></div>\n<p>In 6's adjacency list, we find <code class=\"language-cpptext\">7</code> which is unvisited as well so we call <code class=\"language-cpptext\">RecursiveDFS(7)</code>. Here, we set <code class=\"language-cpptext\">visited[7]</code> as true and look at 7's adjacency list:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F\n2   F                              7\n3   T                              6\n4   F                              3\n5   F                              0\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>7's adjacency list is empty, so there's nothing to visit. We're currently at 7 so we fall through the for loop on line 38 and push <code class=\"language-cpptext\">v</code> to <code class=\"language-cpptext\">reversePost</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F\n2   F                              7\n3   T                              6\n4   F                              3\n5   F           7                  0\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>We're done with 7, so we pop 7 off the call stack for v and continue with 6:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F\n2   F                              \n3   T                              6\n4   F                              3\n5   F           7                  0\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>We continue to inspect 6's adjacency list which doesn't have any other vertices other than 7. So, again, we fall through the for loop on line 38 for vertex 6 and push the current <code class=\"language-cpptext\">v</code> to <code class=\"language-cpptext\">reversePost</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F\n2   F                              \n3   T                              \n4   F           6                  3\n5   F           7                  0\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>Next, we find 3 on the call stack and we go to 3's adjacency list that, again, has nothing but 6 so we fall though the for loop for vertex 3 and push current <code class=\"language-cpptext\">v</code> to <code class=\"language-cpptext\">reversePost</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F\n2   F                              \n3   T           3                   \n4   F           6                  \n5   F           7                  0\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>We're now back to 0. 0's adjacency list has more vertices so we pick up the next available vertex which is 4. We call <code class=\"language-cpptext\">RecursiveDFS(4)</code> and set <code class=\"language-cpptext\">visited[4]</code> to true. Our new <code class=\"language-cpptext\">v</code> is now 4:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F\n2   F                              \n3   T           3                   \n4   T           6                  4\n5   F           7                  0\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>4's adjacency list has 6 which is already visited so we're done with 4. We fall through the for loop on line 38 and push 4 to the <code class=\"language-cpptext\">reversePost</code> stack:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F\n2   F           4                   \n3   T           3                   \n4   T           6                  \n5   F           7                  0\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>We're now back to 0 that doesn't have any more unvisited neighbors. So, we fall through to line 38 for 0 and push 0 onto <code class=\"language-cpptext\">reversePost</code> stack:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   F           0\n2   F           4                   \n3   T           3                   \n4   T           6                  \n5   F           7                  \n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>We send control back up to the original <code class=\"language-cpptext\">RecursiveDFS()</code> function on line 27. Here, we continue looking for unvisited vertices and find that 1 is unvisited. We, therefore make this call: <code class=\"language-cpptext\">RecursiveDFS(1)</code>. For this call, we mark <code class=\"language-cpptext\">visited[1]</code> as true, and check out 1's adjacency list:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T\n1   T           0\n2   F           4                   \n3   T           3                   \n4   T           6                  \n5   F           7                  1\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>We find that 4 is already visited so we fall through to line 47 and push the current v onto the <code class=\"language-cpptext\">reversePost</code> stack after which we're done with this v which is popped of call stack for v:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T           1\n1   T           0\n2   F           4                   \n3   T           3                   \n4   T           6                  \n5   F           7                  \n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>We send control back up to the original <code class=\"language-cpptext\">RecursiveDFS()</code> function on line 27. Here, we continue looking for unvisited vertices and find that 2 is unvisited. We, therefore make this call: <code class=\"language-cpptext\">RecursiveDFS(2)</code>. For this call, we mark <code class=\"language-cpptext\">visited[2]</code> as true, and check out 2's adjacency list:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T           1\n1   T           0\n2   T           4                   \n3   T           3                   \n4   T           6                  \n5   F           7                  2\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>We look in 2's adjacency list and find 5. 5 is unvisited so we make another recursive call with 5 and halt 2's execution. For 5, we mark it as true:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited\n0   T           1\n1   T           0\n2   T           4                   \n3   T           3                   \n4   T           6                  5\n5   T           7                  2\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>and then we check out 5's adjacency list which only has 7 which has already been visited. So, for 5, we fall down to line 47, push 5 onto <code class=\"language-cpptext\">reversePost</code> and pop 5 off call stack for v:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited         \n                5\n0   T           1\n1   T           0\n2   T           4                   \n3   T           3                   \n4   T           6                  \n5   T           7                  2\n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>We then continue with 2 where we left off and find that 2 has no more neighbors. We fall to line 47 for 2, push to <code class=\"language-cpptext\">reversePost</code> and pop 2 off stack:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">\nvisited         \n                2\n                5\n0   T           1\n1   T           0\n2   T           4                   \n3   T           3                   \n4   T           6                  \n5   T           7                  \n6   T       ___________     ________________\n7   T       reversePost     call stack for v</code></pre></div>\n<p>We send control back up to the original <code class=\"language-cpptext\">RecursiveDFS()</code> function on line 27. Here, we continue looking for unvisited vertices and find that all vertices have been visited now. We're done with creating our <code class=\"language-cpptext\">reversePost</code> stack.</p>\n<h3 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h3>\n<p>Notice how the last element we pushed on stack were in reverse order based on their dependencies. For example if 5 is dependent on 2, we pushed 5 first and then we pushed 2. Now when we print <code class=\"language-cpptext\">reversePost</code> by popping off each element, we get this order:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">2 5 1 0 4 3 6 7 </code></pre></div>\n<p>This order clearly complies with all the dependencies before we get to graduation!!!</p>\n<h3 id=\"digraphs-cycles-and-topological-sort\" style=\"position:relative;\"><a href=\"#digraphs-cycles-and-topological-sort\" aria-label=\"digraphs cycles and topological sort permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Digraphs, Cycles and Topological Sort</h3>\n<p>Now that we've looked at <a href=\"/directed-graphs\">digraphs</a>, <a href=\"/cycle-detection\">cycles</a> and <a href=\"/topological-sort#logic\">topological sort</a>, we've completed all the important parts of a job-scheduling application:</p>\n<ul>\n<li>You specify the tasks and the relevant constraints for those tasks (which task needs to be performed first, second, and so on): this is the digraph</li>\n<li>You make sure that there are no cycles</li>\n<li>You then generate an order in which the tasks can be completed based on the constraints specified using the digraph: this is where topological sort comes in.</li>\n</ul>","timeToRead":14,"excerpt":"Table of Contents Motivation Logic Depth First Orders Code Explanation Conclusion Digraphs, Cycles and Topological Sort In this post, I'll…","frontmatter":{"title":"Topological Sort","date":"2020-03-12T00:00:00.000Z","categories":["Graphs"],"extract":"Analysis of topological sort algorithm","thumbnail":"/post-images/topology.png","tags":["Graphs","Sorting Algorithms"]},"fields":{"slug":"/topological-sort","date":"March 12, 2020"}}},"pageContext":{"slug":"/topological-sort","nexttitle":"Cycle Detection","nextslug":"/cycle-detection","prevtitle":"Minimum Spanning Tree","prevslug":"/minimum-spanning-tree"}},"staticQueryHashes":["3969716136"]}