{"componentChunkName":"component---src-templates-post-js","path":"/quick-sort","result":{"data":{"markdownRemark":{"html":"<h3 id=\"table-of-contents\"><a href=\"#table-of-contents\" aria-label=\"table of contents permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Table of Contents</h3>\n<ol>\n<li><a href=\"#introduction\">Introduction</a></li>\n<li><a href=\"#logic\">Logic</a></li>\n<li><a href=\"#sort\">Sort</a></li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n</ol>\n<h3 id=\"introduction\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h3>\n<p>In this post I'll talk about a sorting algorithm called Quick Sort. Idea behind quick sort is similar to what merge sort does: divide and conquer. However, quick sort does the heavy lifting before it recurses. Let's have a look at an example: </p>\n<h3 id=\"logic\"><a href=\"#logic\" aria-label=\"logic permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Logic</h3>\n<p>Here're the three basic steps of quick sort:</p>\n<ul>\n<li>Shuffle the array so that the elements are in random order</li>\n<li>Choose a <code class=\"language-cpptext\">pivot</code>: an item that has all the elements less than it to its left and elements greater than it to its right</li>\n<li>Repeat these steps for each half of the array </li>\n</ul>\n<p>Let's start with a sample array and see how we can use quick sort to sort it:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token number\">5</span>   <span class=\"token number\">3</span>   <span class=\"token number\">1</span>   <span class=\"token number\">2</span>   <span class=\"token number\">7</span>   <span class=\"token number\">4</span>   <span class=\"token number\">8</span>   <span class=\"token number\">6</span></code></pre></div>\n<p>Let's say our pivot is 5, located at <code class=\"language-cpptext\">arr[0]</code>. We'll have 3 pointers:</p>\n<ul>\n<li><code class=\"language-cpptext\">i</code> that points to <code class=\"language-cpptext\">arr[1]</code></li>\n<li><code class=\"language-cpptext\">j</code> that points to the last element in the array</li>\n<li><code class=\"language-cpptext\">k</code> that points to the pivot</li>\n</ul>\n<p><code class=\"language-cpptext\">i</code> and <code class=\"language-cpptext\">j</code> will be used to define our <strong>sort</strong> window. In the first iteration, this window would be the entire array.</p>\n<p>Ok, so what do we do with these pointers? </p>\n<ul>\n<li>If <code class=\"language-cpptext\">i</code> is at an element that is smaller than pivot, keep incrementing <code class=\"language-cpptext\">i</code>.</li>\n<li>If <code class=\"language-cpptext\">j</code> is at an element that is greater than pivot, keep decrementing <code class=\"language-cpptext\">j</code>.</li>\n<li>When <code class=\"language-cpptext\">arr[i]</code> is greater than pivot AND <code class=\"language-cpptext\">arr[j]</code> is less than pivot, swap <code class=\"language-cpptext\">arr[i]</code> and <code class=\"language-cpptext\">arr[j]</code>.</li>\n<li>Continue doing so until <code class=\"language-cpptext\">i</code> and <code class=\"language-cpptext\">j</code> cross over. </li>\n</ul>\n<p>Start:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token number\">5</span>   <span class=\"token number\">3</span>   <span class=\"token number\">1</span>   <span class=\"token number\">2</span>   <span class=\"token number\">7</span>   <span class=\"token number\">4</span>   <span class=\"token number\">8</span>   <span class=\"token number\">6</span>\nk   i                       j</code></pre></div>\n<p>arr[i] is less than pivot, increment <code class=\"language-cpptext\">i</code>. arr[j] is greater than pivot, decrement <code class=\"language-cpptext\">j</code>. Keep incrementing <code class=\"language-cpptext\">i</code> and decrementing <code class=\"language-cpptext\">j</code> until <code class=\"language-cpptext\">i</code> lands on something that is greater than pivot and <code class=\"language-cpptext\">j</code> lands on something that is smaller than the pivot:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token number\">5</span>   <span class=\"token number\">3</span>   <span class=\"token number\">1</span>   <span class=\"token number\">2</span>   <span class=\"token number\">7</span>   <span class=\"token number\">4</span>   <span class=\"token number\">8</span>   <span class=\"token number\">6</span>\nk               i   j</code></pre></div>\n<p>Ok! We found a case where that holds true. Swap <code class=\"language-cpptext\">arr[i]</code> with <code class=\"language-cpptext\">arr[j]</code> increment <code class=\"language-cpptext\">i</code> and decrement <code class=\"language-cpptext\">j</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token number\">5</span>   <span class=\"token number\">3</span>   <span class=\"token number\">1</span>   <span class=\"token number\">2</span>   <span class=\"token number\">4</span>   <span class=\"token number\">7</span>   <span class=\"token number\">8</span>   <span class=\"token number\">6</span>\nk               j   i</code></pre></div>\n<p>At this point, swap <code class=\"language-cpptext\">j</code> with <code class=\"language-cpptext\">k</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token number\">4</span>   <span class=\"token number\">3</span>   <span class=\"token number\">1</span>   <span class=\"token number\">2</span>   <span class=\"token number\">5</span>   <span class=\"token number\">7</span>   <span class=\"token number\">8</span>   <span class=\"token number\">6</span>\nk               j   i</code></pre></div>\n<p>Notice now that ALL elements to the left of <code class=\"language-cpptext\">j</code> (4,3,1,2) are less than <code class=\"language-cpptext\">arr[j]</code> and all elements to the right of <code class=\"language-cpptext\">j</code> (7,8,6) are greater than <code class=\"language-cpptext\">arr[j]</code>. We also want to capture what position we partitioned based off so that we can determine what the left and right halves should be. </p>\n<p>Now, in the example above we always chose <code class=\"language-cpptext\">arr[0]</code> as our pivot that can degenerate running time of quick sort to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> if our array is in sorted order. That is because each time we pick the smallest element in the array and on each call to partition, we iterate over the entire array from left to right. This is why, a better approach is to use a median of 3: look at the first, middle and last element in the array and find the median of three. For example, if we have a sorted array like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token number\">1</span>   <span class=\"token number\">2</span>   <span class=\"token number\">3</span>   <span class=\"token number\">4</span>   <span class=\"token number\">5</span>   <span class=\"token number\">6</span>   <span class=\"token number\">7</span>   <span class=\"token number\">8</span>   <span class=\"token number\">9</span></code></pre></div>\n<p>you'll look at 1, (0 + (8-0)/2) which is 5 and 9. You find that 5 is the median because 1 &#x3C; 5 &#x3C; 9. So you choose 5 as the pivot and move it to the front of the array:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token number\">5</span>   <span class=\"token number\">2</span>   <span class=\"token number\">3</span>   <span class=\"token number\">4</span>   <span class=\"token number\">1</span>   <span class=\"token number\">6</span>   <span class=\"token number\">7</span>   <span class=\"token number\">8</span>   <span class=\"token number\">9</span></code></pre></div>\n<p>and now you run your partition on this array. This allows us to handle cases where the array is already sorted.</p>\n<p>Here's the code for our partition function:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber 0\" class=\"language-cppcpp line-numbers\"><code class=\"language-cppcpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> A<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//Median of three pivot calculation</span>\n    <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> <span class=\"token function\">medianOfThree</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    A<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n    pivot <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n    i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> A<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">&lt;=</span> j<span class=\"token punctuation\">)</span>\n            i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> A<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">>=</span> i<span class=\"token punctuation\">)</span>\n            j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">>=</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            A<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n        i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> j<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//Function to calculate median of three</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">medianOfThree</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> A<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>j<span class=\"token operator\">-</span>i<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> A<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        pivot <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> j <span class=\"token operator\">:</span> m<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> A<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        pivot <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> i <span class=\"token operator\">:</span> m<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        pivot <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> i <span class=\"token operator\">:</span> j<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> pivot<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Also, notice that before we begin partitioning, we always place the pivot at the <code class=\"language-cpptext\">ith</code> index so that we have it out of the way. Once we're done moving the elements around, we place the pivot in its correct position by swapping it with whatever is at <code class=\"language-cpptext\">A[j]</code>.</p>\n<p>The partition function returns an integer that we just partitioned the array around. Meaning that that number is now in its correct position. So, remaining iterations would now take place after excluding the <code class=\"language-cpptext\">j</code>s. We also have a median of three function that calculates which integer needs to be the pivot. </p>\n<h3 id=\"sort\"><a href=\"#sort\" aria-label=\"sort permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sort</h3>\n<p>Here's the code that calls itself recursively and in turn calls the partitioning function:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> A<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> lo<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> hi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lo <span class=\"token operator\">==</span> hi<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span> lo<span class=\"token punctuation\">,</span>hi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span> lo<span class=\"token punctuation\">,</span> p<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span> p<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>hi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If <code class=\"language-cpptext\">lo == hi</code>, it means that we don't have anything to sort because the indices we passed in signify that we're looking at just 1 element. This would be our base case. If we have multiple elements to partition, we call the partition function and swap all elements less than the calculated partition (using the median of 3 approach) and return the position we just partitioned around. Next, we call quicksort again but this time with left and right parts of the array. </p>\n<h3 id=\"conclusion\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h3>\n<p>So, to conclude, we can use quick sort and median of three to get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NlogN)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> average case running time. We use median of three to make sure that even if we get a partially or completely sorted array, our running time doesn't degenerate to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>. Quick sort also uses <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> amount of extra memory since we do not copy over the array in any step. </p>","timeToRead":5,"excerpt":"Table of Contents Introduction Logic Sort Conclusion Introduction In this post I'll talk about a sorting algorithm called Quick Sort. Idea…","frontmatter":{"title":"Quick Sort","date":"2020-04-09T00:00:00.000Z","categories":["Algorithms"],"extract":"Explanation and implementation of quick sort algorithm","thumbnail":"/post-images/quick.png","tags":["Sorting Algorithms","Quick Sort"]},"fields":{"slug":"/quick-sort","date":"April 09, 2020"}}},"pageContext":{"slug":"/quick-sort","nexttitle":"Rabin Karp Algorithm","nextslug":"/rabin-karp-algorithm","prevtitle":"Arrays","prevslug":"/arrays"}}}