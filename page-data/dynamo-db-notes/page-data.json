{"componentChunkName":"component---src-templates-post-js","path":"/dynamo-db-notes","result":{"data":{"markdownRemark":{"html":"<p><strong>My notes as I walk through the great book on DynamoDB - <a href=\"https://www.dynamodbbook.com/\">DynamoDB Book by Alex DeBrie</a></strong> All images and examples used below are taken from the linked book.</p>\n<h3 id=\"table-of-contents\" style=\"position:relative;\"><a href=\"#table-of-contents\" aria-label=\"table of contents permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Table of Contents</h3>\n<ol>\n<li><a href=\"#table\">Table</a></li>\n<li><a href=\"#item\">Item</a></li>\n<li><a href=\"#attributes\">Attributes</a></li>\n<li><a href=\"#primary-key\">Primary Key</a></li>\n<li><a href=\"#secondary-indexes\">Secondary indexes</a></li>\n<li><a href=\"#item-collections\">Item Collections</a></li>\n<li><a href=\"#ddb-streams\">DDB Streams</a></li>\n<li><a href=\"#ttl\">TTL</a></li>\n<li><a href=\"#overloading-keys-and-indexes\">Overloading keys and indexes</a></li>\n<li><a href=\"#api-actions\">API Actions</a></li>\n<li><a href=\"#item-based-actions\">Item Based Actions</a></li>\n<li><a href=\"#query\">Query</a></li>\n<li><a href=\"#scan\">Scan</a></li>\n<li><a href=\"#expressions\">Expressions</a></li>\n<li><a href=\"#ddb-vs-rdb-data-modeling\">DDB vs RDB Data Modeling</a></li>\n<li><a href=\"#modeling-with-ddb\">Modeling with DDB</a>\n<ul>\n<li><a href=\"#erd\">ERD</a></li>\n<li><a href=\"#define-access-patterns\">Define Access Patterns</a></li>\n<li><a href=\"#model-primary-key-structure\">Model primary key structure</a></li>\n<li><a href=\"#secondary-indexes-and-streams\">Secondary Indexes and Streams</a></li>\n</ul>\n</li>\n<li><a href=\"#single-table-design\">Single Table Design</a></li>\n<li><a href=\"#when-not-to-use-single-table-design\">When not to use single-table design</a></li>\n<li><a href=\"#one-to-many-relationship\">One to Many Relationship</a></li>\n</ol>\n<h3 id=\"table\" style=\"position:relative;\"><a href=\"#table\" aria-label=\"table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Table</h3>\n<p>The first basic concept in DynamoDB is a table. A DynamoDB table is similar in some ways to a table in a relational database or a collection in MongoDB. It is a grouping of records that conceptually belong together. For example, your table could be a collection of notifications you generate for a set of tools that you own.</p>\n<p>You often include multiple entity types in the same DynamoDB table. This is to avoid the join operation, which is expensive as a database scales.</p>\n<p>With DynamoDB, you do not declare all of your columns and column types on your table. At the database level, DynamoDB is schemaless, meaning the table itself won’t ensure your records conform to a given schema.</p>\n<h3 id=\"item\" style=\"position:relative;\"><a href=\"#item\" aria-label=\"item permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Item</h3>\n<p>An item is a single record in a DynamoDB table. It is comparable to a row in a relational database or a document in MongoDB. In our notifications example earlier, an item could be a single notification for a tool with notification information such as message, notification start time, tool name etc.</p>\n<h3 id=\"attributes\" style=\"position:relative;\"><a href=\"#attributes\" aria-label=\"attributes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Attributes</h3>\n<p>A DynamoDB item is made up of attributes, which are typed data values holding information about the element. For our notification, you might have an attribute named \"toolName\" with a value of \"permissionsTool\".</p>\n<p>When you write an item to DynamoDB, each attribute is given a specific type. There are ten different data types in DynamoDB. It’s helpful to split them into three categories:</p>\n<p><strong>- Scalars</strong></p>\n<p>Scalars represent a single, simple value, such as a username (string) or an age (integer). There are five scalar types: string, number, binary, boolean, and null.</p>\n<p><strong>- Complex</strong></p>\n<p>Complex types are the most flexible kind of attribute, as they represent groupings with arbitrary nested attributes. There are two complex types: lists and maps. You can use complex attribute types to hold related elements.</p>\n<p><strong>- Sets</strong></p>\n<p>Sets are a powerful compound type that represents multiple, unique values. They are similar to sets in your favorite programming language. You can use sets to keep track of unique items, making it easy to track the number of distinct elements without needing to make multiple round trips to the database.</p>\n<p>The type of attribute affects which operations you can perform on that attribute in subsequent operations. For example, if you have a number attribute, you can use an update operation to add or subtract from the attribute. If you use a set attribute, you can check for the existence of a particular value before updating the item.</p>\n<h3 id=\"primary-key\" style=\"position:relative;\"><a href=\"#primary-key\" aria-label=\"primary key permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Primary Key</h3>\n<p>When creating a DynamoDB table, you must declare a primary key for your table. The primary key can be simple, consisting of a single value, or composite, consisting of two values. Each item in your table is uniquely identifiable by its primary key. Almost all of your data access will be driven off primary keys, so you need to choose them wisely.</p>\n<p>In DynamoDB, there are two kinds of primary keys:</p>\n<p>• <strong>Simple primary keys</strong>, which consist of a single element called a partition key.</p>\n<p>• <strong>Composite primary keys</strong>, which consist of two elements, called a partition key and a sort key.</p>\n<p>The type of primary key you choose will depend on your access patterns. A simple primary key allows you to fetch only a single item at a time. It works well for one-to-one operations where you are only operating on individual items.</p>\n<p>Composite primary keys, on the other hand, enable a \"fetch many\" access pattern. With a composite primary key, you can use the Query API to grab all items with the same partition key. You can even specify conditions on the sort key to narrow down your query space. Composite primary keys are great for handling relations between items in your data and for retrieving multiple items at once.</p>\n<h3 id=\"secondary-indexes\" style=\"position:relative;\"><a href=\"#secondary-indexes\" aria-label=\"secondary indexes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Secondary indexes</h3>\n<p>The way you configure your primary keys may allow for one read or write access pattern but may prevent you from handling a second access pattern. To help with this problem, DynamoDB has the concept of secondary indexes. Secondary indexes allow you to reshape your data into another format for querying, so you can add additional access patterns to your data.</p>\n<p>When you create a secondary index on your table, you specify the primary keys for your secondary index, just like when you’re creating a table. AWS will copy all items from your main table into the secondary index in the reshaped form. You can then make queries against the secondary index.</p>\n<p>When creating a secondary index, you will need to specify the key schema of your index. The key schema is similar to the primary key of your table—you will state the partition and sort key (if desired) for your secondary index that will drive your access patterns.\nThere are two kinds of secondary indexes in DynamoDB:</p>\n<p>• <strong>Local secondary indexes</strong></p>\n<p>A local secondary index uses the same partition key as your table’s primary key but a different sort key. This can be a nice fit when you are often filtering your data by the same top-level property but have access patterns to filter your dataset further. The partition key can act as the top-level property, and the different sort key arrangements will act as your more granular filters.</p>\n<p>• <strong>Global secondary indexes</strong></p>\n<p>With a global secondary index, you can choose any attributes you want for your partition key and your sort key. Global secondary indexes are used much more frequently with DynamoDB due to their flexibility.</p>\n<p><em>There are a few other differences to note between local and global secondary indexes:</em></p>\n<p><em>For global secondary indexes, you need to provision additional throughput for the secondary index. The read and write throughput for the index is separate from the core table’s throughput. This is not the case for local secondary indexes, which use the throughput from the core table.</em></p>\n<p><em>With global secondary indexes, your only choice is eventual\nconsistency. Data is replicated from the core table to global secondary indexes in an asynchronous manner. This means it’s possible that the data returned in your global secondary index does not reflect the latest writes in your main table. The delay in replication from the main table to the global secondary indexes isn’t large, but it may be something you need to account for in your application.</em></p>\n<p><em>On the other hand, local secondary indexes allow you to opt for strongly-consistent reads if you want it. Strongly-consistent reads on local secondary indexes consume more read throughput than eventually-consistent reads, but they can be beneficial if you have strict requirements around consistency.</em></p>\n<p>Alex DeBrie says <em>I opt for global secondary indexes. They’re more flexible, you don’t need to add them at table-creation time, and you can delete them if you need to.</em></p>\n<p>Table showing the comparisons discussed above:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 597px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/43ccd6dea5e4df6d44a811175b5e33bd/17602/secondary-index-types.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.445086705202314%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQUlEQVQoz32S6a6CUAyEef+X84+yKIqKKARQXIgCQm++SUgIMbdJwzmly8z0ODazYRjser3Ki6Kw7/cr516Wpfz9flvXdZbnufx2u1nf96p1uJxOJ/2I49gej4dFUWTb7dY2m43iTdPoPMbIo2kQBHIGM4DBzvF4tOVyaa/XSyg+n4+KPM+z1Wql5m3bmu/7Kt7tdsolz3VdW6/XliSJ7phjP+x+v8tHelCpqkroRyPOENDu93vRFsKR+9TnRs78DCLQhWFodV2rIbSdeTN8HDIdNo1h6IqmoKQx0iHNT8pzlFOEU8o0QVMc6kJ4OBxssVho08A/n8/6yTLQBt1oSDF3FpZlmSizOBaF3uSpIZtN01SoEJUvhSRCiYEUg+JyueiJoBlDOOPox9KIOVOaI1UQghY0NEGb5/MpBP/JwMP+A/E7/ErAuxQpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Index-Types-Table\"\n        title=\"Index-Types-Table\"\n        src=\"/static/43ccd6dea5e4df6d44a811175b5e33bd/17602/secondary-index-types.png\"\n        srcset=\"/static/43ccd6dea5e4df6d44a811175b5e33bd/991de/secondary-index-types.png 173w,\n/static/43ccd6dea5e4df6d44a811175b5e33bd/e4d6b/secondary-index-types.png 345w,\n/static/43ccd6dea5e4df6d44a811175b5e33bd/17602/secondary-index-types.png 597w\"\n        sizes=\"(max-width: 597px) 100vw, 597px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"item-collections\" style=\"position:relative;\"><a href=\"#item-collections\" aria-label=\"item collections permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Item Collections</h3>\n<p>An item collection refers to a group of items that share the same partition key in either the base table or a secondary index. Let's look at a table that includes actors and actresses and the movies in which they’ve played roles. We could model this with a composite primary key where the partition key is Actor and the sort key is Movie. The table with some example data looks as follows:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 583px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3d5927b746c1196853435e3adc582a71/9fc4b/item-collections.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.491329479768794%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACN0lEQVQozz2RCY+bMBCF+f+/q6parZrtJoFkF0ggCebGGMx9fBWsVEvP4zfPxxuPkamWVHVkVc8jyrnentyDZOdbPlEtsWxIypak/I4iq/a9YV7/z0eyodQ9hu8+OP45cj1dOb+fcS8Ot4uD9X7GPJywz1/Ej5DIF4ResK+9z9uuP2zvvybuL2RaYLSWSeM46OsFbVl0vo/2feSW83y654vn0eR5vBBfXULLxv97Jro4O/f/mtwPR4RlU5wtjFEEzH3PWldQVbCudPOM7npWvkfV9mSqRtYN/bJSVBo9jEyAanuKWjMAQxBgaN9D9QPjsuyHt3le1v2yZf3mcV4ikoI4r8hVQxDnpHJ7oCNMJSLOKfRA7fkYk3eDaWTRmqVpWNoGnWWUcczcaOg6MhGRBiGtVDRSkbwEZZLRlhV5GCO8B2VW0Lkuxvh6MongG2HA9gWjeO18DgOWSBCeTcKzRXX3ke6d1/FE+vmFunlE5oXH+wfZp039eGLUXU8ma2bYy9xQNx250gwLTCtEecUzlgRJidTjHlPVotqZKK/xw4xMdbTjjHHyJm7RzMEd+fU58sMaebNHHDFjiwlbzLxdS36Z+R4/bi2/zYKDXXPyet6uip+nlIOtMf0B4+hWDK0iThWynpB6JcoqlFKM47A3KskkYZIjVUNZt4goI5c1SndEaYGIs72qk9dhfNw3N9OOzekGJ5z4CsbdoRPOXJ89H47i4rfc4pWL3+3aPV53zfIa3HDhS8z8A2LvOB36ZULEAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Item-Collections\"\n        title=\"Item-Collections\"\n        src=\"/static/3d5927b746c1196853435e3adc582a71/9fc4b/item-collections.png\"\n        srcset=\"/static/3d5927b746c1196853435e3adc582a71/991de/item-collections.png 173w,\n/static/3d5927b746c1196853435e3adc582a71/e4d6b/item-collections.png 345w,\n/static/3d5927b746c1196853435e3adc582a71/9fc4b/item-collections.png 583w\"\n        sizes=\"(max-width: 583px) 100vw, 583px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>There are four movie roles in this table. Notice that two of those movie roles have the same partition key: Tom Hanks. Those two movie role items are said to be in the same item collection. Likewise, the single movie role for Natalie Portman is in an item collection, even though it only has one item in it.</p>\n<p>Item collections are important for two reasons. First, they are useful for partitioning. DynamoDB partitions your data across a number of nodes in a way that allows for consistent performance as you scale. However, all items with the same partition key will be kept on the same storage node. This is important for performance reasons. Second, item collections are useful for data modeling.</p>\n<h3 id=\"ddb-streams\" style=\"position:relative;\"><a href=\"#ddb-streams\" aria-label=\"ddb streams permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DDB Streams</h3>\n<p>With DynamoDB streams, you can create a stream of data that includes a record of each change to an item in your table. Whenever an item is written, updated, or deleted, a record containing the details of that record will be written to your DynamoDB stream. You can then process this stream with AWS Lambda or other compute infrastructure.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 516px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3b55dfafee227c1de61f96a8bf2f2e07/75dcb/ddb-streams.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.6300578034682%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB4ElEQVQ4y5VTSW7UQBT1PbgKx+ASbLgCF8iSJaxYcwPEJqjVbBAxSeTY6cFj2W7H82yXH/o/6Za7E1pKSeXv+vWH915VKXjFmKbpyL60r+CVY19Mdj3qIEBpWig2W3Rxwn6FAl6a++Q5mrm/jR6QXt8i+XuD+I+KYr3B2HX/R3hKa16cEivho/ID1LsdKkLqCXRpCoU+tSdQByFqCqCNJD0qcoqchh+GcISAKwQ830cUx4+UK8dFequhuL5BcqUiM+650znxsyzDZr1GGAQQQiAMQ0RRhEnKJ8pyhKVtUOziZ8njOKJtW57DMCDPczRNg6qqUJYl/5MtiuIRIX2udBNvP3zGx68/EQY+DMPgjq7rwrZtTqb1drvlBoScUNKaYk3T5EaHa3P5W8Obdxd4/+kHPNflwCRJ4DgODF3HarViv2Wah+JE1fd9LBYLtlRQ7ik3TYsv377jl2pgkiMn9X2PpuuQlyXqtsUDNfA8jFIytTndvT0gZPGnAXLsD9oNFOgJnqXtsK1sB0kQsp7UkHSr65oBkO9wsbnoyf3ri5JPPNV0pNod0jsd+f0KkBJplrG+pN1yuYRlWceUz72Qse1QC//ZydOhxHEMVVXZEkryK+ce/+mzmzciinut55T/AT4kNR52jSxtAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"DDB-Streams\"\n        title=\"DDB-Streams\"\n        src=\"/static/3b55dfafee227c1de61f96a8bf2f2e07/75dcb/ddb-streams.png\"\n        srcset=\"/static/3b55dfafee227c1de61f96a8bf2f2e07/991de/ddb-streams.png 173w,\n/static/3b55dfafee227c1de61f96a8bf2f2e07/e4d6b/ddb-streams.png 345w,\n/static/3b55dfafee227c1de61f96a8bf2f2e07/75dcb/ddb-streams.png 516w\"\n        sizes=\"(max-width: 516px) 100vw, 516px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"ttl\" style=\"position:relative;\"><a href=\"#ttl\" aria-label=\"ttl permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TTL</h3>\n<p>TTLs allow you to have DynamoDB automatically delete items on a per-item basis. This is a great option for storing short-term data in DynamoDB as you can use TTL to clean up your database rather than handling it manually via a scheduled job.\nTo use TTL, you specify an attribute on your DynamoDB table that will serve as the marker for item deletion.</p>\n<p>For each item that you want to expire, you should store a Unix timestamp as a number in your specified attribute. This timestamp should state the time after which the item should be deleted. DynamoDB will periodically review your table and delete items that have your TTL attribute set to a time before the current time.</p>\n<p>Your application should be safe around how it handles items with TTLs. Items are generally deleted in a timely manner, but AWS only states that items will usually be deleted within 48 hours after the time indicated by the attribute. This delay could be unacceptable for the access patterns in your application. Rather than relying on the TTL for data accuracy in your application, you should confirm an item is not expired when you retrieve it from DynamoDB.</p>\n<h3 id=\"overloading-keys-and-indexes\" style=\"position:relative;\"><a href=\"#overloading-keys-and-indexes\" aria-label=\"overloading keys and indexes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overloading keys and indexes</h3>\n<p>One unique quirk of modeling with DynamoDB is that you will often include different types of entities in a single table. Including multiple entity types in one table will make for more efficient queries.</p>\n<p>Imagine you had a SaaS application and organizations signed up for your application, and each organization had multiple Users that belonged to the organization. Let’s start with a table that just has our organization items in it:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0e0c5030e11c86643efe47fe25872547/84a90/organizations.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 24.85549132947977%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4ElEQVQY0z2P247DIAxE8/8fuVIvIcRAABMgQFdT4Xb3wdJwbB0NS0wFnjOMC1DawoWEwBmBCzhVzP1nKvis8DHDx1Pef3zOvD/zhYVswP2546EI2ng8lcG6GZBjKPLYLUPbiI2CzG0l/NwUtImym2xmbRnWJyy1VnBKaK1hjCF5slwurIqkOaeCnRz0bqXlZNtupak9omTn+dPwag2lFPTe0ceQ3FpHmcKN5FCE5hBp5Awyh8hF6AI0ORwhfYVXQ85fYR+SJ2u9w/sorI8Xzn8+f3Hi8AE5V+HMCeP1K3dvQOB+Vg2GWukAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"organizations\"\n        title=\"organizations\"\n        src=\"/static/0e0c5030e11c86643efe47fe25872547/1e043/organizations.png\"\n        srcset=\"/static/0e0c5030e11c86643efe47fe25872547/991de/organizations.png 173w,\n/static/0e0c5030e11c86643efe47fe25872547/e4d6b/organizations.png 345w,\n/static/0e0c5030e11c86643efe47fe25872547/1e043/organizations.png 690w,\n/static/0e0c5030e11c86643efe47fe25872547/84a90/organizations.png 982w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>First, notice how generic the names of the partition key and sort key are. Rather than having the partition key named 'OrgName`, the partition key is titled PK, and the sort key is SK. That’s because we will also be putting User items into this table, and Users don’t have an OrgName. They have a UserName.</p>\n<p>Second, notice that the <code class=\"language-cpptext\">PK</code> and <code class=\"language-cpptext\">SK</code> values have prefixes. The pattern for both is <code class=\"language-cpptext\">ORG#&lt;OrgName&gt;</code>. We do this for a few reasons. First, it helps to identify the type of item that we’re looking at. Second, it helps avoid overlap between different item types in a table. Remember that a primary key must be unique across all items in a table. If we didn’t have this prefix, we could run into accidental overwrites. Imagine if the real estate company Keller Williams signed up for our application, and the musician Keller Williams was a user of our application. The two could overwrite each other!</p>\n<p>Let’s edit our table to add Users now. A table with both Organization and User entities might look as follows:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c5528ba2074d0967756eab372686c0da/ef916/users.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.58381502890174%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3UlEQVQ4y22TiY6rMAxF+/9/+DTqUzca1uyBJBDuyAbazmgiuSamuT6xzcn6CBcSm9Qet7tAJToYN3GM/GH68HbEoBz/33zE5qXgdL4InC9P/L8K3KoeDyFxqzqcr4JjtK87i6Z36KRHKz2ejcK/ryuujxa9Chyn9ykvOEltMUgDqSycnxDGBOtGdINGP2iOjVNG3Wpc7g2Lk2g7eDzEwMlJuKoVMgni1wohwBgD5zxyzq+4Ng5103NyZRwnbjvJMXrnQ0QpBadSVn7Y/IplKfu+YNltXVco7SDqfiOXFtZPaHuFQVn4kXoQ+exJawOlNax1HPCeCC3vtbFMSouonqLDIN8CTSehTeA9NZcFD5qyk/wgXMgWjmvjIZqeqexeaxIkwjBlvjIL/q4hERE1mzEI48hxqR0q0aKXhulItOk2cR8S+/kn4fqq25tw2Wv4bgoR+jFy56kpx3QwYfmL0HuuIdUvfXSZDt4fNQ8w1YuGuW4ll4GMBp2vvB3exuRFtRvVjhb9Gks17ODDhJhmjFPizse08EBPMW+E8zwj5xnkSeDoMiXgZNpwIqrd9S5QtwrSBCgz8idKZERNsXn+GGyiKOvKw5xS3vz+TIJTjPDe821iTHyGkh/DTzBk3+WA697GOYl0AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"users\"\n        title=\"users\"\n        src=\"/static/c5528ba2074d0967756eab372686c0da/1e043/users.png\"\n        srcset=\"/static/c5528ba2074d0967756eab372686c0da/991de/users.png 173w,\n/static/c5528ba2074d0967756eab372686c0da/e4d6b/users.png 345w,\n/static/c5528ba2074d0967756eab372686c0da/1e043/users.png 690w,\n/static/c5528ba2074d0967756eab372686c0da/ef916/users.png 815w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Here we’ve added three Users to our existing Organization items. Our User items use a <code class=\"language-cpptext\">PK</code> value of <code class=\"language-cpptext\">ORG#&lt;OrgName&gt;</code> and an <code class=\"language-cpptext\">SK</code> value of <code class=\"language-cpptext\">USER#&lt;UserName&gt;</code>.</p>\n<p>This concept of using generic names for your primary keys and using different values depending on the type of item is known as <strong>overloading your keys</strong>. You will do this with both your primary keys and your secondary indexes to enable the access patterns you need.</p>\n<h3 id=\"api-actions\" style=\"position:relative;\"><a href=\"#api-actions\" aria-label=\"api actions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>API Actions</h3>\n<p>Let's learn about the core API actions with DynamoDB that can be broken down into 3 categories: Item-based actions, queries and scans. The API actions are divided based on what you’re operating on:</p>\n<ul>\n<li>\n<p>Operating on specific items? Use the item-based actions.</p>\n</li>\n<li>\n<p>Operating on an item collection? Use a Query.</p>\n</li>\n<li>\n<p>Operating on the whole table? Use a Scan.</p>\n</li>\n</ul>\n<h3 id=\"item-based-actions\" style=\"position:relative;\"><a href=\"#item-based-actions\" aria-label=\"item based actions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Item Based Actions</h3>\n<p>Item-based actions are used whenever you are operating on a specific item in your DynamoDB table. There are four core API actions for item-based actions:</p>\n<ol>\n<li>\n<p>GetItem--used for reading a single item from a table.</p>\n</li>\n<li>\n<p>PutItem--used for writing an item to a table. This can completely overwrite an existing item with the same key, if any.</p>\n</li>\n<li>\n<p>UpdateItem--used for updating an item in a table. This can create a new item if it doesn’t previously exist, or it can add, remove, or alter properties on an existing item.</p>\n</li>\n<li>\n<p>DeleteItem--used for deleting an item from a table.</p>\n</li>\n</ol>\n<p>There are three rules around item-based actions. First, the full primary key must be specified in your request. Second all actions to alter data—writes, updates, or deletes—must use an item-based action. Finally, all item-based actions must be performed on your main table, not a secondary index.</p>\n<p>The combination of the first two rules can be surprising—you can’t make a write operation to DynamoDB that says, \"Update the attribute X for all items with a partition key of Y\" (assuming a composite primary key). You would need to specify the full key of each of the items you’d like to update.</p>\n<h3 id=\"query\" style=\"position:relative;\"><a href=\"#query\" aria-label=\"query permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Query</h3>\n<p>The second category of API actions is the Query API action. The Query API action lets you retrieve multiple items with the same partition key. This is a powerful operation, particularly when modeling and retrieving data that includes relations. You can use the Query API to easily fetch all related objects in a one-to-many relationship or a many-to-many relationship.</p>\n<p>Imagine you modeled a table that tracked actors and actresses and the movies in which they acted. Your table might have some items like the following:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1bfc931745cbe42ebc7af48846e22e1a/b97f6/actors.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.33526011560693%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABxElEQVQoz11SB47cMAz0/5+XILe55LLt1lXNKrZcJE9Aer05hMCAJi0OBySLTnsQhAm4fDZ4e7/gfK85pnyrPBrp0KodnfIoW81vy9ZwTHl6o/oBBf349vaB0+8bvp/+4ProcL7vxD9+nvFxrZi0FpZBhbdS4PTryp5iQtVZSBNQTPOKaV4Qpx3zsiIMI6zzGOPE8b3scCvlXigsLp8dE1AjIqWmFAvtUaSUQPhqMUaEELBtmWMfBihtoI3lBqZ33HRNmf2RX9aEYiA11mJdVy7OOSPljG3bXmiFQdUqtNJC9QFlI9EpC+NGNKLHoxbQdkDvRxT4z4iA1Dnn+JtMGQupex7JOC2Qqod1AXFe0buAuhGwbuD/RUqZVeW8IW8bq0v5yJFSoOkU6k7DjzOsj6gaCakdXJhY6f3RQBkPP0wovCc1/qWGPOXsF4WkqG4lmk7DhYhWaOjeY4gLlHF4VC2MDRjijIKUUWF+zi091e653SttmURqCz9EdNK8CIi4asQ/QpoVLYVUMimAI7csCys8lkILoUXQUoSy6H1EIwwvhfKWlrKu+9kQjrmtKTEO1fM8cxM6J7Jpml6nRtcxDgPwHM9f54VM9Kl/zF8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"actors\"\n        title=\"actors\"\n        src=\"/static/1bfc931745cbe42ebc7af48846e22e1a/1e043/actors.png\"\n        srcset=\"/static/1bfc931745cbe42ebc7af48846e22e1a/991de/actors.png 173w,\n/static/1bfc931745cbe42ebc7af48846e22e1a/e4d6b/actors.png 345w,\n/static/1bfc931745cbe42ebc7af48846e22e1a/1e043/actors.png 690w,\n/static/1bfc931745cbe42ebc7af48846e22e1a/b97f6/actors.png 958w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Here we have four items in our table. The primary key is a composite primary key using the actor’s name as the Partition key and the Movie name as the Sort key.</p>\n<p>You can use the Query operation on either your base table or secondary index. When making a Query, you must include a partition key in your request. In our example, this can be useful to find all the roles an actor has played. For example, we could use the Query operation and specify a partition key of \"Tom Hanks\":</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-cppjsx\"><code class=\"language-cppjsx\"> items <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span>\n    TableName<span class=\"token operator\">=</span>\n    KeyConditionExpression<span class=\"token operator\">=</span>\n    ExpressionAttributeNames<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'#actor'</span><span class=\"token operator\">:</span> <span class=\"token string\">'Actor'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">,</span>\n <span class=\"token string\">'MoviesAndActors'</span>\n <span class=\"token string\">'#actor = :actor'</span>\n<span class=\"token punctuation\">,</span>\nExpressionAttributeValues<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n        <span class=\"token string\">':actor'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'S'</span><span class=\"token operator\">:</span> <span class=\"token string\">'Tom Hanks'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> <span class=\"token punctuation\">)</span></code></pre></div>\n<p>This Query would return two items—Tom Hanks in Cast Away and Tom Hanks in Toy Story.Remember that all items with the same partition key are in the same item collection. Thus, the Query operation is how you efficiently read items in an item collection. This is why you carefully structure your item collections to handle your access patterns.</p>\n<p>While the partition key is required, you may also choose to specify conditions on the sort key in a Query operation. In our example, imagine we want to get all of Tom Hanks' roles in movies where the title is between A and M in the alphabet. We could use the Query action to get: Tom Hanks in Cast Away—as it is the only item that satisfies both the partition key requirement and the sort key requirement.</p>\n<p>As mentioned, you can use the Query API on either the main table or a secondary index. With our example, we can query movie roles by the actor’s name. But what if we want to query by a movie? Our current pattern doesn’t allow this, as the partition key must be included in every request. To handle this pattern, we can create a global secondary index that flips our partition key and sort key:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c9befcfae7b012adbb3d4489328a42f5/4d08a/flipped-secondary.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 115.60693641618498%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAADiElEQVQ4y4VVaY/rNgz0//9hPR/Qoq/oXt1NduPEtqz78p0pSMV5+VYBhC06oobDIVOlYYJyGdZGqKcXHH7+FcffvkH/+RfspYMOI5SJUDaxaZcglMelU+i1v/kjpIkIaURlfcLTe43n7894/uNvPB0uOAiH11++4fmn3/Hy2eIiLJre87OVHp/nHv+8HnGsBe/JzsLCuIRqmlf4kOBCgo0DQsxIaYAKCTokxJjRCINj3fNBCkoBH4MfTh3qzjL6ats2XK9XPK5lWRBjwDLPvM95gNQG2jgM4wRtHYOYlw3ORyhtMc4L5nlBRYed94gx8mEKvq4b1m3DfpmxAedWoZOW+WL+lIMNA9re4NJKGJ8Lh9v2A92OdJomWOcYKS1CI6RGHmc2qS2sjximhS9rOwkfM8ZpQUVI1nVlNNv1ykYItxtCWtp6nJsePo1wYUDDFXZwcUQnDU4XwchjnijlFdY6RoVHhNbeERJPrVDoeg0fB/SKKhqQxwXaeDRtDxcI4YyK0NDB9QqslDaAdbtiZaQrBzTW31EZn9D2GlJ7RiyURd0IaBdBmq7maYYNEfbrE+nfNw4wOAddnzAMwx0hpSyNZ+IboaBM4BSFpKIUOjjgQuVeV0zWIr2+IH8ekT/eMSmFcZowjiPLhlSwX0AZ7fxSFoWaKxe18t6hbRp0fY+6bdErBSElOiFwOn2haRrU9Yl/E0PA/62KBEnQ0zAz4UQ8pRHShDSWb5SmjyN/pyqT0fvj3obMkqqsz3g7Nnj/bPF6OOP78wde3mu8HS7s+/jqcO6olx33K/U09fD3p/d7L5OPWo/EXQ3jjKaTODeCjRAy8Z3EpS37trc4tRqtDLj0Dl8XhVOj+ALy03sJmErrhRCKDh96mXxUkL3KdIHU7kaLgnGRU+yVQSskYh5B4FiHVKl7t2w/9mRUOQ4oFAt651nbIhvylawmZJLN47TZnzQ1qJenab4JO/AAoMM0P1uhoViTUxE2DWIbS0BKzxiL6TaqKOiOdNcaIdyrT0OgtF5kZSjjOGVqPU55R7hbQThzf6eUeW9dSZkQkXwKwlBaT1ruFBqu6THlgqxYmYXXO8IyvgwfIKPiOJ+4KERHJ9RtOCz0FzDDOY+U0r3KM/scvPcFrYuoGwlpAmvtzHx6HrBNp5lf7TIiDViqMhWh9OcN4brefeX7zDLaLyU5retyH3U55zv//wEWFObIIq952QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"flipped\"\n        title=\"flipped\"\n        src=\"/static/c9befcfae7b012adbb3d4489328a42f5/1e043/flipped-secondary.png\"\n        srcset=\"/static/c9befcfae7b012adbb3d4489328a42f5/991de/flipped-secondary.png 173w,\n/static/c9befcfae7b012adbb3d4489328a42f5/e4d6b/flipped-secondary.png 345w,\n/static/c9befcfae7b012adbb3d4489328a42f5/1e043/flipped-secondary.png 690w,\n/static/c9befcfae7b012adbb3d4489328a42f5/4d08a/flipped-secondary.png 709w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Notice that we have the same four items as in our previous table. The primary key has changed, but the data is the same.\nNow, we can get all performers in Toy Story by using a Query operation on the secondary index and specifying \"Toy Story\" as the partition key. We will receive two items back—Tom Hanks and Tim Allen— representing the Toy Story roles in our database.</p>\n<h3 id=\"scan\" style=\"position:relative;\"><a href=\"#scan\" aria-label=\"scan permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scan</h3>\n<p>The final kind of API action is the Scan. The Scan API is the bluntest tool in the DynamoDB toolbox. By way of analogy, item- based actions are like a pair of tweezers, deftly operating on the exact item you want. The Query call is like a shovel—grabbing a larger amount of items but still small enough to avoid grabbing everything. A Scan will grab everything in a table. If you have a large table, this will be infeasible in a single request, so it will paginate. Your first request in a Scan call will read a bunch of data and send it back to you, along with a pagination key. You’ll need to make another call, using the pagination key to indicate to DynamoDB where you left off.</p>\n<h3 id=\"expressions\" style=\"position:relative;\"><a href=\"#expressions\" aria-label=\"expressions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Expressions</h3>\n<p>As you’re working with the DynamoDB API, a lot of your time will be spent writing various kinds of expressions. Expressions are statements that operate on your items. They’re sort of like mini- SQL statements.</p>\n<p>There are five types of expressions in DynamoDB:</p>\n<ul>\n<li>\n<p>Key Condition Expressions: Used in the Query API call to describe which items you want to retrieve in your query</p>\n</li>\n<li>\n<p>Filter Expressions: Used in Query and Scan operations to describe which items should be returned to the client after finding items that match your key condition expression</p>\n</li>\n<li>\n<p>Projection Expressions: Used in all read operations to describe which attributes you want to return on items that were read</p>\n</li>\n<li>\n<p>Condition Expressions: Used in write operations to assert the existing condition (or non-condition) of an item before writing to it</p>\n</li>\n<li>\n<p>Update Expressions: Used in the UpdateItem call to describe the desired updates to an existing item</p>\n</li>\n</ul>\n<p>The first three expressions are for read-based operations. The fourth, Condition Expressions, is for all write-based operations, and the last, Update Expressions, is for update operations only.</p>\n<h3 id=\"ddb-vs-rdb-data-modeling\" style=\"position:relative;\"><a href=\"#ddb-vs-rdb-data-modeling\" aria-label=\"ddb vs rdb data modeling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DDB vs RDB Data Modeling</h3>\n<p>Let’s look at a few ways that data modeling in DynamoDB is different than data modeling with a relational database. Relational databases have been the de facto standard for a few decades, and most developers have familiarity with relational data modeling.</p>\n<p>It’s a bad idea to model your data in DynamoDB the same way you model your data in a relational database. The entire point of using a NoSQL datastore is to get some benefit you couldn’t get with a relational database. If you model the data in the same way, you not only won’t get that benefit but you will also end up with a solution that’s worse than using the relational database!</p>\n<p>Below are a few key areas where DynamoDB differs from relational databases:</p>\n<p>-<strong>JOINS</strong></p>\n<p>In a relational database, you use the JOIN operator to connect data from different tables in your query. It’s a powerful way to reassemble your data and provide flexibility in your access patterns. But joins come at a cost. Joins need large amounts of CPU to combine your disparate units of data. You won’t find information about joins in the DynamoDB documentation because there are no joins in DynamoDB. Joins are inefficient at scale, and DynamoDB is built for scale. Rather than reassembling your data at read time with a join, you should preassemble your data in the exact shape that is needed for a read operation. One last note—people often try to do joins in their application code. They’ll make an initial request to DynamoDB to fetch a record, then make a follow-up request to query all related records for that record. You should avoid this pattern. DynamoDB doesn’t have joins for a reason!</p>\n<p>-<strong>NORMALIZATION</strong></p>\n<p>Normalization is basically the database version of the popular code mantra of \"Don’t Repeat Yourself\" (or, \"DRY\"). If you have data that is duplicated across records in a table, you should split the record out into a separate table and refer to that record from your original table. In a relational database, each entity type is put into a different table. Customers will be in one table, CustomerOrders will be in another table, and InventoryItems will be in a third table. Each table has a defined set of columns that are present on every record in the table—Customers have names, dates of birth, and an email address, while CustomerOrders have an order date, delivery date, and total cost.</p>\n<p>There are no joins in DynamoDB, and we also saw that you shouldn’t fake joins in your application code by making multiple serial requests to your DynamoDB table. So how do you solve a complex access pattern in a single request, such as fetching a customer and all customer orders? You put multiple entity types in a single table. Rather than having a Customers table and a CustomerOrders table, your application will have a single table that includes both Customers and CustomerOrders (and likely other entities as well). Then, you design your primary key such that you can fetch both a Customer and the matching CustomerOrders in a single request.</p>\n<p>-<strong>FILTERING</strong></p>\n<p>Filtering with relational databases is glorious. You can specify any condition you want using the magical WHERE clause. You can filter on properties of top-level objects or properties of nested objects that have been joined to your data. You can filter using dynamic properties, such as the current time of the request. The WHERE clause is supremely powerful and a huge benefit to relational databases.</p>\n<p>But, like other aspects of a relational database, the flexibility of the WHERE clause is a luxury you can’t afford at scale. A WHERE clause needs to read and discard a large number of records, and this is wasted compute.</p>\n<p>Filtering with DynamoDB is much more limited and, as a result, much more performant. With DynamoDB, filtering is built directly into your data model. The primary keys of your table and your secondary indexes determine how you retrieve data. Rather than arbitrarily filtering on any attribute in your record, you use precise, surgical requests to fetch the exact data you need.</p>\n<p>The DynamoDB approach requires more planning and work upfront but will provide long-term benefits as it scales. This is how DynamoDB is able to provide consistently fast performance as you scale. The sub-10 millisecond response times you get when you have 1 gigabyte of data is the same response time you get as you scale to a terabyte of data and beyond. The same cannot be said about relational databases.</p>\n<h3 id=\"modeling-with-ddb\" style=\"position:relative;\"><a href=\"#modeling-with-ddb\" aria-label=\"modeling with ddb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Modeling with DDB</h3>\n<p>Data modeling in DynamoDB is driven entirely by your access patterns. You will not be able to model your data in a generic way that allows for flexible access in the future. You must shape your data to fit the access patterns. The steps for modeling with DynamoDB, at a high level, are:</p>\n<ul>\n<li>Understand your application</li>\n<li>Create an entity-relationship diagram (\"ERD\")</li>\n<li>Write out all of your access patterns</li>\n<li>Model your primary key structure</li>\n<li>Satisfy additional access patterns with secondary indexes and streams</li>\n</ul>\n<h3 id=\"erd\" style=\"position:relative;\"><a href=\"#erd\" aria-label=\"erd permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ERD</h3>\n<p>An entity-relationship diagram is just like it sounds—a diagram that lists the different entities in your application and how they relate to each other. Imagine you have a \"Notes\" application. Users sign up for your application, and they can save notes. A note has a title, a date when it was created, and a body, which contains the content of the note. The ERD for your Notes application would look like this:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 622px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/431ffd1748c33e49b3d50b6afaed30c9/604ec/erd.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.947976878612714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABAUlEQVQoz3VRy6qDUAw8//8pLl10VSq09QPciY+CoFYR363WWp0ygSO9t/cGBmLOZJKJCv/Euq5b3vc95nn+qv8Vqus6tG0r0PntdpPH1+uFqqqkVtc1xnGU+jAMW89n3zRNUIfDAefzGaZpYrfb4Xg8wrZtpGkqoDjJFEmSBGVZ4nQ6wbIs7Pd7GIYhOXWiKIJyHAcEPziJ9oqikGm0x80ICj0eD9kwjmO4riuDmqaRPs1Rvu8jDENcLpftTrSm7TG4Je3ryPMcQRDger3+uB/FFR84LcsyscVmPjyfz6+foHNyPc/D/X4XPqHvqLgVm2mRlohPsd9gLMsiHM3XYP0NGKgU6pO6KzUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"erd\"\n        title=\"erd\"\n        src=\"/static/431ffd1748c33e49b3d50b6afaed30c9/604ec/erd.png\"\n        srcset=\"/static/431ffd1748c33e49b3d50b6afaed30c9/991de/erd.png 173w,\n/static/431ffd1748c33e49b3d50b6afaed30c9/e4d6b/erd.png 345w,\n/static/431ffd1748c33e49b3d50b6afaed30c9/604ec/erd.png 622w\"\n        sizes=\"(max-width: 622px) 100vw, 622px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>First, note that there are two rectangular boxes, titled \"Users\" and \"Notes\". These are the entities in your application. Usually, these are the nouns you use when talking about your application—Users, Notes, Orders, Organizations, etc. Note that each entity lists a number of attributes for that entity. Our User entity has a username, email address, and date created, while the Note entity has a title, a date created, and a body. Second, notice that there is a diamond with some lines connecting the User and Note entities. This indicates a relationship between the two entities. The line shown indicates a one-to-many relationship, as one User can own many notes. ERD forces you to think about your data upfront and provides a nice artifact for those that are new to your application.</p>\n<h3 id=\"define-access-patterns\" style=\"position:relative;\"><a href=\"#define-access-patterns\" aria-label=\"define access patterns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Define Access Patterns</h3>\n<p>When using a relational database, you can usually just ship your ERD straight to the database. Your entities become tables, and your relationships are configured via foreign keys. You design your data in a way that can accomodate flexible query patterns in the future.</p>\n<p>This is not the case when data modeling in DynamoDB. You design your data to handle the specific access patterns you have, rather than designing for flexibility in the future.</p>\n<p>Thus, your next step after creating an ERD is to define your data access patterns. All of them. Be specific and thorough. Failure to do this correctly may lead to problems down the line as you find your DynamoDB table isn’t as flexible to new patterns as your relational database was.</p>\n<h3 id=\"model-primary-key-structure\" style=\"position:relative;\"><a href=\"#model-primary-key-structure\" aria-label=\"model primary key structure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Model Primary Key Structure</h3>\n<p>The primary key is the foundation of your table, so you should start there. I model my primary key using the following four steps:</p>\n<p>First, I create an 'entity chart' that is used to track the different types of items I’ll have in my table. The entity chart tracks the type of item, the primary key structure for each item, and any additional notes and properties. I usually start by copying each entity in my ERD into the entity chart.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 639px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0324eaecce9bb20889177e179892cdcc/738b8/model-entity-chart.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.13294797687862%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAr0lEQVQoz61S0QqFIAz1//9RLH1ICwSfMs122WChdotLXGFsnh3PNqYYhgG2bYPjOKCUQj7nDMYY2PedMDY8IQRwzlHc59HEOI4kgBcmoF/XtXnAMRaPMTZYI8jV6g7Z9/Edp84JHFkpBd77E7yr/oSfHVpridQTXwtqrWkBKaX/dIiC/bhsPfaNcxFcloUC3nT96EnwLieklLQUHLtOvB55miaY55k+K3b5y1hPgh9pwhJtwSGdZgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Model-Entity-Chart\"\n        title=\"Model-Entity-Chart\"\n        src=\"/static/0324eaecce9bb20889177e179892cdcc/738b8/model-entity-chart.png\"\n        srcset=\"/static/0324eaecce9bb20889177e179892cdcc/991de/model-entity-chart.png 173w,\n/static/0324eaecce9bb20889177e179892cdcc/e4d6b/model-entity-chart.png 345w,\n/static/0324eaecce9bb20889177e179892cdcc/738b8/model-entity-chart.png 639w\"\n        sizes=\"(max-width: 639px) 100vw, 639px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>As you build out your data model, the rows in your entity chart may change. You may remove entities that appear in your ERD because they aren’t tracked as separate items in DynamoDB. For example, you may use a list or map attribute type to represent related objects on a particular item. This denormalized approach means there’s not a separate item for each of the related entities. Additionally, you may need to add entities to your chart as you design your table. A common example here is with a many-to-many relationship where you need to add an item type to represent the relationship between entities.</p>\n<p>After deciding the entities and relationships to model, the second step is to decide on a simple or composite primary key. Most complex data models use a composite primary key but there are exceptions. In general, a rule of thumb is that if you have any access patterns that require retrieving multiple entities (e.g., Get all Orders for a User) or entity types (e.g., Get a Sensor and the most recent SensorReadings for the Sensor), you will need a composite primary key.</p>\n<p>The last step is to start designing the primary key format for each entity type. Make sure you satisfy the uniqueness requirements first. If you have some additional flexibility in your key design after handling uniqueness, try to solve some of the \"fetch many\" access patterns you have.</p>\n<p>There’s no one-size-fits-all approach to designing your primary key, but there are a few principles you should keep in mind:</p>\n<ul>\n<li>Consider what your client will know at read time</li>\n</ul>\n<p>Remember that your client must know the primary key at read time or otherwise make costly additional queries to figure out the primary key.</p>\n<ul>\n<li>Use primary key prefixes to distinguish between entity types</li>\n</ul>\n<p>We mentioned in the previous section that you will include multiple entity types per table. This can make it difficult to distinguish between the different types of entities, particularly when looking at your table in the console or exporting to analytics systems. Further, it can prevent accidental overlaps if you have different entity types with common attributes.</p>\n<p>Use a prefixing system on primary keys to help identify the type of entity that is being referenced. For example, if you have Customers and CustomerOrders in a table, the pattern for Customers might be CUSTOMER#<CustomerId> for the partition key and METADATA#<CustomerId> on the sort key. For the CustomerOrder, the pattern might be ORDER#<OrderId> for the partition key and METADATA#<OrderId> for the sort key.\nAs you’re modeling your entities, keep track of primary key templates in your entity chart as shown below:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 642px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ecbd25d93bd494c5f5ad9495ed39cc19/1bba8/ecommerce-entity-chart.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16.184971098265898%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAmUlEQVQI1zVOCQqEMBDz//9zi0cPFI9qwQpKbdVmmWE3EGbIHElhrYWUEs/zgPC+L9fzPNF1Ha7rYqaUEEJAjAl938N7z9qftBNjROGcg1IKwzDwwX3fyDlzX1UVyvKDtpVQSsMYA9onIyEEmqaF1gZ1XfPsOA4U+77zs3meMY4jJyOQG+nLsv64cBLCtm2Ypom1dXV8S88IXyt/4wiZuXCHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Ecommerce-Entity-Chart\"\n        title=\"Ecommerce-Entity-Chart\"\n        src=\"/static/ecbd25d93bd494c5f5ad9495ed39cc19/1bba8/ecommerce-entity-chart.png\"\n        srcset=\"/static/ecbd25d93bd494c5f5ad9495ed39cc19/991de/ecommerce-entity-chart.png 173w,\n/static/ecbd25d93bd494c5f5ad9495ed39cc19/e4d6b/ecommerce-entity-chart.png 345w,\n/static/ecbd25d93bd494c5f5ad9495ed39cc19/1bba8/ecommerce-entity-chart.png 642w\"\n        sizes=\"(max-width: 642px) 100vw, 642px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>This will help you maintain clarity as you build out your access patterns chart and will serve as a nice artifact for development and post-development.</p>\n<h3 id=\"secondary-indexes-and-streams\" style=\"position:relative;\"><a href=\"#secondary-indexes-and-streams\" aria-label=\"secondary indexes and streams permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Secondary Indexes and Streams</h3>\n<p>You won’t always be able to model everything with your primary key. That’s where you start thinking about secondary indexes. New users often want to add a secondary index for each read pattern. This is overkill and will cost more. Instead, you can overload your secondary indexes just like you overload your primary key. Use generic attribute names like GSI1PK and GSI1SK for your secondary indexes and handle multiple access patterns within a single secondary index.</p>\n<h3 id=\"single-table-design\" style=\"position:relative;\"><a href=\"#single-table-design\" aria-label=\"single table design permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Single Table Design</h3>\n<p>With relational databases, you generally normalize your data by creating a table for each type of entity in your application. For example, if you’re making an e-commerce application, you’ll have one table for Customers and one table for Orders. Each Order belongs to a certain Customer, and you use foreign keys to refer from a record in one table to a record in another. These foreign keys act as pointers—if I need more information about a Customer that placed a particular Order, I can follow the foreign key reference to retrieve items about the Customer:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 689px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9bcdfd983cf914a9d2e960b95773f007/0f79a/normalized-db.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.69364161849711%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACTUlEQVQoz11SiW7aQBD1//9B1KglqQEZbHMTQqJwFaTYmFJSJ1CuIAVwoRDiA+wK8qqZlijqSm93Zt7szNPOCoZh4Pr6GpVKBZVyGTc3N+yXSiVUq1VkMhlIkoRIJIKLiwvmy+Uyg+/8w+XlJYbDIYRGo4FwJIJwOIzPoghFUZDL5RCLxSCKIkKhEE5OTphPpVLcgGwC8WdnZ2wnEgl0u10IP/p9lHN5FCQJRUUFNfjW6aBer7OiQqGAfD4PXdfRarXQbrdZPXHZbJabkGriptMpBD8I4E9nWIxGcCYT+I4Liu33e1iWhaenJz5fX1/hui4OhwNozedz5mazGfsU3263EF5eXuDaNsx0Btb4EbbjgGKUeHd3h4eHB3Q6HaxWK6zXay5q2zbHTdNEr9fj/GNcOHbcWj9ZBYFi78/jItW0/s977wu9bhearkO/ukJT09A0DDSbTUbLMKBpGorF4ts7HTn6HUeQf3t7+/cNa7UaYrIMORyG+vETEuk0kqkUT01WVcQVBR9OT3F+fo5kMvmGeDzOkGWZB0P2/f09BNqoe1SSkI5EUc/m8KVUQqNehyyKkEIhpBWFlVJzUkI2FY1Go1BVlX36HZPJBAI9JD1ov9+HtVjAXq144ovvJqyvbQw0Hb+6Pbiex4OhXM/z+DINZDQa4VjDcRwIRO52Oy64XC7h7XZwPA+/gwDr2RxD04T7/IwgCLDZbOD7PttUcDAYYDwe83ehOBUVyCFQMRo/NaBOlOBtt1g9r7Hzfc4hJXSSAFJLd1iE573F/wDYskbgwH/hxwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Normalized-DB\"\n        title=\"Normalized-DB\"\n        src=\"/static/9bcdfd983cf914a9d2e960b95773f007/0f79a/normalized-db.png\"\n        srcset=\"/static/9bcdfd983cf914a9d2e960b95773f007/991de/normalized-db.png 173w,\n/static/9bcdfd983cf914a9d2e960b95773f007/e4d6b/normalized-db.png 345w,\n/static/9bcdfd983cf914a9d2e960b95773f007/0f79a/normalized-db.png 689w\"\n        sizes=\"(max-width: 689px) 100vw, 689px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>To follow these pointers, the SQL language for querying relational databases has a concept of joins. Joins allow you to combine records from two or more tables at read-time. While convenient, SQL joins are also expensive. They require scanning large portions of multiple tables in your relational database, comparing different values, and returning a result set. DynamoDB was built for enormous, high-velocity use cases, such as the Amazon.com shopping cart. These use cases can’t tolerate the inconsistency and slowing performance of joins as a dataset scales.</p>\n<p>But as an application developer, you still need some of the benefits of relational joins. And one of the big benefits of joins is the ability to get multiple, heterogeneous items from your database in a single request.In our example above, we want to get both a Customer record and all Orders for the customer. Many developers apply relational design patterns with DynamoDB even though they don’t have the relational tools like the join operation. This means they put their items into different tables according to their type. However, since there are no joins in DynamoDB, they’ll need to make multiple, serial requests to fetch both the Orders and the Customer record:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7c3ad8d22706b94e8067b45bfa27248b/cecac/ddb-joins.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.33526011560693%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB70lEQVQoz32Sy2sTURTG83+4EJfVnX+DCwVxoTvXdudSKPgoQnyg0I0bERIs2oALhVAUrQElKMWIttRk8jJtkmaSadLUdCYzcyfzyE/mhkibNh74uJd7Dt/9zjlfBGA4HEpMi3F+EuPc63SeeKrAnuEQOVgQBIEsCs9/74HP0PckGAb4vo+madTqday+wZpS4eTlKDPX4jx9uzEiHEe1WqVWq0mUy2VKxSKD4LDaft/AMEL0sUyD5Y9pTl2JcmY2xpPkTyJhUbvTQW02EUKgqqoka+9oWAMf7WuSzcV5aoko+WSM3Z6BOxig6wamaWLZggfPV5h7lqKidkeEm1tb5HI52Y7jOJLYdRxsH4ov77Mxd45fN8+Ti93GdAOEZR6aeVtTKRUUfM8lEhKsra/zLZOh0+lIQsuysC0TXbiUEw/J3bqAMn+RfPwOf0whCUN1ruseWaCcYaVSQVGUYzdd/7JMdjFKIfGIwvsE3Z6O57ry43CWumFy78VnbsTS/G7tj1qeapEgYLens7O3T1c30S2BEDa6YWALEVbz7tMqJy7d5fRsjIU33w/b5qDCab70PI9Go0GxWKKpbrP6I8vM1cecvb5EfCU7Ujhp1Mn7JHq9Hq1WSy4vjFcfMiwspejb7tGW/xfTVAtTp93alkv5C6WkLgHBP5VEAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"DDB-Joins\"\n        title=\"DDB-Joins\"\n        src=\"/static/7c3ad8d22706b94e8067b45bfa27248b/1e043/ddb-joins.png\"\n        srcset=\"/static/7c3ad8d22706b94e8067b45bfa27248b/991de/ddb-joins.png 173w,\n/static/7c3ad8d22706b94e8067b45bfa27248b/e4d6b/ddb-joins.png 345w,\n/static/7c3ad8d22706b94e8067b45bfa27248b/1e043/ddb-joins.png 690w,\n/static/7c3ad8d22706b94e8067b45bfa27248b/cecac/ddb-joins.png 728w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>This can become a big issue in your application. Network I/O is likely the slowest part of your application, but now you’re making multiple network requests in a waterfall fashion, where one request provides data that is used for subsequent requests. As your application scales, this pattern gets slower and slower.</p>\n<p>So how do you get fast, consistent performance from DynamoDB without making multiple requests to your database? <strong>By pre-joining your data using item collections.</strong></p>\n<p><em>An item collection in DynamoDB refers to all the items in a table or index that share a partition key.</em></p>\n<p>In the example below, we have a DynamoDB table that contains actors and the movies in which they have played. The primary key is a composite primary key where the partition key is the actor’s name and the sort key is the movie name.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fdacd28bdd40eff4348065710ffc184f/3a737/item-collection.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.369942196531795%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABhklEQVQY0zWO71PSAACG99dXp1fS6eV1ZUWZjLM6tCAEpB+Q48YGKouCDQ1qDLY5xpiK4no64Xq+Pe+H515hrzZgPd1mI9vmfqLCsqjwaKfBRlbnae4XuSOf+uk5Siekqk9QjAmZcouspKN2wsVuTKi0AvT+BcLRiUtB7VJUTynWuuTrFh/KP8nLBgc/XOJ5nTtJjVjmDyupFmsfe6zt9Ymlf3M32eCeeMjjfZuVjEWh4SNMzyeEvgv85ZbQd/DPhvynovVYTR3zvHBCstTjTWVISh0hfrNY3z3mSVojpXiIkoPSCRCm0yuurq+Z3UTcRBG+P2Y8DuZ+S05q8vBtnZ3DkM19HbFs8k7x2fxqEduWWX71iUR5QEI6QzYChNFoxHA4JIoWAc/zcF2XKFo8zss6S8kaq+9bPMsZvC5ZiBWPF5/7PNhWWdo64OUXi3jJQWoHCLZtY5rmPDqbzXAcZ+4Xl5fzoPy9SzyrsVsdkKmaZOs2BW1MWrXZKjRJFptzz9Q9Gr2Qf2Xhn+O9oCgPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Item-Collection\"\n        title=\"Item-Collection\"\n        src=\"/static/fdacd28bdd40eff4348065710ffc184f/1e043/item-collection.png\"\n        srcset=\"/static/fdacd28bdd40eff4348065710ffc184f/991de/item-collection.png 173w,\n/static/fdacd28bdd40eff4348065710ffc184f/e4d6b/item-collection.png 345w,\n/static/fdacd28bdd40eff4348065710ffc184f/1e043/item-collection.png 690w,\n/static/fdacd28bdd40eff4348065710ffc184f/3a737/item-collection.png 897w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>You can see there are two items for Tom Hanks—Cast Away and Toy Story. Because they have the same partition key of Tom Hanks, they are in the same item collection.</p>\n<p>You can use DynamoDB’s Query API operation to read multiple items with the same partition key. Thus, if you need to retrieve multiple heterogeneous items in a single request, you organize those items so that they are in the same <strong>item collection</strong>.</p>\n<p>Another example uses an e-commerce application which involves Users and Orders. We have an access pattern where we want to fetch the User record and the Order records. To make this possible in a single request, we make sure all Order records live in the same item collection as the User record to which they belong:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b5a685ef71d05ce741dbc1fed6ca7081/c65fa/item-collection-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.79190751445087%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiElEQVQY0y2R/0/acBiE+/9PN53AGCpmwEQQaUtxgKIO5gTa1TEMDpVvcVC2OCGUQksy8yx+tje5XO6HuzzJK2WMB1KVEdHTPpFim3h5gFwdkdF/oVQsVP2BjPFb5GePHn0ndf4DtfZTSDPHaF8eUY1HCvUxkud5/Hl6YrFwGVojZjObeN5kLf2N9WSV7eMOsdKQF7sXBPM9gtoVq3sVVuIXrCZ0/Ie3BHNtNjIttgp3SJPJBNu2mdk2/X6fxdxBKV3zRmuylW2Q/GwJ+eWvpPQJ7896+NKXbByY+NQG4WKfzXybQLZF5KSDxP9zHAfLsvDcBclinddyA9+BTvTjPbvlIa+SOonqWJT+EVZY2asRKnQJZG9YU5psPxNOp1Nc1xWDg8FAkMqlJqHcDQHZZKfYJX5u8TJRJXxyLwYFXdrEr9R5m7sThJuFDrGzHtJs5rBcLpnP5wyGQzzPRStf8e6oxc7hJUpthFKzCKkm2fqU/XKXkGIQUg3CHxrETjtEjm/FQ/c/9fgLSOSQc160XxgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Item-Collection-2\"\n        title=\"Item-Collection-2\"\n        src=\"/static/b5a685ef71d05ce741dbc1fed6ca7081/1e043/item-collection-2.png\"\n        srcset=\"/static/b5a685ef71d05ce741dbc1fed6ca7081/991de/item-collection-2.png 173w,\n/static/b5a685ef71d05ce741dbc1fed6ca7081/e4d6b/item-collection-2.png 345w,\n/static/b5a685ef71d05ce741dbc1fed6ca7081/1e043/item-collection-2.png 690w,\n/static/b5a685ef71d05ce741dbc1fed6ca7081/e3189/item-collection-2.png 1035w,\n/static/b5a685ef71d05ce741dbc1fed6ca7081/b1001/item-collection-2.png 1380w,\n/static/b5a685ef71d05ce741dbc1fed6ca7081/c65fa/item-collection-2.png 1434w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Now when we want to fetch the User and Orders, we can do it in a single request without needing a costly join operation. <strong>This is what single-table design is all about—tuning your table so that your access patterns can be handled with as few requests to DynamoDB as possible, ideally one.</strong></p>\n<p>While reducing the number of requests for an access pattern is the main reason for using a single-table design with DynamoDB, there are some other benefits as well:</p>\n<ul>\n<li>\n<p>If you have one table with all items in it rather than eight separate tables, you reduce the number of alarms and metrics to watch.</p>\n</li>\n<li>\n<p>Second, having a single table can save you money as compared to having multiple tables. With each table you have, you need to provision read and write capacity units. Often you will do some back-of-the-envelope math on the traffic you expect, bump it up by X%, and convert it to RCUs and WCUs.</p>\n</li>\n</ul>\n<p>In general, when thinking about single-table design, the main benefit is the performance improvement by making a single request to retrieve all needed items.</p>\n<p>Having said that, single table design does have its short-comings:</p>\n<ul>\n<li><strong>The inflexibility of adding new access patterns:</strong></li>\n</ul>\n<p>When modeling a single-table design in DynamoDB, you start with your access patterns first. Think hard (and write down!) how you will access your data, then carefully model your table to satisfy those access patterns. When doing this, you will organize your items into collections such that each access pattern can be handled with as few requests as possible—ideally a single request.</p>\n<p>Once you have your table modeled out, then you put it into action and write the code to implement it. Done properly, this will work great. Your application will be able to scale infinitely with no degradation in performance.</p>\n<p>However, your table design is narrowly tailored for the exact purpose for which it has been designed. If your access patterns change because you’re adding new objects or accessing multiple objects in different ways, you may need to do an ETL process to scan every item in your table and update with new attributes. This process isn’t impossible, but it does add friction to your development process.</p>\n<ul>\n<li><strong>The difficulty of exporting your tables for analytics:</strong></li>\n</ul>\n<p>DynamoDB is designed for on-line transactional processing (OLTP) use cases—high speed, high velocity data access where you’re operating on a few records at a time. But users also have a need for on-line analytics processing (OLAP) access patterns—big, analytical queries over the entire dataset to find popular items, number of orders by day, or other insights.</p>\n<h3 id=\"when-not-to-use-single-table-design\" style=\"position:relative;\"><a href=\"#when-not-to-use-single-table-design\" aria-label=\"when not to use single table design permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>When not to use single-table design</h3>\n<p>If your GraphQL query is resolved by multiple independent resolvers that are essentially independent from each other. Say we have the following graphql query where we have a nested Orders object for each User. The Orders object need not be nested but the idea here is that the query requires multiple resolvers:</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-cppgraphql\"><code class=\"language-cppgraphql\"><span class=\"token keyword\">query</span><span class=\"token punctuation\">{</span>\n    User<span class=\"token punctuation\">(</span><span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token number\">112233</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        firstName\n        lastName\n        addresses\n        orders<span class=\"token punctuation\">{</span>\n            orderDate\n            amount\n            status\n        <span class=\"token punctuation\">}</span>   \n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In the example above, the root resolver would execute first to find the User with ID 112233. This would involve a query to the database. Then, once that data is available, it would be passed to the Order resolver in order to fetch the relevant Orders for this User. This would make subsequent requests to the database to resolve those entities. Now our flow looks like this:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/183c7cbc3e5bdfd098c8f33f6411950d/d2cbc/graphql-ddb.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.72832369942196%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABs0lEQVQoz22SzW7TQBSF/S7wEpW65CWQuuoKsULiEZDYsWgfgSIkpErdwKIsCqhpGlWiSgIRSZq/xk7t+D9J/TNjjz/kofyo4khX584szj1z7hgAydCnTAS639ziOg5ZklBKSVWWmqkq8jzH931dYRhSVRX3YcQtE/vdN7zjK7JRhL+wuGyeMx+NdE0HA6b9Pq5p4boupmliWRbWYsF6FXH0ucOTvY8cfBoiZInhfhho5XXXIW7NoRBkmaDd6dJonNFsntfm6H29xLZtiqJACMFms2E+v2Z79yUPdvbZevaG7zMP4+Z1m8yMCU4m+McjpEqIYp8vpyc0W6f0fnS5TVdkyUoLeZ6HbTtEUcR0MuHR01c83Nlj+/lbetc+hvASloc91h0blRekYgNULJcOnU6b/qBPEAaMZ0PG47HOL45jgjAkjgIO3jd4/OKQ/aML0kxg1M+t1N9w03yNVDnWzZzWxRnj6RWFygljV2c4m810hrV4WZaoQujBgef8WsrvTdVcl1Il8Soiy1OKUiKl0Hc1lFJ601JKzXWeNeqzutMx/hXTDtNUT76P//yQP0Y03/U/ASnuUPeG0DbkAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"graphql-ddb\"\n        title=\"graphql-ddb\"\n        src=\"/static/183c7cbc3e5bdfd098c8f33f6411950d/1e043/graphql-ddb.png\"\n        srcset=\"/static/183c7cbc3e5bdfd098c8f33f6411950d/991de/graphql-ddb.png 173w,\n/static/183c7cbc3e5bdfd098c8f33f6411950d/e4d6b/graphql-ddb.png 345w,\n/static/183c7cbc3e5bdfd098c8f33f6411950d/1e043/graphql-ddb.png 690w,\n/static/183c7cbc3e5bdfd098c8f33f6411950d/d2cbc/graphql-ddb.png 705w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>In this flow, our backend is making multiple, serial requests to DynamoDB to fulfill our access pattern. This is exactly what we’re trying to avoid with single-table design!</p>\n<p>None of this goes to say that you can’t use DynamoDB with GraphQL—you absolutely can. I just think it’s a waste to spend time on a single-table design when using GraphQL with DynamoDB. Because GraphQL entities are resolved separately, I think it’s fine to model each entity in a separate table. It will allow for more flexibility and make it easier for analytics purposes going forward.</p>\n<h3 id=\"one-to-many-relationship\" style=\"position:relative;\"><a href=\"#one-to-many-relationship\" aria-label=\"one to many relationship permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>One to Many Relationship</h3>\n<p>A one-to-many relationship is when a particular object is the owner or source for a number of sub-objects. A few examples include:</p>\n<ul>\n<li>\n<p>Workplace: A single office will have many employees working there; a single manager may have many direct reports.</p>\n</li>\n<li>\n<p>E-commerce: A single customer may make multiple orders over time; a single order may be comprised of multiple items.</p>\n</li>\n</ul>\n<p>With one-to-many relationships, there’s one core problem: how do I fetch information about the parent entity when retrieving one or more of the related entities? In a relational database, there’s essentially one way to do this— using a foreign key in one table to refer to a record in another table and using a SQL join at query time to combine the two tables. There are no joins in DynamoDB. Instead, there are a number of strategies for one-to-many relationships, and the approach you take will depend on your needs.</p>\n<p>Let's look at tehe 5 strategies for one-to-many relationships:</p>\n<ul>\n<li><strong>Denormalization by using a complex attribute</strong></li>\n</ul>\n<p>We’ll use denormalization with DynamoDB by having an attribute that uses a complex data type, like a list or a map. This violates the first tenet of database normalization: to get into first normal form, each attribute value must be atomic. They cannot be broken down any further.</p>\n<p>Let's say there are Customer entities that represent people that have created an account on our site. A single Customer can have multiple mailing addresses to which they may ship items. Perhaps one address is home address, another for workplace, and a third address for a temporary location, etc. In a relational database, you would model this with two tables using a foreign key to link the tables together:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ac50a25aab34b4cda698c40c9a1e50a6/e9beb/normalized-table.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.6300578034682%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVQ4y41TyY7aQBTk/z+CQYDYBBwZxHJgWKSwmJBwSsQNkFi8YLu944rqZUwWRRkslauX19Wv+1XnAMCyLIzHY8xmM/T7fbRaLbTbbXQ6HRkbjUY4HA4MRZqm+N+X4+96vYpAs9VCvV5HoVBAPp9HtVqV8Uqlgt1uJwvu9/vHgrZtS4a911eM394wnU4xHA4xmUwku16vh+Px+HyGURzDt21Y375DXXX4QQDHceD7vmxGhGH4vGDg+1CGAWWaCIIASincbrcHExyn2EfIpXGMwHYQRRHiJBFmNhQgM0siSRI88+Vi5eGepiLAheS/QeEM/5rP1nJTObJuGGIXFoIs7cEAg8FAClIqlfDy8oJyuSx9xnEuiyd3u12xVg5JAtOyHvYg04fVel242WyiWCyi0WiIIGNoLfbZzjxbq9Ww3++Ru4chbF3HZv0Zi8UCX7ZfsdY0fBqNoC2X2Gw2WK1W2G63woyZz+fQNA3L5RLr9VrAcdM036vseQgcF45hIFQK7vmMwDSl8rQUbcNi8UUZhiHgvbH6vLvL5SLgHf/04XtlXdeF73mwTye4pzPsywXK82AaBjzPE0G+KjL73IjW4ga6rv8SzKrHHcMogqcUHF2Hcl0RpAjnybx4ZsPMeEQK8hURjBHBOI7/8B5ZXo/vP7xI5uIMv3uUJyN40h+YaguxjYVphwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Normalized-Table\"\n        title=\"Normalized-Table\"\n        src=\"/static/ac50a25aab34b4cda698c40c9a1e50a6/1e043/normalized-table.png\"\n        srcset=\"/static/ac50a25aab34b4cda698c40c9a1e50a6/991de/normalized-table.png 173w,\n/static/ac50a25aab34b4cda698c40c9a1e50a6/e4d6b/normalized-table.png 345w,\n/static/ac50a25aab34b4cda698c40c9a1e50a6/1e043/normalized-table.png 690w,\n/static/ac50a25aab34b4cda698c40c9a1e50a6/e9beb/normalized-table.png 730w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Notice that each record in the Addresses table includes a CustomerId, which identifies the Customer to which this Address belongs. You can follow the pointer to the record to find information about the Customer.</p>\n<p>DynamoDB works differently: we can have a MailingAddresses attribute on our Customer item. This attribute is a map and contains all addresses for the given customer:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b76d35ab574d2ed7ec73db1183c39ade/024d6/ddb-denormalized.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.86705202312138%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABrklEQVQoz21S2Y6cMBDk//8tD/uwiTKTBYyxwQcYbHMzVOTe2ZGibEulrnaX+rCd2WGC6jzuOce9qKH7QEhn/yJAWQ+hekjt/s91HtZFZEwY/Hj7hVshcMtrvL3fUUlLotb6F1IslMPPW4k/paC4MSOhfXrdBWStcfh9L5C86T0KJqA7D950BKkHVLIDb3sINaBuHfGU+yqYIPVIG2T4xo7zgUooQmrC6hZ1Y6DsgJwJQskbamxdIJg+wI0TshAiWqUwjh4hBCilEWJ8FX9cFx6PB/F13Ug7DCM4r1FVHFprWGsxzTOu60Lmn0VijPA+QGtDyWn6FJznCecc+W3b8PGRg1UVSsbwkefgnENKiXmeSfPtysmu6znhc7pk276j4jXKksF2PWKcnpvFlzY7jhPHcWDfd+qQ+LysKHmLomrQ2pE8ExqNHojnTFLc+wXOL+jHGen70bfpuh5FUVInYywYY/AhYpoXzPOKZd0x+oBl2RCnGUoZGNtDyBayUdC2g7EdWmVIm6WJ0mRf95XGTnxd1tca6bFo5W1DXX8+hhAS4zjCe49pmuDcgPN84C+v6vg0bilFPAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ddb-denormalized\"\n        title=\"ddb-denormalized\"\n        src=\"/static/b76d35ab574d2ed7ec73db1183c39ade/1e043/ddb-denormalized.png\"\n        srcset=\"/static/b76d35ab574d2ed7ec73db1183c39ade/991de/ddb-denormalized.png 173w,\n/static/b76d35ab574d2ed7ec73db1183c39ade/e4d6b/ddb-denormalized.png 345w,\n/static/b76d35ab574d2ed7ec73db1183c39ade/1e043/ddb-denormalized.png 690w,\n/static/b76d35ab574d2ed7ec73db1183c39ade/024d6/ddb-denormalized.png 961w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Because MailingAddresses contains multiple values, it is no longer atomic and, thus, violates the principles of first normal form.\nThere are two factors to consider when deciding whether to handle a one-to-many relationship by denormalizing with a complex attribute:</p>\n<p>• <strong>Do you have any access patterns based on the values in the complex attribute?</strong> Meaning, is there a scenario where you'd have to access items based off your complex attribute. For example, in the mailing address example above, do you have an access pattern where you'd ask: get me all the customers that live in the postal code 69361. You cannot use a complex attribute like a list or a map in a primary key. Thus, you won’t be able to make queries based on the values in a complex attribute. In our example, we can’t have any access patterns like \"Fetch a Customer by his or her mailing address\". All use of the MailingAddress attribute will be in the context of a Customer, such as displaying the saved addresses on the order checkout page.</p>\n<p>• <strong>Is the amount of data in the complex attribute unbounded?</strong> A single DynamoDB item cannot exceed 400KB of data. If the amount of data that is contained in your complex attribute is potentially unbounded, it won’t be a good fit for denormalizing and keeping together on a single item. But you could imagine other places where the one-to-many relationship might be unbounded. For example, our e-commerce application has a concept of Orders and Order Items. Because an Order could have an unbounded number of Order Items (you don’t want to tell your customers there’s a maximum number of items they can order!), it makes sense to split Order Items separately from Orders.</p>\n<p>If the answer to either of the questions above is \"Yes\", then denormalization with a complex attribute is not a good fit to model that one-to-many relationship.</p>\n<ul>\n<li><strong>Denormalization by duplicating data</strong></li>\n</ul>\n<p>In this strategy we’ll violate the principles of second normal form by duplicating data across multiple items. Imagine we have an application that contains Books and Authors. Each Book has an Author, and each Author has some biographical information, such as their name and birth year. In a relational database, we would model the data as follows:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b4b6c7fefeeb3b32b2751fba1a17e7a3/4cdf7/authors-and-books.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.47976878612717%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABE0lEQVQY0z1QTQuCUBD0//8FwUAs6BCJl0DJ8NQ1EjTKD7oEolBZ+W0Ts2APhnlvd3Z2eMp+v4fjOHBdF6vVCoZhYLPZYLfbwbZtRFEEHt/35b3dbgXr9Vq0nJ1qhOJ5HnRdh2mamM/nUFVVeLlcYjab4XA4iOHxePzrLMuCpmmiWywWoiUTyu12QxzHuF6vuFwuOJ/PgtPphCAIkOe5GBZFIWmpS9MUSZIIh2Eoes6yrwzDgOm832+8Xi/UdY2yLFFVFdq2lV7f938dZ77frzD7XddJfxxHKE3TiAEbTMFE9/sdWZbJ+/P5iMmkI3MR78/nUzRkBmAYMaQZwcLj8RATCnjndh72J+2UnIv5NVzOGvEDw2+u5x9kqJoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"authors-and-books\"\n        title=\"authors-and-books\"\n        src=\"/static/b4b6c7fefeeb3b32b2751fba1a17e7a3/1e043/authors-and-books.png\"\n        srcset=\"/static/b4b6c7fefeeb3b32b2751fba1a17e7a3/991de/authors-and-books.png 173w,\n/static/b4b6c7fefeeb3b32b2751fba1a17e7a3/e4d6b/authors-and-books.png 345w,\n/static/b4b6c7fefeeb3b32b2751fba1a17e7a3/1e043/authors-and-books.png 690w,\n/static/b4b6c7fefeeb3b32b2751fba1a17e7a3/4cdf7/authors-and-books.png 995w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>This works in a relational database as you can join those two tables at query-time to include the author’s biographical information when retrieving details about the book. But we don’t have joins in DynamoDB. So how can we solve this? We can ignore the rules of second normal form and include the Author’s biographical information on each Book item:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cd99bbafc08b8346d5ac1403d8706d38/33e10/author-duplicated.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.35260115606936%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABc0lEQVQoz3VSi27bMAz0/3/f1qVJXTvxU7b1omQ5iWXfICbtgmEjcBB5pE4koUzTAkUBygYYd8UgLfKyRnFpIc0MTQFcYwMm7V/gICbDSPGoHawLyH4cCrznFQ4fFX6+l3wW9YDjZ41fpwsOeYVUcyoa1EKjHQyEdOgnwuF0xtuxZL+XjhvIxkljUpYxSg2pCfNyB/nlyRukGpX4cEM/GeTnHh9li6qT6EZCfu5wLBqeLsM/LMYV/7M5LGi7Ab2YMEwa2nr0g3w0Eq7IlNKwRIgx8oVt27DtO/v7vj/iJ1LsfECTBAfJEyRBMSo+WXBdVxbbX0RCCNBaIyzLN/eVtzSjrDpGK1JnDlUjGIb8n5G5m2dHMW5YY2T/b/NzQNMKiGHinWvrIJXhzpfrDRmRg7X0fTkJzyGAiMA5Is5ba+G95zE/Ly3yokbTS/4yednwN1PGPUa+39fnnnbEbcODuzP/isRfbzfMc+BH1zXyupL/tf/fP8SyIeDmhngAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"author-duplicated\"\n        title=\"author-duplicated\"\n        src=\"/static/cd99bbafc08b8346d5ac1403d8706d38/1e043/author-duplicated.png\"\n        srcset=\"/static/cd99bbafc08b8346d5ac1403d8706d38/991de/author-duplicated.png 173w,\n/static/cd99bbafc08b8346d5ac1403d8706d38/e4d6b/author-duplicated.png 345w,\n/static/cd99bbafc08b8346d5ac1403d8706d38/1e043/author-duplicated.png 690w,\n/static/cd99bbafc08b8346d5ac1403d8706d38/33e10/author-duplicated.png 844w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Notice that there are multiple Books that contain the biographical information for the Author Stephen King. Because this information won’t change, we can store it directly on the Book item itself. Whenever we retreive the Book, we will also get information about the parent Author item.</p>\n<p>There are two main questions you should ask when considering this strategy:</p>\n<p>• Is the duplicated information immutable?</p>\n<p>• If the data does change, how often does it change and how many items include the duplicated information?</p>\n<p>In our example above, we’ve duplicated biographical information that isn’t likely to change. Because it’s essentially immutable, it’s OK to duplicate it without worrying about consistency issues when that data changes. Another example could be the notification created for a tool: if the notification is created once, the tool for which it was created will not be changed.</p>\n<ul>\n<li><strong>Composite primary key + the Query API action</strong></li>\n</ul>\n<p>This is probably the most common strategy, which is to use a composite primary key plus the Query API to fetch an object and its related sub-objects. Earlier, we discussed the notion of item collections. Item collections are all the items in a table or secondary index that share the same partition key. When using the Query API action, you can fetch multiple items within a single item collection. This can include items of different types, which can give you join-like behavior with much better performance characteristics.</p>\n<p>Let’s use the example of a SaaS application where Organizations will sign up for accounts. Then, multiple Users will belong to an Organization and take advantage of the subscription. For example, Google signing up for LinkedIn Learning and then Google employees are able to access the platform.</p>\n<p>Because we’ll be including different types of items in the same table, we won’t have meaningful attribute names for the attributes in our primary key. Rather, we’ll use generic attribute names, like PK and SK, for our primary key. We have two types of items in our table—Organizations and Users. The patterns for the PK and SK values are as follows:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a3a71697c11c41fe289eb3fc6378a329/0955e/saas-app-entity-chart.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 19.653179190751445%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAnklEQVQY022Q2w6EIAxE+f9PlCcxaESNwSsIOptpgtlsdl6a9JTOFNV1HcZxRNF931LXdcU8z/jW8zzCh2FAzhn/pIwxqKoKXDxN07twWRZorcWsaRrhIQRZWte19Nq2hXNOGHvee6jjOLDvO87zRIxRHlApJRnYtk0qEzMVOc1Kj7zU67qgGJ8DvyfTgOnJS0IaUkxVmLUWfd+/X/ABMyozqxhcZFMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"saas-app-entity-chart\"\n        title=\"saas-app-entity-chart\"\n        src=\"/static/a3a71697c11c41fe289eb3fc6378a329/1e043/saas-app-entity-chart.png\"\n        srcset=\"/static/a3a71697c11c41fe289eb3fc6378a329/991de/saas-app-entity-chart.png 173w,\n/static/a3a71697c11c41fe289eb3fc6378a329/e4d6b/saas-app-entity-chart.png 345w,\n/static/a3a71697c11c41fe289eb3fc6378a329/1e043/saas-app-entity-chart.png 690w,\n/static/a3a71697c11c41fe289eb3fc6378a329/0955e/saas-app-entity-chart.png 901w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Let's populate the data with some example items:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7adb4c61cad18987fd4c089445b44aa2/9937c/saas-app-data.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.80346820809249%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACPklEQVQoz22S647aSBBG/f4PFeXHjqLdmRBmgAGMb2BjfG3btC/txvZZ4ZmQZLUlHbWqqvV9qu4y4qIhKdsH99z2Y0w35JJKslI9SIvuF/f8k5+9QiqM6BhibUx2rxsO6x1nx+finXEcC/doYdl7fixfWK2XOO7hgetZODOH+bRdkygMMQYh0HGEjmN0EjOmGW0WEIYLUn9DfHrj4i0R4ZY6t2mEw9l94/31icBbEbgrDuu/OdjPnFZfMPifUGhMGeGICreo2OQXFoXLpg7ZNRH7LGfh+TjlFbu48noMWKYxjvmC0fY9TV1z05ppmoAR2U68ODkr32flh5hJwrEqsXOBU5QsvICvb1u+uwELL+SvzY6v+4DF0ztGoxS1lGitYRacKOqRKB9mcYaRXkHTAsPHBF3TkkQJuuvRSiOSFHHV2N9dDIYblAVTWTJ9jlwq8MXAOPXoQSNqRdlNj77sOsI0R9QNZdORCIFfKrb/2BhDWTCkKWOeMeQ5FDnXS852FXHanznuQ07mmchNiNyMyM3n2m5pY62OBFaMvfZwDoLD0xaDWoKUjFX1YLpWZEHKybrg37Ej0qAgO5eIS8VhG/D87R3z/cx+E/Dj2WS99EiCDEO2Lfd3/G+MTIzTMDNMwx+9ru8RVcUwTaibplEdAxP9MGJ0XUev1McP/4ZSPVLWSCnpOjWXx3GcBXNxxXID4rQkFRL3GBLGgkq2v/bwLvg7Wt/olOJuqD9X6mOtmM2Kopzv3G4D16uczYZx5F9j3IrYfvC6jQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"saas-app-data\"\n        title=\"saas-app-data\"\n        src=\"/static/7adb4c61cad18987fd4c089445b44aa2/1e043/saas-app-data.png\"\n        srcset=\"/static/7adb4c61cad18987fd4c089445b44aa2/991de/saas-app-data.png 173w,\n/static/7adb4c61cad18987fd4c089445b44aa2/e4d6b/saas-app-data.png 345w,\n/static/7adb4c61cad18987fd4c089445b44aa2/1e043/saas-app-data.png 690w,\n/static/7adb4c61cad18987fd4c089445b44aa2/e3189/saas-app-data.png 1035w,\n/static/7adb4c61cad18987fd4c089445b44aa2/9937c/saas-app-data.png 1156w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>In this table, we’ve added five items—two Organization items for Microsoft and Amazon, and three User items for Bill Gates, Satya Nadella, and Jeff Bezos. Outlined in red is the item collection for items with the partition key of ORG#MICROSOFT. Notice how there are two different item types in that collection. In green is the Organization item type in that item collection, and in blue is the User item type in that item collection.</p>\n<p>This primary key design makes it easy to solve four access patterns:</p>\n<ol>\n<li>\n<p>Retrieve an Organization. Use the GetItem API call and the Organization’s name to make a request for the item with a PK of <code class=\"language-cpptext\">ORG#&lt;OrgName&gt;</code> and an SK of <code class=\"language-cpptext\">METADATA#&lt;OrgName&gt;.</code></p>\n</li>\n<li>\n<p>Retrieve an Organization and all Users within the Organization. Use the Query API action with a key condition expression of <code class=\"language-cpptext\">PK = ORG#&lt;OrgName&gt;</code>. This would retrieve the Organization and all Users within it, as they all have the same partition key.</p>\n</li>\n<li>\n<p>Retrieve only the Users within an Organization. Use the Query API action with a key condition expression of</p>\n</li>\n</ol>\n<p><code class=\"language-cpptext\">PK = ORG#&lt;OrgName&gt; AND begins_with(SK, &quot;USER#&quot;)</code>.\nThe use of the <code class=\"language-cpptext\">begins_with()</code> function allows us to retrieve only the Users without fetching the Organization object as well.</p>\n<ol start=\"4\">\n<li>Retrieve a specific User. If you know both the Organization name and the User’s username, you can use the GetItem API call with a PK of <code class=\"language-cpptext\">ORG#&lt;OrgName&gt;</code> and an SK of <code class=\"language-cpptext\">USER#&lt;Username&gt;</code> to fetch the User item.</li>\n</ol>\n<p>While all four of these access patterns can be useful, the second access pattern—Retrieve an Organization and all Users within the Organization—is most interesting for this discussion of one-to- many relationships. Notice how we’re emulating a join operation in SQL by locating the parent object (the Organization) in the same item collection as the related objects (the Users). We are pre-joining our data by arranging them together at write time. This is a pretty common way to model one-to-many relationships and will work for a number of situations.</p>\n<ul>\n<li><strong>Secondary index + the Query API action</strong></li>\n</ul>\n<p>Another pattern for one-to-many relationships is to use a global secondary index and the Query API to fetch multiple items in a single request. This pattern is almost the same as the previous pattern, but it uses a secondary index rather than the primary keys on the main table. You may need to use this pattern instead of the previous pattern because the primary keys in your table are reserved for another purpose. It could be some write-specific purpose, such as to ensure uniqueness on a particular property, or it could be because you have hierarchical data with a number of levels.</p>\n<ul>\n<li><strong>Composite sort keys with hierarchical data</strong></li>\n</ul>","timeToRead":36,"excerpt":"My notes as I walk through the great book on DynamoDB - DynamoDB Book by Alex DeBrie All images and examples used below are taken from the…","frontmatter":{"title":"DynamoDB Notes","date":"2021-09-08T00:00:00.000Z","categories":["General"],"extract":"My notes as I learn DynamoDB","thumbnail":"/post-images/dynamo-db.png","tags":["blog"]},"fields":{"slug":"/dynamo-db-notes","date":"September 08, 2021"}}},"pageContext":{"slug":"/dynamo-db-notes","nexttitle":"ReactJS Notes","nextslug":"/react-js-notes","prevtitle":"Micro Frontend","prevslug":"/micro-frontend"}},"staticQueryHashes":["3969716136"]}