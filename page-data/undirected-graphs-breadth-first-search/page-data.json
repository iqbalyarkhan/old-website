{"componentChunkName":"component---src-templates-post-js","path":"/undirected-graphs-breadth-first-search","result":{"data":{"markdownRemark":{"html":"<h3 id=\"table-of-contents\"><a href=\"#table-of-contents\" aria-label=\"table of contents permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Table of Contents</h3>\n<ol>\n<li><a href=\"#introduction\">Introduction</a></li>\n<li><a href=\"#bfs-vs-dfs\">BFS vs DFS</a></li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n<li>\n<p>[Problems]</p>\n<ul>\n<li><a href=\"#number-of-islands\">Number of islands</a></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"introduction\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h3>\n<p>Breadth first search, as the name suggests, is concerned with looking at vertices that are closest to the current vertex. It gradually moves away from the starting vertex. BFS, therefore, can help find the shortest path to vertices from a given vertex. BFS does so by first exploring all vertices 1 edge away from the source, then exploring all vertices 2 edges away from the source and so on. </p>\n<p>In contrast, depth first search took a long route to find a path. That is because DFS is not designed to find the shortest route. It is used to find <strong>a</strong> route. Therefore, DFS helped us answer whether a path existed, BFS will help us find the shortest path from the starting node. </p>\n<p>In breadth first search, we start the search from elements closest to the starting node. The only difference between the code for depth first and breadth first is that breadth first uses <code class=\"language-cpptext\">queue</code> instead of <code class=\"language-cpptext\">stack</code>. </p>\n<p>The algorithm has 3 main steps:</p>\n<ul>\n<li>Remove a vertex from the queue</li>\n<li>Mark all vertices adjacent to current vertex and push them onto the queue</li>\n<li>Repeat until queue is empty</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber 0\" class=\"language-cppcpp line-numbers\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> AdjList<span class=\"token operator\">::</span><span class=\"token function\">BFS</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">visited</span><span class=\"token punctuation\">(</span>vectorSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span>\n    visited<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> curr <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> curr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n        q<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> adjList<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> neighbor <span class=\"token operator\">=</span> adjList<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>visited<span class=\"token punctuation\">[</span>neighbor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                edgeTo<span class=\"token punctuation\">[</span>neighbor<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n                visited<span class=\"token punctuation\">[</span>neighbor<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>neighbor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p> The code above first creates a boolean vector to keep track of visited elements called <code class=\"language-cpptext\">visited</code>.</p>\n<p> We also create a queue to push elements so that we can visit them later. We want first in first out for breadth first search because we want to explore all the nodes closest to the starting node first. </p>\n<p> Next we push the passed element, <code class=\"language-cpptext\">v</code>, onto the queue and mark it. Then we enter a while loop until the queue is empty. </p>\n<p> We pop an element off the queue, call it <code class=\"language-cpptext\">curr</code>, and start to visit and mark all the elements that are adjacent to <code class=\"language-cpptext\">curr</code>. In the process, we also go ahead and mark these adjacent vertices. This is because we're <strong>visiting</strong> them at this time and this is because BFS is interested in the vertices closest to the passed in vertex. At this point we also populate the <code class=\"language-cpptext\">edgeTo</code> array to record how we got to the current vertex. </p>\n<p>We then push each one of these visited vertices onto the queue.</p>\n<p>Let's walk through an example again. Here is the graph we're using:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 423px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.41371158392435%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAABr0lEQVQ4y5VUy07DMBDshyNx4CO48A2AeNw4wA0kpBYhVSDxUlq1oFZJG9txbMcZdk2TJml5rbSyk/WOx7Nr98qyBBuPvvRh/KtX1pz3uj/+YzI3cEXRAu351eRhOsHx4BbGODhjkWuDPMuhlUYmMyihIJcyuKbvJBbYOz/G9ctzyPfetwH7UYSDq0vM32MoSjIEGJxYWNrAuQKl/5KEN4o/YtwMnzAXss2wmnhK8HnBEahUBWZdYxbMsGILOk1Bm1WA7DUgs+CFlTE7kYjARtA8ow1EkqIgzbTUsLlFsdrgW0DWqlukGWm1c3qGwWv0tc66GoTBm4CtIzta2ASspaBxMJ5AkJZsKbGsClCu5Gl+twFFm2G3nRTFWYJmjHM491fAJmhBznG5kBtx1t00CrMGdK4uyrbbIBYiaNYFdFxpvQWQxIJRZqNVMmsxjMahyiGpE9fE7nE0gd+8KVPsX14gpmNlxDQlRk7m6L+8YffsCNNZAk0FEKvbwowttc/9W0RdcIhZqtpVHsUJTu4GyKjn6iORWzrmnLTd+jhwnC7EdCnWDH96HH57MrpxxvkEECqUXQvSv5wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Undirected-Graph-1\"\n        title=\"Undirected-Graph-1\"\n        src=\"/static/e302006a5aa2e4f676efbd57fdc17139/d7276/path1.png\"\n        srcset=\"/static/e302006a5aa2e4f676efbd57fdc17139/27f03/path1.png 173w,\n/static/e302006a5aa2e4f676efbd57fdc17139/376d0/path1.png 345w,\n/static/e302006a5aa2e4f676efbd57fdc17139/d7276/path1.png 423w\"\n        sizes=\"(max-width: 423px) 100vw, 423px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span> <a href=\"https://graphonline.ru/en/\">Image Credit - Undirected Graph 1</a></p>\n<p>Let's say we start at vertex 0 and our queue is empty and the visited array has each entry as false and edgeTo array is empty:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">queue:             \n\nvisited[0] =        \nvisited[1] = \nvisited[2] = \nvisited[3] = \nvisited[4] =\nvisited[5] =  \n\nedgeTo[0] =        \nedgeTo[1] = \nedgeTo[2] = \nedgeTo[3] = \nedgeTo[4] = \nedgeTo[5] = </code></pre></div>\n<p>Since we start at 0, we push and mark it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">                   current Vertex: 0\nqueue:                  0\n\nvisited[0] =             T\nvisited[1] = \nvisited[2] = \nvisited[3] = \nvisited[4] =\nvisited[5] =  \n\nedgeTo[0] =             0\nedgeTo[1] = \nedgeTo[2] = \nedgeTo[3] = \nedgeTo[4] = \nedgeTo[5] = </code></pre></div>\n<p>We then go inside the <code class=\"language-cpptext\">while</code> loop, pop 0 from queue, visit all its neighbors, mark them and push them on queue:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">                   current Vertex<span class=\"token operator\">:</span> <span class=\"token number\">0</span>\nqueue<span class=\"token operator\">:</span>                 <span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span>\n\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> \nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\n\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>     \nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> \nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span></code></pre></div>\n<p>Next, we go back to the top of the while loop and pop another element off the queue which is 2:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">                   current Vertex<span class=\"token operator\">:</span> <span class=\"token number\">2</span>\nqueue<span class=\"token operator\">:</span>                 <span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span>\n\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> \nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\n\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>     \nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> \nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span></code></pre></div>\n<p>We then move through the adjacency list for 2 and mark each vertex and push each to the queue as well:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">                   current Vertex<span class=\"token operator\">:</span> <span class=\"token number\">2</span>\nqueue<span class=\"token operator\">:</span>                 <span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span>\n\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\nvisited<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             T\n\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">2</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">2</span>\nedgeTo<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>             <span class=\"token number\">0</span></code></pre></div>\n<p>Although the marking is done and our <code class=\"language-cpptext\">edgeTo</code> array is fully created, the algorithm keeps running until all the elements from the queue are popped off. Notice how the <code class=\"language-cpptext\">edgeTo</code> list now notes that we got to 1,2 and 5 from 0 and we got to 3 and 4 from 2. So if you were to call the <code class=\"language-cpptext\">FindPath()</code> function, it'll provide you with the shortest path from any vertex to any other vertex. </p>\n<p>You can create a tree using the <code class=\"language-cpptext\">edgeTo</code> array (look at <a href=\"/undirected-graphs-depth-first-search\">DFS</a> to see how I did it). The tree in BFS's case would look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">        0\n      / | \\\n     1  2  5\n       / \\\n      3   4</code></pre></div>\n<p><strong>Notice in DFS we mark a vertex not as soon as we visit it while go through another vertex's adjacency list but it is marked when it is its turn to be processed. However, in BFS, we mark the element as soon as we visit it while exploring another vertex's adjacency list.</strong> BFS says: as soon as you get to a vertex, mark it and push it to the queue. </p>\n<p>Similar to DFS, the running time for BFS is also <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(V + E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<h3 id=\"bfs-vs-dfs\"><a href=\"#bfs-vs-dfs\" aria-label=\"bfs vs dfs permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BFS vs DFS</h3>\n<p>When do we choose one over the other? </p>\n<p><strong>BFS</strong>\nHelps us find all the vertices that are one edge away from the starting position, then 2 edges away and so on. BFS, therefore, is to be used when you're looking to find the shortest path to a vertex. </p>\n<p><strong>DFS</strong>\nHelps us actually answer the question whether a path exists between the vertices we're interested in. </p>\n<h3 id=\"conclusion\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h3>\n<p>Relationship between objects can be represented using undirected graphs and a lot of questions can be answered about the said objects using the BFS as we've discussed in this section.</p>\n<h3 id=\"number-of-islands\"><a href=\"#number-of-islands\" aria-label=\"number of islands permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Number of islands</h3>\n<p><strong>Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</strong></p>\n<p>Let's see an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">    <span class=\"token punctuation\">{</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>In the diagram above, we can see that we have 3 islands. Let's start with the basics: </p>\n<ul>\n<li>We can return 0 is the array is empty</li>\n<li>We'd have to iterate over each cell therefore we'll setup nested for loops</li>\n<li>Next, if the current character is <code class=\"language-cpptext\">0</code>, we can ignore it and move to next cell</li>\n<li>\n<p>If the current character is <code class=\"language-cpptext\">1</code> is where we need to process more:</p>\n<ul>\n<li>We can start queuing up all the neighbors that are 1</li>\n<li>While our queue is not empty, pop from queue, and proceed to enqueue <strong>unvisited</strong> neighbors</li>\n</ul>\n</li>\n</ul>\n<p>We'll start at 0,0 and have a visited array that is filled with false since we haven't processed any of our elements. Next, we'll enqueue 0,0, mark 0,0 as visited and explore its neighbors (up, down, left, right). If any of the neighbors has a value of <code class=\"language-cpptext\">1</code> and we haven't visited that neighbor, we mark visited[neighbor coordinates] as true and push the neighbor to our queue. </p>\n<p>We'll continue the process until our queue is empty. Why does this work? In our first iteration, we'll increment the islands count from 0 to 1 and then proceed to process all the neighbors 0,0 until our queue is empty. This means we'll process:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span></code></pre></div>\n<p>These are all the connected neighbors that have a value of 1. After we've processed them all, we'll have no more elements on the queue so we'll return and continue exploring our 2d grid until we find another <code class=\"language-cpptext\">1</code>. This would be at 3,0. At this point, we'll increment our count from 1 to 2 and start pushing all neighbors that are 1 to the queue:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span></code></pre></div>\n<p>Once we're done with this, our queue will be empty and we'll continue processing until we get to 3,3 and we'll increment the count for islands one last time!</p>\n<p>Notice in the approach above, we're using an extra visited array. That array can be removed if we're allowed to modify the original array in which case we'll simply change the <code class=\"language-cpptext\">1</code> to a <code class=\"language-cpptext\">0</code>.</p>\n<ul>\n<li><a href=\"https://leetcode.com/problems/walls-and-gates/\">Problem 2</a> </li>\n<li><a href=\"https://leetcode.com/problems/rotting-oranges/\">Problem 3</a></li>\n<li><a href=\"https://leetcode.com/problems/accounts-merge/\">Problem 4</a></li>\n</ul>","timeToRead":7,"excerpt":"Table of Contents Introduction BFS vs DFS Conclusion Problems Number of islands Introduction Breadth first search, as the name suggests, is…","frontmatter":{"title":"Undirected Graphs Breadth First Search","date":"2020-02-16T00:00:00.000Z","categories":["Graphs"],"extract":"An analysis of Breadth First Search on undirected graphs","thumbnail":"/post-images/bfs.png","tags":["Algorithms","Graphs"]},"fields":{"slug":"/undirected-graphs-breadth-first-search","date":"February 16, 2020"}}},"pageContext":{"slug":"/undirected-graphs-breadth-first-search","nexttitle":"Undirected Graphs Depth First Search","nextslug":"/undirected-graphs-depth-first-search","prevtitle":"Pointers","prevslug":"/pointers"}}}