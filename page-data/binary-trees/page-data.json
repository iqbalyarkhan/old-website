{"componentChunkName":"component---src-templates-post-js","path":"/binary-trees","result":{"data":{"markdownRemark":{"html":"<h3 id=\"table-of-contents\"><a href=\"#table-of-contents\" aria-label=\"table of contents permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Table of Contents</h3>\n<ol>\n<li><a href=\"#intro\">Intro</a></li>\n<li>\n<p>Problems</p>\n<ul>\n<li><a href=\"#traversal\">Traversal</a></li>\n<li><a href=\"#find-height\">Find height</a></li>\n<li><a href=\"#check-if-balanced\">Check if balanced</a></li>\n<li><a href=\"#check-if-tree-is-symmetric\">Check if tree is symmetric</a></li>\n<li><a href=\"#merge-two-trees\">Merge two trees</a></li>\n<li><a href=\"#invert-a-binary-tree\">Invert a binary tree</a></li>\n<li><a href=\"#are-they-cousins\">Are they cousins</a></li>\n<li><a href=\"#lca\">LCA</a></li>\n<li><a href=\"#lca-with-parent\">LCA with parent</a></li>\n<li><a href=\"#binary-sum-from-root-to-leaf\">Binary sum from root to leaf</a></li>\n<li><a href=\"#path-to-leaf-with-sum\">Path to leaf with sum</a></li>\n<li><a href=\"#in-order-without-recursion\">In-order without recursion</a></li>\n<li><a href=\"#pre-order-without-recursion\">Pre-order without recursion</a></li>\n<li><a href=\"#find-in-order-successor\">Find in-order successor</a></li>\n<li><a href=\"#form-list-from-leaves\">Form list from leaves</a></li>\n<li><a href=\"#vertical-order-traversal\">Vertical Order Traversal</a></li>\n<li><a href=\"#remove-leaf-nodes-with-given-value\">Remove leaf nodes with given value</a></li>\n<li><a href=\"#diameter-of-a-tree\">Diameter of a tree</a></li>\n<li><a href=\"#level-order-traversal\">Level order traversal</a></li>\n</ul>\n</li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n</ol>\n<h3 id=\"intro\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h3>\n<p>A binary tree is a data structure that is useful for representing hierarchy. Formally a binary tree is either empty or a root node r together with a left binary tree and a right binary tree.</p>\n<p>The depth of a node n is the number of nodes on the search path from the root to n, not including n itself. The height of a binary tree is the maximum depth of any node in that tree. A level of a tree is all nodes at the same depth.</p>\n<p>A full binary tree is a binary tree in which every node other than the leaves has two children. </p>\n<p>A perfect binary tree is a full binary tree in which all leaves are at the same depth, and in which every parent has two children. </p>\n<p>A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.  </p>\n<p>3 main types of traversals are: preorder, inorder and postorder.</p>\n<p>Basic data structure to represent a node in our tree would be:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">{</span>\n    T data<span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">*</span> left <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">*</span> right <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"traversal\"><a href=\"#traversal\" aria-label=\"traversal permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Traversal</h3>\n<p><strong>Given a binary tree, traverse the tree in pre-, in- and post-orders.</strong></p>\n<p>Recursively this is quite simple:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">PreOrder</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    \n    cout <span class=\"token operator\">&lt;&lt;</span> root<span class=\"token operator\">-></span>data <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">PreOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">PreOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">InOrder</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">InOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> root<span class=\"token operator\">-></span>data <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">InOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Postorder</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">Postorder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Postorder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> root<span class=\"token operator\">-></span>data <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Running time is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> and space complexity is the call stack used to traverse the tree which at most uses <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span> space where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span></span></span></span> is the height of our tree. </p>\n<h3 id=\"find-height\"><a href=\"#find-height\" aria-label=\"find height permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Find Height</h3>\n<p><strong>Given a binary tree, find the height of the tree</strong></p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">    \n            <span class=\"token number\">12</span>\n           <span class=\"token operator\">/</span>  \\\n         <span class=\"token number\">11</span>   <span class=\"token number\">10</span>\n        <span class=\"token operator\">/</span>  \\   \n       <span class=\"token number\">9</span>    <span class=\"token number\">8</span> \n      <span class=\"token operator\">/</span>  \n     <span class=\"token number\">7</span>\n    <span class=\"token operator\">/</span>\n   <span class=\"token number\">6</span>\nHeight is the longest path from root to leaf<span class=\"token operator\">:</span> <span class=\"token number\">12</span><span class=\"token operator\">-</span><span class=\"token number\">11</span><span class=\"token operator\">-</span><span class=\"token number\">9</span><span class=\"token operator\">-</span><span class=\"token number\">7</span><span class=\"token operator\">-</span><span class=\"token number\">6</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">(</span>I<span class=\"token number\">'</span>m counting root as level <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>   </code></pre></div>\n<p>Let's think through it logically: </p>\n<ul>\n<li>If the node is null, its height is 0</li>\n<li>If the node is not null BUT has both left and right pointers as null, then the height is 1.</li>\n<li>Otherwise, the height is equal to the max height of left subtree and right subtree plus 1 (for the current node).</li>\n</ul>\n<p>Translated to code:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">FindHeight</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span> <span class=\"token operator\">&amp;&amp;</span> root<span class=\"token operator\">-></span>right <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">int</span> lH <span class=\"token operator\">=</span> <span class=\"token function\">FindHeight</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> rH <span class=\"token operator\">=</span> <span class=\"token function\">FindHeight</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> currH <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>lH<span class=\"token punctuation\">,</span>rH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    currH<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> currH<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Running time is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is the number of nodes in the tree. Space complexity is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span> because the max number of recursive calls at a given time on the call stack are equal to the max height of the tree. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span></span></span></span> is the height of the tree</p>\n<h3 id=\"check-if-balanced\"><a href=\"#check-if-balanced\" aria-label=\"check if balanced permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Check if balanced</h3>\n<p><strong>Write a program that takes as input the root of a binary tree and checks whether the tree is height-balanced.\nA binary tree is said to be height-balanced if for each node in the tree, the difference in the height of its left and right subtrees is at most one.</strong></p>\n<p>A brute force approach would be to start at root, look at left subtree and then right subtree and compared. Then move to left subtree and then look at its left subtree and right subtree and compare. Continue until you either find imbalance or you're out of nodes to consider. The running time is approximately <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>h</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span></span></span></span> is the height of the tree. This seems complicated and time consuming. </p>\n<p>Another approach would be to recursively go down the tree and once at the leaf, start coming back up and storing the heights in a data structure which can be accessed later to compare the heights for each node. This is better time wise than brute force but requires more space for that external data structure. </p>\n<p>Best approach makes use of this insight: we're only interested in seeing if the heights differ by more than 1, we do not need to store the heights. After processing each node's left and right subtrees, we can look at the heights returned and determine whether the tree is balanced. As soon as we find a subtree that is unbalanced, we can return. </p>\n<p>So here's how this approach works. Say we have this tree:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">    \n            <span class=\"token number\">12</span>\n           <span class=\"token operator\">/</span>  \\\n         <span class=\"token number\">11</span>   <span class=\"token number\">10</span>\n        <span class=\"token operator\">/</span>  \\   \n       <span class=\"token number\">9</span>    <span class=\"token number\">8</span> \n      <span class=\"token operator\">/</span>  \n     <span class=\"token number\">7</span>\n    <span class=\"token operator\">/</span>\n   <span class=\"token number\">6</span>   </code></pre></div>\n<p>this tree is unbalanced because node <code class=\"language-cpptext\">9</code> has left subtree that has height 2 and right subtree that has height 0. We'll make our way down the tree using one of the tree traversal methods we discussed in the previous question: post-order traversal. That is because we need to process the left subtree of a node, then right subtree of a node and then compare those heights at the node which fits well with how post order works. </p>\n<p>Having said that, this is how we'll go down the tree:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">    <span class=\"token number\">12</span>\n     <span class=\"token operator\">|</span>_ <span class=\"token number\">11</span>\n         <span class=\"token operator\">|</span>_ <span class=\"token number\">9</span>\n            <span class=\"token operator\">|</span>_ <span class=\"token number\">7</span>\n               <span class=\"token operator\">|</span>_ <span class=\"token number\">6</span>\n\n<span class=\"token number\">6</span> has no children<span class=\"token punctuation\">,</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n\n    <span class=\"token number\">12</span>\n     <span class=\"token operator\">|</span>_ <span class=\"token number\">11</span>\n         <span class=\"token operator\">|</span>_ <span class=\"token number\">9</span>\n            <span class=\"token operator\">|</span>_ <span class=\"token number\">7</span>\n\n<span class=\"token number\">7</span> has no right children <span class=\"token keyword\">return</span> <span class=\"token number\">0.</span>\n\nSo now that we<span class=\"token string\">'ve processed both the left and right subtree of 7, we'</span>re ready to compare<span class=\"token operator\">:</span>\n<span class=\"token number\">7</span><span class=\"token operator\">-></span>left height <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token number\">7</span><span class=\"token operator\">-></span>right height <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token operator\">|</span>left <span class=\"token operator\">-</span> right<span class=\"token operator\">|</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span> so we<span class=\"token string\">'re good. Now for 7'</span>s parent<span class=\"token punctuation\">,</span> <span class=\"token keyword\">return</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1.</span>\n\n    <span class=\"token number\">12</span>\n     <span class=\"token operator\">|</span>_ <span class=\"token number\">11</span>\n         <span class=\"token operator\">|</span>_ <span class=\"token number\">9</span>\n            <span class=\"token operator\">|</span>_ <span class=\"token number\">7</span> returned <span class=\"token number\">2</span>\n            <span class=\"token operator\">|</span>_ <span class=\"token constant\">NULL</span> returned <span class=\"token number\">0</span>\n\nNow look at <span class=\"token number\">9</span><span class=\"token operator\">-></span>right<span class=\"token operator\">:</span> has no children<span class=\"token punctuation\">,</span> so <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n\nWe<span class=\"token number\">'</span>re done processing left <span class=\"token operator\">and</span> right subtrees <span class=\"token keyword\">for</span> <span class=\"token number\">9</span><span class=\"token operator\">:</span>\n<span class=\"token number\">9</span><span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n<span class=\"token number\">9</span><span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n \n<span class=\"token operator\">|</span>left <span class=\"token operator\">-</span> right<span class=\"token operator\">|</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span> so we found imbalance<span class=\"token operator\">!</span> No need to process any further<span class=\"token punctuation\">,</span> we know the tree is unbalanced</code></pre></div>\n<p>Converting this to code is simple:</p>\n<ul>\n<li>If our node is null, return 0</li>\n<li>If our node has left and right child as null but is not itself null, return 1</li>\n<li>\n<p>If neither left nor right is null, call the function again on the left subtree and the right subtree</p>\n<ul>\n<li>Once you have the results from left and right subtrees, take the max of returned values, add 1 (for current level) and return</li>\n</ul>\n</li>\n</ul>\n<p>This is would translate to:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">{</span>\n    T data<span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">*</span> left <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">*</span> right <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n   \n<span class=\"token keyword\">int</span> <span class=\"token function\">getH</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>left <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span> <span class=\"token operator\">&amp;&amp;</span> node<span class=\"token operator\">-></span>right <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n        \n    <span class=\"token keyword\">int</span> leftHeight <span class=\"token operator\">=</span> <span class=\"token function\">RecursiveFunction</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> rightHeight <span class=\"token operator\">=</span> <span class=\"token function\">RecursiveFunction</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//Now that we have the two heights, compare and assign max + 1 to current height:</span>\n    <span class=\"token keyword\">int</span> currH <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>leftHeight<span class=\"token punctuation\">,</span>rightHeight<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> currH<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In our code, we need to keep track of whether we've encountered any unbalanced nodes. To check if we've got any unbalanced nodes, we need to compare whether the left and right heights differ by more than 1. To keep track of this, we need a global variable. As soon as it turns false, we can start unwinding our recursive call stack. </p>\n<p>An observation: we're using two pieces of related information: the height and isBalanced boolean variable. We can combine the two into one struct called <code class=\"language-cpptext\">statusAndHeight</code> and use that to keep track of the height we found and whether the node was unbalanced:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">statusAndHeight</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> height<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">bool</span> status<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n\nstatusAndHeight <span class=\"token function\">getH</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span> <span class=\"token operator\">&amp;&amp;</span> root<span class=\"token operator\">-></span>right <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    \n    <span class=\"token keyword\">auto</span> left <span class=\"token operator\">=</span> <span class=\"token function\">getH</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>left<span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">auto</span> right <span class=\"token operator\">=</span> <span class=\"token function\">getH</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>right<span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">int</span> currH <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">bool</span> isBal <span class=\"token operator\">=</span> <span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">.</span>height <span class=\"token operator\">-</span> right<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isBal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Balance not right for node: \"</span> <span class=\"token operator\">&lt;&lt;</span> root<span class=\"token operator\">-></span>data <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>currH<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> isBal<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Notice, we also immediately return if left is unbalanced or right is unbalanced in our checks by returning -1 and false for our return struct. That way we don't have to unnecessarily continue processing remaining nodes. Running time of this algorithm is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is the number of nodes and since we recurse through the tree, space complexity is the call stack that we use: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span></span></span></span> is the height of our tree. </p>\n<h3 id=\"check-if-tree-is-symmetric\"><a href=\"#check-if-tree-is-symmetric\" aria-label=\"check if tree is symmetric permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Check if tree is symmetric</h3>\n<p><strong>Write a program that checks whether a binary tree is symmetric. Symmetric tree is where a vertical line can be drawn from the root dividing the tree into mirror images (values of the nodes and positions match in each half)</strong></p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Is symmetric<span class=\"token operator\">:</span>\n            <span class=\"token number\">314</span>\n           <span class=\"token operator\">/</span>   \\\n          <span class=\"token number\">6</span>     <span class=\"token number\">6</span>\n         <span class=\"token operator\">/</span>       \\   \n        <span class=\"token number\">2</span>         <span class=\"token number\">2</span>\n         \\       <span class=\"token operator\">/</span>\n         <span class=\"token number\">4</span>      <span class=\"token number\">4</span>\n        <span class=\"token operator\">/</span>        \\\n       <span class=\"token number\">1</span>          <span class=\"token number\">1</span>   \n\nNot symmetric<span class=\"token operator\">:</span>\n            <span class=\"token number\">314</span>\n           <span class=\"token operator\">/</span>   \\\n          <span class=\"token number\">6</span>     <span class=\"token number\">6</span>\n         <span class=\"token operator\">/</span>       \\   \n        <span class=\"token number\">2</span>         <span class=\"token number\">5</span>\n         \\       <span class=\"token operator\">/</span>\n         <span class=\"token number\">4</span>      <span class=\"token number\">4</span>\n        <span class=\"token operator\">/</span>        \\\n       <span class=\"token number\">1</span>          <span class=\"token number\">1</span>   \n\n\nNot symmetric<span class=\"token operator\">:</span>\n            <span class=\"token number\">314</span>\n           <span class=\"token operator\">/</span>   \\\n          <span class=\"token number\">6</span>     <span class=\"token number\">6</span>\n         <span class=\"token operator\">/</span>       \\   \n        <span class=\"token number\">2</span>         <span class=\"token number\">2</span>\n         \\         \\\n         <span class=\"token number\">4</span>          <span class=\"token number\">4</span>\n        <span class=\"token operator\">/</span>          <span class=\"token operator\">/</span> \n       <span class=\"token number\">1</span>          <span class=\"token number\">1</span>        </code></pre></div>\n<p>Brute force approach is to start with root's left subtree and copy the values to an external data structure, say an array. Then iterate over the right subtree and match the values as you iterate. If there's a mismatch, it is not symmetric, otherwise the tree is symmetric. Running time is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is the number of nodes. Space is approx <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> for the array. </p>\n<p>Can we do this without saving half the tree in an array? We can try to go down each half of the tree simultaneously. One pointer goes down root's left subtree and the other goes down root's right subtree. However, the order of traversal shouldn't be the same. That is because for the tree to be symmetric, the left pointer's left child is right pointers right child. So, the order of traversal should be mirrored as well: left pointer's left child must equal right pointer's right child. Therefore left pointer can traverse in <code class=\"language-cpptext\">node left right</code> while right pointer can traverse in <code class=\"language-cpptext\">node right left</code> fashion. Let's have a look at the symmetric tree again and see the output for the left and right pointers:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Is symmetric<span class=\"token operator\">:</span>\n            <span class=\"token number\">314</span>\n           <span class=\"token operator\">/</span>   \\\n          <span class=\"token number\">6</span>     <span class=\"token number\">6</span>\n         <span class=\"token operator\">/</span>       \\   \n        <span class=\"token number\">2</span>         <span class=\"token number\">2</span>\n         \\       <span class=\"token operator\">/</span>\n         <span class=\"token number\">4</span>      <span class=\"token number\">4</span>\n        <span class=\"token operator\">/</span>        \\\n       <span class=\"token number\">1</span>          <span class=\"token number\">1</span>   \n\nleft<span class=\"token operator\">:</span>   <span class=\"token number\">6</span> <span class=\"token number\">2</span> null <span class=\"token number\">4</span> <span class=\"token number\">1</span> null null\nright<span class=\"token operator\">:</span>  <span class=\"token number\">6</span> <span class=\"token number\">2</span> null <span class=\"token number\">4</span> <span class=\"token number\">1</span> null null</code></pre></div>\n<p>Now, if during traversal, at any point the two pointers do not point to the same data, we can return false. If the two pointers traverse their way back up to the root, then we have a symmetric tree.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">{</span>\n    T data<span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">*</span> left <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">*</span> right <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">bool</span> <span class=\"token function\">isSymmetric</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> left<span class=\"token punctuation\">,</span> Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>left <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>right<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>right<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>left <span class=\"token operator\">&amp;&amp;</span> right<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left<span class=\"token operator\">-></span>data <span class=\"token operator\">!=</span> right<span class=\"token operator\">-></span>data<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">bool</span> move1 <span class=\"token operator\">=</span> <span class=\"token function\">isSymmetric</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> right<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">bool</span> move2 <span class=\"token operator\">=</span> <span class=\"token function\">isSymmetric</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> right<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>move1 <span class=\"token operator\">&amp;&amp;</span> move2<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The running time of the code is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is the number of nodes in our tree. Space complexity is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span></span></span></span> is the height of our tree. This space complexity comes from our call stack. At most, we'd have to save <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span></span></span></span> recursive calls.</p>\n<h3 id=\"merge-two-trees\"><a href=\"#merge-two-trees\" aria-label=\"merge two trees permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Merge two trees</h3>\n<p><strong>Merge two trees, if both nodes present add sum. If one of them is null, only add the non-null node</strong></p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">tree1   tree2\n    <span class=\"token number\">1</span>   <span class=\"token number\">2</span>\n   <span class=\"token operator\">/</span>     \\\n  <span class=\"token number\">9</span>       <span class=\"token number\">4</span>  \n\nmerged<span class=\"token operator\">:</span>\n\n    <span class=\"token number\">3</span>\n  <span class=\"token operator\">/</span>   \\\n <span class=\"token number\">9</span>     <span class=\"token number\">4</span> </code></pre></div>\n<p>Approach 1: We can store nodes and their values (including null nodes) for each tree in their respective arrays. We can then iterate over the arrays and pick the non-null values and add ones that need to be added. Finally, we can construct a tree from our answer array and return. Not a good approach since it takes extra space.</p>\n<p>Better approach: Can we do it in place? How about we save the final result in <code class=\"language-cpptext\">t1</code> pointer that was passed to us. Let's step through the logic and see if we can:</p>\n<ul>\n<li>If both tree pointers are null, return null</li>\n<li>If t1 is null and t2 is not null, return t2</li>\n<li>If t1 is not null and t2 is null, return t1.</li>\n<li>\n<p>If both are not null, we need to do more work:</p>\n<ul>\n<li>Problem statement says add the values if both present</li>\n<li>Next, we need to repeat the steps above for current nodes' left and right subtrees.</li>\n</ul>\n</li>\n<li>Finally, return t1:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> <span class=\"token function\">mergeTrees</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> t1<span class=\"token punctuation\">,</span> Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>t1 <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>t2<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>t1 <span class=\"token operator\">&amp;&amp;</span> t2<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> t2<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t1 <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>t2<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> t1<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">//both present, sum the two:</span>\n    t1<span class=\"token operator\">-></span>data <span class=\"token operator\">+=</span> t2<span class=\"token operator\">-></span>data<span class=\"token punctuation\">;</span>\n    \n    t1<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> <span class=\"token function\">mergeTrees</span><span class=\"token punctuation\">(</span>t1<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> t2<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    t1<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> <span class=\"token function\">mergeTrees</span><span class=\"token punctuation\">(</span>t1<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> t2<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> t1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This approach uses no extra space (except for the recursive call stack). Running time: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is the max of the number of nodes in tree 1 and tree 2. And space complexity is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span> of the tree with the larger height.</p>\n<h3 id=\"invert-a-binary-tree\"><a href=\"#invert-a-binary-tree\" aria-label=\"invert a binary tree permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Invert a binary tree</h3>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">        <span class=\"token number\">1</span>           <span class=\"token number\">1</span>\n       <span class=\"token operator\">/</span> \\         <span class=\"token operator\">/</span> \\\n      <span class=\"token number\">2</span>   <span class=\"token number\">3</span>       <span class=\"token number\">3</span>   <span class=\"token number\">2</span>\n     <span class=\"token operator\">/</span> \\ <span class=\"token operator\">/</span> \\     <span class=\"token operator\">/</span> \\ <span class=\"token operator\">/</span> \\\n    <span class=\"token number\">4</span>  <span class=\"token number\">5</span> <span class=\"token number\">6</span>  <span class=\"token number\">7</span>   <span class=\"token number\">7</span>  <span class=\"token number\">6</span> <span class=\"token number\">5</span>  <span class=\"token number\">4</span> \n     </code></pre></div>\n<p>The idea here is to make a mirror image of the tree. Now as you go about swapping elements, you don't want to swap the parents until the children are done. You want to start at the bottom. To do so, what type of traversal would you use? The one that comes to mind that does the node AFTER the children is post-order (Left,right, node). So, here's what we'll do:</p>\n<ul>\n<li>Swap children of 4 (there aren't any so the null pointers stay where they are)</li>\n<li>Swap children of 5 (there aren't any so the null pointers stay where they are)</li>\n<li>Swap children of 2 : Swap 4 and 5.</li>\n<li>We're up to <code class=\"language-cpptext\">1</code> now BUT we're only done with its left subtree, we move to the right subtree</li>\n<li>Swap children of 6 and 7 (aren't any)</li>\n<li>Swap children of 3 : Swap 6 and 7</li>\n<li>Now swap children of 1 : swap 2 and 3</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> <span class=\"token function\">invert</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">invert</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">invert</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> temp <span class=\"token operator\">=</span> root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n    root<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">;</span>\n    root<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> root<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Running time is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> and space is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"are-they-cousins\"><a href=\"#are-they-cousins\" aria-label=\"are they cousins permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Are they cousins?</h3>\n<p><strong>In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.Two nodes of a binary tree are cousins if they have the same depth, but have different parents.We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.Return true if and only if the nodes corresponding to the values x and y are cousins.</strong></p>\n<p>Method signature:</p>\n<p>We need to satisfy two conditions: the depth of each node and the parent. Naive approach would be to first iterate through the tree, get the depths for each node and store in an external data structure such as a hash map. Then find the two nodes you're looking for and see if they satisfy the conditions for them to be considered cousins. This approach takes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> time and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> space.</p>\n<p>Better approach is to calculate the depth and the parent as we iterate over the nodes in our tree. We're only interested in the parent and depth of the node if its value matches that of the two nodes (x and y) we're looking for. So, we can use 4 global variables: </p>\n<ul>\n<li>x depth</li>\n<li>x parent</li>\n<li>y depth</li>\n<li>y parent</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> xp<span class=\"token punctuation\">;</span>\nNode<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> yp<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> xd<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> yd<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">,</span> Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> parent<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> depth<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>data <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        xp <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">;</span>\n        xd <span class=\"token operator\">=</span> depth<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>data <span class=\"token operator\">==</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        yp <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">;</span>\n        yd <span class=\"token operator\">=</span> depth<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    depth <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">,</span> depth<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">,</span> depth<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The code above shows that we start traversing the tree at the root. Our base condition would be when the root is null at which point we simply return. If the value we found is that of either x or y, we assign the parent and depth for our respective node and return. In other cases, we increment the depth and parent pointer and move to the left subtree and then the right subtree. </p>\n<p>Finally, we check if the conditions hold and return result accordingly.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">bool isCousins(Node&lt;int&gt;* rootundefined int xundefined int y) {\n    if (root-&gt;data == x || root-&gt;data == y)\n        return false;\n    process(rootundefined nullptrundefined 0undefined xundefined y);\n    return ((xp != yp) &amp;&amp; (xd == yd));\n    \n}</code></pre></div>\n<h3 id=\"lca\"><a href=\"#lca\" aria-label=\"lca permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LCA</h3>\n<p><strong>Find the least common ancestor for two given nodes.</strong></p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">LCA of <span class=\"token number\">6</span> <span class=\"token operator\">and</span> <span class=\"token number\">8</span> is <span class=\"token number\">11</span>\n            <span class=\"token number\">12</span>\n           <span class=\"token operator\">/</span>  \\\n         <span class=\"token number\">11</span>   <span class=\"token number\">10</span>\n        <span class=\"token operator\">/</span>  \\   \n       <span class=\"token number\">9</span>    <span class=\"token number\">8</span> \n      <span class=\"token operator\">/</span> \\    \\\n     <span class=\"token number\">7</span>  <span class=\"token number\">3</span>     <span class=\"token number\">1</span>\n    <span class=\"token operator\">/</span> \\ \n   <span class=\"token number\">6</span>   <span class=\"token number\">4</span></code></pre></div>\n<p>Naive approach would be to go through the tree and determine the path for each node that we're interested in and save the path in an external data structure. Once done, we can then compare the path to find the first node that is common in both paths. This requires extra space.</p>\n<p>Better approach would be to traverse the tree and if the current node is one of those that we're interested in, we can return true. As soon as we get to a node that has both the left and right returned values as true, we've found our ancestor. The trick here is to push up the tree what we found.</p>\n<p> So, in the example above, when 6 is found, it returns to 7 with the value <code class=\"language-cpptext\">true</code>. Therefore, <code class=\"language-cpptext\">7-&gt;left = true</code>. 7 checks its right and finds a false so 7 returns back to 9 as a true. Now, 9's left is true and its right is checked and a false is  returned. BUT, when 9 returns to 11, it returns a true. This means that 11's left is true. 11 then checks its right subtree to find that 8 is present. Then 11 sees that its left was also true so in this case, we've found our LCA. 11 is the first node that has a true return value from both its left and right subtrees. </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>data <span class=\"token operator\">==</span> x <span class=\"token operator\">||</span> root<span class=\"token operator\">-></span>data <span class=\"token operator\">==</span> y<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">auto</span> L <span class=\"token operator\">=</span> <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">auto</span> R <span class=\"token operator\">=</span> <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>L<span class=\"token operator\">&amp;&amp;</span>R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Found LCA! \"</span> <span class=\"token operator\">&lt;&lt;</span> root<span class=\"token operator\">-></span>data <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>L <span class=\"token operator\">||</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Running time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>, space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<h3 id=\"lca-with-parent\"><a href=\"#lca-with-parent\" aria-label=\"lca with parent permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LCA with parent</h3>\n<p><strong>Given a tree with parent pointers for each node, find the LCA for two given nodes</strong>.</p>\n<p>Naive approach: Chart the path all the way up to the root for the first node and save in an external data structure (such as a hash table). Then start at the second node and at each node in its path, check if the hash-table has this value. If so, return this node as the LCA. Otherwise, move node2 pointer up one level. This approach requires extra space.</p>\n<p>Better approach: Find the height for each node. If they're the same keep moving both in tandem up the tree until either nullpointer is encountered or both point to the same node. If the height for each node is not the same, move the one that is at a greater depth to the other node's depth and then move both pointers in tandem.</p>\n<h3 id=\"binary-sum-from-root-to-leaf\"><a href=\"#binary-sum-from-root-to-leaf\" aria-label=\"binary sum from root to leaf permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Binary sum from root to leaf</h3>\n<p><strong>Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.Return the sum of these numbers.</strong></p>\n<p>Brute force approach would be to take each path and store it as a string. Then once you have all the paths, convert each string to its integer representation and sum those values. This requires extra space and the string to int conversion might lead to overflow. </p>\n<p>A better approach would be to calculate the sum as we traverse the tree. This approach will make use of the fact that the paths to leaves share nodes. For example, for paths 1-1-0 and 1-1-1, the first two bits are shared so we don't need to get the values for that path again.</p>\n<p> We'll choose to traverse the tree in pre-order fashion since we need to capture the value of the current node first and then move to its left and right children. Also, as we've traversing, we need to keep track of the sum. To do so, we'll use this formula:</p>\n<ul>\n<li>OldValue * Base + ReadValue = NewValue</li>\n</ul>\n<p>Explanation can be found <a href=\"/primitive-types#converting-binary-to-decimal\">here</a>. Then, as soon as we reach a node that has no children, we can update a global sum variable with the current path's sum and return.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">getSum</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> curr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    curr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>curr <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> root<span class=\"token operator\">-></span>data<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token operator\">-></span>left <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        sum <span class=\"token operator\">+=</span> curr<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">getSum</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">getSum</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">sumRootToLeaf</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">getSum</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Running time is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> and space is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<h3 id=\"path-to-leaf-with-sum\"><a href=\"#path-to-leaf-with-sum\" aria-label=\"path to leaf with sum permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Path to leaf with sum</h3>\n<p><strong>Given a root to a tree, find the path that has sum equal to the given sum</strong></p>\n<p>This is a simple problem. All we need to do is traverse the tree and keep track of the path taken and the sum. When we reach a leaf node, we need to check the path's sum and see if it equals the passed value. If so, print the path, if not, continue.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> currw<span class=\"token punctuation\">,</span> string currPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"curr weight: \"</span> <span class=\"token operator\">&lt;&lt;</span> currw <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" and path so far: \"</span> <span class=\"token operator\">&lt;&lt;</span> currPath <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    currw <span class=\"token operator\">+=</span> root<span class=\"token operator\">-></span>data<span class=\"token punctuation\">;</span>\n    stringstream ss<span class=\"token punctuation\">;</span>\n    ss <span class=\"token operator\">&lt;&lt;</span> root<span class=\"token operator\">-></span>data<span class=\"token punctuation\">;</span>\n    string temp<span class=\"token punctuation\">;</span>\n    ss <span class=\"token operator\">>></span> temp<span class=\"token punctuation\">;</span>\n    currPath <span class=\"token operator\">+=</span> temp<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>currw <span class=\"token operator\">==</span> w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Found path: \"</span> <span class=\"token operator\">&lt;&lt;</span> currPath<span class=\"token punctuation\">;</span>\n        path <span class=\"token operator\">=</span> currPath<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span>currw<span class=\"token punctuation\">,</span>currPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> currw<span class=\"token punctuation\">,</span> currPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">sumPath</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"in-order-without-recursion\"><a href=\"#in-order-without-recursion\" aria-label=\"in order without recursion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>In-order without recursion</h3>\n<p><strong>Given root to a binary tree, save in-order traversal to a vector and return the vector. Do so, without using recursion.</strong></p>\n<p>The first thing that comes to mind is that we need to somehow replicate the call stack. To do so, we'll use the stack! In-order traversal is left, node and then right. So, we'll store the left subtree on a stack, then pop off the stack, push the element to answer vector and then process the right half.</p>\n<p> Start inside out: worry first about how you're going to process each node (that is the inside while call) and then take care of when to end (outside while call). We exit once we realize that the stack is empty:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> ans<span class=\"token punctuation\">;</span>\nstack<span class=\"token operator\">&lt;</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span><span class=\"token operator\">></span> s<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Inorder</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//Stack to keep track of elements</span>\n    stack<span class=\"token operator\">&lt;</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span><span class=\"token operator\">></span> s<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//Keep running until explicitly broken</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">//Keep adding left children to the stack</span>\n            s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            root <span class=\"token operator\">=</span> root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">//Remove from top of stack,</span>\n        root <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        s<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//move to right subtree and continue processing</span>\n        root <span class=\"token operator\">=</span> root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Running time: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> and space is also <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is the number of nodes in the tree.</p>\n<h3 id=\"pre-order-without-recursion\"><a href=\"#pre-order-without-recursion\" aria-label=\"pre order without recursion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pre-order without recursion</h3>\n<p><strong>Return a vector with a tree's nodes ordered in pre-order fashion without using recursion</strong></p>\n<p>Pre-order is node, left right. Again, move inside out. Concern yourself first with how you'd move in the tree. Ok, so you're at the root of say this tree:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">            <span class=\"token number\">12</span>\n           <span class=\"token operator\">/</span>  \\\n         <span class=\"token number\">11</span>   <span class=\"token number\">10</span>\n        <span class=\"token operator\">/</span>  \\   \n       <span class=\"token number\">9</span>    <span class=\"token number\">8</span> \n      <span class=\"token operator\">/</span> \\    \\\n     <span class=\"token number\">7</span>  <span class=\"token number\">3</span>     <span class=\"token number\">1</span>\n    <span class=\"token operator\">/</span> \\ \n   <span class=\"token number\">6</span>   <span class=\"token number\">4</span></code></pre></div>\n<p>So if you're at 12, you can again keep moving left until there are no more nodes to process. This time, what are you going to save on the stack? You must save the right child of the current node. That is because by moving down left node by node, you're already processing the node and the left subtree. All that is left to process are the right subtrees as we encounter them. We do so by saving those right subtree nodes on the stack.</p>\n<p>We continue processing until the stack is empty:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">PreOrder</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    stack<span class=\"token operator\">&lt;</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span><span class=\"token operator\">></span> s<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span>\n                s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            root <span class=\"token operator\">=</span> root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        \n        root <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        s<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"find-in-order-successor\"><a href=\"#find-in-order-successor\" aria-label=\"find in order successor permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Find in-order successor</h3>\n<p><strong>The successor of a node in a binary tree is the node that appears immediately after the given node in an inorder traversal. Design an algorithm that computes the successor of a node in a binary tree. Assume that each node stores its parent.</strong></p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Inorder <span class=\"token punctuation\">(</span>LNR<span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> tree below<span class=\"token operator\">:</span>\n\n<span class=\"token number\">6</span> <span class=\"token number\">7</span> <span class=\"token number\">4</span> <span class=\"token number\">9</span> <span class=\"token number\">3</span> <span class=\"token number\">11</span> <span class=\"token number\">8</span> <span class=\"token number\">2</span> <span class=\"token number\">1</span> <span class=\"token number\">12</span> <span class=\"token number\">10</span>\n\n            <span class=\"token number\">12</span>\n           <span class=\"token operator\">/</span>  \\\n         <span class=\"token number\">11</span>   <span class=\"token number\">10</span>\n        <span class=\"token operator\">/</span>  \\   \n       <span class=\"token number\">9</span>    <span class=\"token number\">8</span> \n      <span class=\"token operator\">/</span> \\    \\\n     <span class=\"token number\">7</span>  <span class=\"token number\">3</span>     <span class=\"token number\">1</span>\n    <span class=\"token operator\">/</span> \\      <span class=\"token operator\">/</span>\n   <span class=\"token number\">6</span>   <span class=\"token number\">4</span>    <span class=\"token number\">2</span></code></pre></div>\n<p>The naive approach would be to ignore that there's a parent pointer and keep traversing in in-order fashion and when you get to the node you were interested in, you'd record the next node and return. However, this requires <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> time. </p>\n<p>A better approach is to break this down into possible combinations and then figure out the successor. Here are the possible scenarios:</p>\n<ol>\n<li>The node is a leaf, it has no left or right children. This can have 2 cases:\na. The leaf is a left-child: in this case the successor is the parent. Example: node 6\nb. The leaf is a right-child: in this case the successor is the parent after we move up from a left child. Example: node 3. Move to node 3's parent 9. Does 9 have a parent? Yes: 11. Is 9 the left child of 11? Yes. Then the successor to 3 is 11.</li>\n<li>The node is not a leaf and has right child: Move to the right-subtree and find the node that has no left children, that node is the successor. Example: 11. </li>\n<li>The node is not a leaf and has no right child: Similar to 1b. Example: node 1, parent is 12. </li>\n</ol>\n<p>From the logic above, the code is pretty self explanatory. I've pulled out case 1b into its separate function for reuse in case 3:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> <span class=\"token function\">leftUpToParent</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> parent <span class=\"token operator\">=</span> node<span class=\"token operator\">-></span>parent<span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> successor <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n    node <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">;</span>\n    parent <span class=\"token operator\">=</span> parent<span class=\"token operator\">-></span>parent<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>parent<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            successor <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent<span class=\"token operator\">-></span>left <span class=\"token operator\">==</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            successor <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            node <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">;</span>\n            parent <span class=\"token operator\">=</span> parent<span class=\"token operator\">-></span>parent<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> successor<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nNode<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> <span class=\"token function\">getInOrderSuccessor</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> parent <span class=\"token operator\">=</span> node<span class=\"token operator\">-></span>parent<span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> successor <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>parent<span class=\"token punctuation\">)</span>\n        successor <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>node<span class=\"token operator\">-></span>left <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>node<span class=\"token operator\">-></span>right <span class=\"token operator\">&amp;&amp;</span> parent<span class=\"token operator\">-></span>left <span class=\"token operator\">==</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//Is leaf and left child of parent</span>\n        successor <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>node<span class=\"token operator\">-></span>left <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>node<span class=\"token operator\">-></span>right <span class=\"token operator\">&amp;&amp;</span> parent<span class=\"token operator\">-></span>right <span class=\"token operator\">==</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//Is leaf and right child of parent</span>\n        successor <span class=\"token operator\">=</span> <span class=\"token function\">leftUpToParent</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//Node is not leaf and has a right subtree</span>\n        node <span class=\"token operator\">=</span> node<span class=\"token operator\">-></span>right<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span>\n            node <span class=\"token operator\">=</span> node<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n        successor <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//Node not leaf and has no righ child</span>\n        successor <span class=\"token operator\">=</span> <span class=\"token function\">leftUpToParent</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> successor<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Running time is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span> because at worst, we'd get a case where we're one level above leaf and the successor is the root. Space complexity is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"form-list-from-leaves\"><a href=\"#form-list-from-leaves\" aria-label=\"form list from leaves permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Form list from leaves</h3>\n<p><strong>Form a list from the leaves of a tree in left to right fashion</strong></p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">            <span class=\"token number\">12</span>\n           <span class=\"token operator\">/</span>  \\\n         <span class=\"token number\">11</span>   <span class=\"token number\">10</span>\n        <span class=\"token operator\">/</span>  \\   \n       <span class=\"token number\">9</span>    <span class=\"token number\">8</span> \n      <span class=\"token operator\">/</span> \\    \\\n     <span class=\"token number\">7</span>  <span class=\"token number\">3</span>     <span class=\"token number\">1</span>\n    <span class=\"token operator\">/</span> \\      <span class=\"token operator\">/</span>\n   <span class=\"token number\">6</span>   <span class=\"token number\">4</span>    <span class=\"token number\">2</span>\n\nShould <span class=\"token keyword\">return</span><span class=\"token operator\">:</span> <span class=\"token number\">6</span> <span class=\"token number\">4</span> <span class=\"token number\">3</span> <span class=\"token number\">2</span> <span class=\"token number\">10</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">vector<span class=\"token operator\">&lt;</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span><span class=\"token operator\">></span> allLeaves<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">generateList</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token operator\">-></span>left <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Adding: \"</span> <span class=\"token operator\">&lt;&lt;</span> root<span class=\"token operator\">-></span>data <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        allLeaves<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">generateList</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">generateList</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Running time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>, space, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span> + <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(l)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span></span></span></span> is the number of leaves. </p>\n<h3 id=\"vertical-order-traversal\"><a href=\"#vertical-order-traversal\" aria-label=\"vertical order traversal permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Vertical Order Traversal</h3>\n<p><strong>Given a tree, return vertical order traversal for the tree</strong>.</p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">            <span class=\"token number\">3</span>\n          <span class=\"token operator\">/</span>   \\\n        <span class=\"token number\">9</span>     <span class=\"token number\">20</span>\n             <span class=\"token operator\">/</span>  \\           \n            <span class=\"token number\">15</span>  <span class=\"token number\">7</span></code></pre></div>\n<p>If you go from left to right, you can see that 9 is by itself vertically. Nodes 3 and 15 align vertically and finally 20 and 7 are by themselves:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Input<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span>null<span class=\"token punctuation\">,</span>null<span class=\"token punctuation\">,</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span>\nOutput<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">15</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>It is clear that we need to traverse the tree in some order and keep track of the position relative to the root. Let's start with this step. How do we keep track of how far to the right or the left a node is with respect to the root? We can assign integers to each position. How do we go about deciding which integer gets assigned where. An insight that we can derive is that if we go left, we can perform one arithmetic operation and if we go right we can perform a complementary operation. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">    <span class=\"token number\">0</span>   \n     \\\n      <span class=\"token number\">1</span>\n     <span class=\"token operator\">/</span>\n    <span class=\"token number\">0</span>    </code></pre></div>\n<p>Notice how the two nodes that align have the same value! We got that by adding 1 if we go to the right child and subtracting one if we go to the left child. Let's label our tree and see if this scheme works (the labels are in parenthesis):</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">            <span class=\"token number\">3</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n          <span class=\"token operator\">/</span>   \\\n    <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token number\">9</span>    <span class=\"token number\">20</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n             <span class=\"token operator\">/</span>  \\           \n        <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">15</span>  <span class=\"token number\">7</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Notice how 3 and 15 have the same label, while all other labels are different. </p>\n<p>Let's look at the piece of code that assigns labels to each node and stores this information in a multi-map (multi-map because multiple nodes can have the same label):</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">verticalOrderTraversal</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">,</span> multimap<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> info<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Pushing to map: \"</span> <span class=\"token operator\">&lt;&lt;</span> pos <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" -> \"</span> <span class=\"token operator\">&lt;&lt;</span> root<span class=\"token operator\">-></span>val <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    info<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>pos<span class=\"token punctuation\">,</span>root<span class=\"token operator\">-></span>val<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">verticalOrderTraversal</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> pos<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">verticalOrderTraversal</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> pos<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Once completed, our multi-map (which is in sorted order) will look like this for the tree above:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Pushing to map<span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token operator\">-></span> <span class=\"token number\">3</span>\nPushing to map<span class=\"token operator\">:</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">-></span> <span class=\"token number\">9</span>\nPushing to map<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token operator\">-></span> <span class=\"token number\">20</span>\nPushing to map<span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token operator\">-></span> <span class=\"token number\">15</span>\nPushing to map<span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token operator\">-></span> <span class=\"token number\">7</span></code></pre></div>\n<p>Finally, we populate our vector of vectors to return vertical order traversal information:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> <span class=\"token function\">verticalOrderTraversal</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> ans<span class=\"token punctuation\">;</span>\n    multimap<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> info<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">verticalOrderTraversal</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    multimap<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator itr <span class=\"token operator\">=</span> info<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> prev <span class=\"token operator\">=</span> numeric_limits<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>itr <span class=\"token operator\">!=</span> info<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> curr<span class=\"token punctuation\">;</span>\n        curr<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>itr<span class=\"token operator\">-></span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        prev <span class=\"token operator\">=</span> itr<span class=\"token operator\">-></span>first<span class=\"token punctuation\">;</span>\n        itr<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>itr<span class=\"token operator\">-></span>first <span class=\"token operator\">==</span> prev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            curr<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>itr<span class=\"token operator\">-></span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            itr<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"remove-leaf-nodes-with-given-value\"><a href=\"#remove-leaf-nodes-with-given-value\" aria-label=\"remove leaf nodes with given value permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Remove leaf nodes with given value</h3>\n<p><strong>Given a binary tree root and an integer target, delete all the leaf nodes with value target. Note that once you delete a leaf node with value target, if it's parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you can't).</strong></p>\n<p>This is an interesting problem. We're to keep deleting nodes until leaf nodes do not have target value. Here, we'll use a recursive approach. We'll keep recursing until we get to a leaf node and find that the leaf node has target value. If so, we'll delete it and return null. In the process, we'll automatically update inner nodes' left and right children and then check again to see if the newly created leaf nodes have target value. </p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">        <span class=\"token number\">1</span>\n     <span class=\"token operator\">/</span>     \\\n   <span class=\"token number\">3</span>       <span class=\"token number\">4</span> \n  <span class=\"token operator\">/</span>      <span class=\"token operator\">/</span>  \\   \n <span class=\"token number\">4</span>     <span class=\"token number\">3</span>    <span class=\"token number\">3</span> <span class=\"token operator\">--</span><span class=\"token operator\">></span> Interesting node\n           <span class=\"token operator\">/</span>\n          <span class=\"token number\">3</span> <span class=\"token operator\">--</span><span class=\"token operator\">></span> Child node</code></pre></div>\n<p>Say we're at the child node and find that it's a leaf (by checking if child->left and child->right is null). If so, we make child node null and return. At this point, our tree looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">        <span class=\"token number\">1</span>\n     <span class=\"token operator\">/</span>     \\\n   <span class=\"token number\">3</span>       <span class=\"token number\">4</span> \n  <span class=\"token operator\">/</span>      <span class=\"token operator\">/</span>  \\   \n <span class=\"token number\">4</span>     <span class=\"token number\">3</span>    <span class=\"token number\">3</span> <span class=\"token operator\">--</span><span class=\"token operator\">></span> Interesting node\n           <span class=\"token operator\">/</span>\n         <span class=\"token constant\">NULL</span> <span class=\"token operator\">--</span><span class=\"token operator\">></span> Child node</code></pre></div>\n<p>Now, once we return back to interesting node, we find that the interesting node has both children as null and has the target value as well, so we make interesting node null and return:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">        <span class=\"token number\">1</span>\n     <span class=\"token operator\">/</span>     \\\n   <span class=\"token number\">3</span>       <span class=\"token number\">4</span> \n  <span class=\"token operator\">/</span>      <span class=\"token operator\">/</span>  \\   \n <span class=\"token number\">4</span>     <span class=\"token number\">3</span>    <span class=\"token constant\">NULL</span> <span class=\"token operator\">--</span><span class=\"token operator\">></span> Interesting node\n           <span class=\"token operator\">/</span>\n         <span class=\"token constant\">NULL</span> <span class=\"token operator\">--</span><span class=\"token operator\">></span> Child node</code></pre></div>\n<p>Using this approach, we'll recursively make inner nodes null if they match target.</p>\n<p>Here's the code for this logic:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">TreeNode<span class=\"token operator\">*</span> <span class=\"token function\">removeLeafNodes</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n    root<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> <span class=\"token function\">removeLeafNodes</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    root<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> <span class=\"token function\">removeLeafNodes</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token operator\">-></span>left <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>root<span class=\"token operator\">-></span>right <span class=\"token operator\">&amp;&amp;</span> root<span class=\"token operator\">-></span>val <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> root<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"diameter-of-a-tree\"><a href=\"#diameter-of-a-tree\" aria-label=\"diameter of a tree permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Diameter of a tree</h3>\n<p><strong>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</strong></p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">      <span class=\"token number\">1</span>\n    <span class=\"token operator\">/</span>   \\\n  <span class=\"token number\">4</span>     <span class=\"token number\">11</span> \n <span class=\"token operator\">/</span> \\     \\\n<span class=\"token number\">13</span>  <span class=\"token number\">20</span>    <span class=\"token number\">7</span>\n   <span class=\"token operator\">/</span>\n  <span class=\"token number\">21</span></code></pre></div>\n<p>If we have the tree above, our diameter would comprise of the following nodes: 21-2-4-1-11-7 for a length of 5. In order to determine the diameter, what information do we need to store for each node? According to the definition, diameter is the length of the longest path, so for each node we need to keep track of longest path encountered in left subtree and right subtree. When we're returning from a node, we'll then return the max of the two lengths. During the process, we'll also keep track of the longest length encountered so far in a passed-by-reference variable:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">diameterOfBinaryTreeHelper</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> maxLen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token function\">diameterOfBinaryTreeHelper</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> maxLen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> <span class=\"token function\">diameterOfBinaryTreeHelper</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> maxLen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">+</span> right <span class=\"token operator\">></span> maxLen<span class=\"token punctuation\">)</span>\n        maxLen <span class=\"token operator\">=</span> left<span class=\"token operator\">+</span>right<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">diameterOfBinaryTree</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> maxLen <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">diameterOfBinaryTreeHelper</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> maxLen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> maxLen<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We'll start with calling <code class=\"language-cpptext\">diameterOfBinaryTree()</code> that initializes our reference variable <code class=\"language-cpptext\">maxLen</code> to 0. It then calls the helper function that performs the steps that we discussed earlier. Running time: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is the number of nodes and space complexity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span></span></span></span> is the height of the tree.</p>\n<h3 id=\"level-order-traversal\"><a href=\"#level-order-traversal\" aria-label=\"level order traversal permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Level order traversal</h3>\n<p><strong>[Problem]:(<a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/\">https://leetcode.com/problems/binary-tree-level-order-traversal/</a>) Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).</strong></p>\n<p>Example: </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">    <span class=\"token number\">3</span>\n   <span class=\"token operator\">/</span> \\\n  <span class=\"token number\">9</span>  <span class=\"token number\">20</span>\n    <span class=\"token operator\">/</span>  \\\n   <span class=\"token number\">15</span>   <span class=\"token number\">7</span></code></pre></div>\n<p>Would return:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">[</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Ok, so we're to start at the root and keep track of the nodes at each level. We must then add all nodes at this level to the final answer. In order to keep track of the level info, we need to pass level number down from parent to child nodes. For example, <code class=\"language-cpptext\">3</code>'s level is 0, and when we go to process <code class=\"language-cpptext\">9</code> and <code class=\"language-cpptext\">20</code>, we'll pass level as <code class=\"language-cpptext\">root + 1</code>. </p>\n<p>Can we use one of our conventional order traversal to solve this? Let's see: we want to process the node first and then its left and right children. That is because we'll have to process the current node's level and transfer that information to the child nodes. It sounds like node, then left, then right. That is nothing but pre-order traversal! That takes care of the levels. At the end of this piece of logic, we'll have the information for each node and its level. Next, all we need to do is push each node and its level to a vector and push that vector to the final answer.</p>\n<p>What is the best way to store our levels so that we have it in sorted order AND can iterate over it quickly? A map! A map uses balanced tree behind the scenes so it'll take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logN)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> for each lookup. Here's this logic converted to code:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">levelOrderHelper</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> level<span class=\"token punctuation\">,</span> map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">&amp;</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//Process current node by pushing</span>\n    <span class=\"token comment\">//current level and node to the map</span>\n    m<span class=\"token punctuation\">[</span>level<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//Pass current level + 1 to left</span>\n    <span class=\"token comment\">//and right children</span>\n    <span class=\"token function\">levelOrderHelper</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> level<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">levelOrderHelper</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> level<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nvector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> <span class=\"token function\">levelOrder</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> m<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">levelOrderHelper</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//populate the final vector:</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i<span class=\"token operator\">:</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We can also use BFS to get level order traversal. For this section we'll use the problem where we need to return level order in a vector of vectors BUT from bottom up. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">    <span class=\"token number\">3</span>\n   <span class=\"token operator\">/</span> \\\n  <span class=\"token number\">9</span>  <span class=\"token number\">20</span>\n    <span class=\"token operator\">/</span>  \\\n   <span class=\"token number\">15</span>   <span class=\"token number\">7</span></code></pre></div>\n<p>should return:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">[</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>In this approach, we push each node to a queue. Why queue? Because we need to process the nodes as we encounter them since the problem wants us to return nodes close together in the same vector. Ok, so we'll start with root: </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">queue<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\nvector<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\ndeque<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Now what? We'll process <code class=\"language-cpptext\">3</code> by saving to a deque (double ended queue) of vectors where each vector is a collection of nodes on that level in left to right order (since the question asks for that order). This will help us save time when we need to return at the end in reverse order. We'll save time by placing elements correctly as we process them by using deque's <code class=\"language-cpptext\">push_front()</code> call.</p>\n<p>Ok, so we have <code class=\"language-cpptext\">3</code> in the queue, we keep iterating until the current queue is empty (ie 1 iteration). On each iteration we'll push the value to our vector:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">queue<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nvector<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">3</span><span class=\"token operator\">></span>\ndeque<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Since we have no more elements in the queue, we can push_front the vector to our deque:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">queue<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nvector<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">3</span><span class=\"token operator\">></span>\ndeque<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span><span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Before we move on, we'll also push 3's left and right child to the queue:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">queue<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span>\nvector<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">3</span><span class=\"token operator\">></span>\ndeque<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span><span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>At the end of this iteration, we'll have the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">queue<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span>\nvector<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token operator\">></span>\ndeque<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span><span class=\"token operator\">&lt;</span><span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Notice how 9,20 is at the front. We'll continue building our deque and at the end we'll just copy over vectors from deque to our vector of vectors and return. The key insight here is that we empty the queue on each level so that we know the correct number of nodes on each level. Here's the logic for this code:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> ans<span class=\"token punctuation\">;</span>\n    deque<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> deck<span class=\"token punctuation\">;</span>\n    queue<span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">*</span><span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> levelVals<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            TreeNode<span class=\"token operator\">*</span> curr <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            q<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>curr<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>curr<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            \n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>curr<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>curr<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            levelVals<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>curr<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            size<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        deck<span class=\"token punctuation\">.</span><span class=\"token function\">push_front</span><span class=\"token punctuation\">(</span>levelVals<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> deck<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>deck<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-cpptext\">size</code> keeps track of current level nodes while we continue to push elements to the queue!</p>\n<h3 id=\"conclusion\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h3>\n<ul>\n<li>Best solutions have running time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> and space complexity as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">h</span><span class=\"mclose\">)</span></span></span></span> (when using recursion).</li>\n<li>If you're required to keep track of more than one condition (such the height at that node and if it is balanced), consider returning a struct instead of just height or just a boolean (for isBalanced) to encapsulate both pieces of information as shown <a href=\"/binary-tree-problems#check-if-balanced\">here</a></li>\n<li>Always start at the base case when working with trees. For example, what do we do when the node is null? Next, handle the case where the node has no more children. Next choose a middle node and decide what to return based on the problem you're trying to solve, then finally add the missing steps. </li>\n<li>Whenever you recurse and go down a subtree, make sure you capture the result and return if there's a return condition that needs to hold. That way you prevent yourself from going through the entire tree when the first subtree already breaks the condition you're trying to check for.</li>\n<li>If you need to transmit some information to parent from child, return a value AFTER you've processed everything in the recursive call. Look at <a href=\"#lca\">lca</a> for an example. Notice how we return L if L is not null and R if R is not null, otherwise we return nullptr.</li>\n</ul>","timeToRead":32,"excerpt":"Table of Contents Intro Problems Traversal Find height Check if balanced Check if tree is symmetric Merge two trees Invert a binary tree Are","frontmatter":{"title":"Binary Trees","date":"2020-01-27T00:00:00.000Z","categories":["Data Structures"],"extract":"Binary tree data structure","thumbnail":"/post-images/tree.png","tags":["Binary Tree","Data Structures"]},"fields":{"slug":"/binary-trees","date":"January 27, 2020"}}},"pageContext":{"slug":"/binary-trees","nexttitle":"Binary Search Trees","nextslug":"/binary-search-trees","prevtitle":"Hash Tables","prevslug":"/hash-tables"}}}