{"componentChunkName":"component---src-templates-post-js","path":"/string-problems","result":{"data":{"markdownRemark":{"html":"<ol>\n<li><a href=\"#all-anagrams\">All Anagrams</a></li>\n<li><a href=\"#group-anagrams\">Group Anagrams</a></li>\n<li><a href=\"\">Word Break</a></li>\n</ol>\n<h3 id=\"all-anagrams\"><a href=\"#all-anagrams\" aria-label=\"all anagrams permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>All Anagrams</h3>\n<p><a href=\"https://leetcode.com/problems/find-all-anagrams-in-a-string/\">All anagrams</a>\n<strong>Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter.</strong></p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Input<span class=\"token operator\">:</span>\ns<span class=\"token operator\">:</span> <span class=\"token string\">\"cbaebabacd\"</span> p<span class=\"token operator\">:</span> <span class=\"token string\">\"abc\"</span>\n\nOutput<span class=\"token operator\">:</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>A naive approach would be to somehow keep track of number of characters in the pattern and start iterating over the text. On each iteration, keep a \"window\" size equal to the length of the pattern. Next, check to see if the frequency of characters in the text equal that of pattern. If so, store the starting index of this window in our answer vector.</p>\n<p>A better approach would be to realize that an anagram is nothing but a rearrangement of characters in a string so the only requirement for 2 strings to be an anagram is that they both must have the same number and frequency of characters:</p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token string\">\"abc\"</span> <span class=\"token operator\">and</span> <span class=\"token string\">\"cba\"</span> are anagarams\n<span class=\"token string\">\"abc\"</span> <span class=\"token operator\">and</span> <span class=\"token string\">\"abd\"</span> are <span class=\"token operator\">not</span></code></pre></div>\n<p>So, what we can do is this:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">pattern<span class=\"token operator\">:</span> a   b   c\nmake an unordered_map <span class=\"token keyword\">using</span> the pattern\n\ntext<span class=\"token operator\">:</span> c   b   a   e   b   a   b   a   c   d\ncheck the first <span class=\"token number\">3</span> characters <span class=\"token operator\">and</span> make an unordered_map from these first <span class=\"token number\">3</span> chars<span class=\"token punctuation\">.</span>\n\ncompare the map with that of the pattern <span class=\"token keyword\">using</span> the <span class=\"token operator\">==</span> <span class=\"token keyword\">operator</span>\nIf they<span class=\"token number\">'</span>re the same<span class=\"token punctuation\">,</span> store the index in answer vector  \n\nTo move along the text string<span class=\"token punctuation\">,</span> decrement count of previous character from map\n<span class=\"token operator\">and</span> add <span class=\"token keyword\">new</span> character to map<span class=\"token punctuation\">.</span> If previous character count decreases to <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> remove\nit from the map<span class=\"token punctuation\">.</span></code></pre></div>\n<p>This approach takes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> time. Here's this logic converted to code:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">findAnagrams</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">,</span> string p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> ans<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n\n        unordered_map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> txtMap<span class=\"token punctuation\">,</span> patMap<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            txtMap<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            patMap<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>patMap <span class=\"token operator\">==</span> txtMap<span class=\"token punctuation\">)</span>\n            ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">//Decrement removed char from map</span>\n            txtMap<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//If count went down to 0,</span>\n            <span class=\"token comment\">//erase from map</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>txtMap<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                txtMap<span class=\"token punctuation\">.</span><span class=\"token function\">erase</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            txtMap<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>txtMap <span class=\"token operator\">==</span> patMap<span class=\"token punctuation\">)</span>\n                ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"group-anagrams\"><a href=\"#group-anagrams\" aria-label=\"group anagrams permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Group Anagrams</h3>\n<p><a href=\"https://leetcode.com/problems/group-anagrams/\">Group Anagrams</a></p>\n<p><strong>Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</strong></p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Input<span class=\"token operator\">:</span> strs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"eat\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"tea\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"tan\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"ate\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"nat\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"bat\"</span><span class=\"token punctuation\">]</span>\nOutput<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"bat\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"nat\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"tan\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"ate\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"eat\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"tea\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Naive approach is to start with the first string in the input, <code class=\"language-cpptext\">eat</code> and get the frequency of all characters in it. Push this string to a new vector and iterate over remaining input strings to see if any other strings have the same character count. If so, add this new string to the vector. Repeat until done with all strings. This approach takes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> time to calculate character count for a single string and then iterate over all other strings. This comes out to exponential running time. </p>\n<p>Better approach is again to eliminate the need to repeatedly iterate over all the strings. To do so, we need a hash function that'll return a particular string for each anagram. The best hash function for the job would be one that returns the string in sorted order. For example, if we pass <code class=\"language-cpptext\">eat</code> and <code class=\"language-cpptext\">tea</code> to our hash function, we'll get back <code class=\"language-cpptext\">aet</code>. Next, we'll store this sorted string as a key in our hash table and for the value we'll have each string that gets returned from the hash function. For example, given, <code class=\"language-cpptext\">eat</code>, <code class=\"language-cpptext\">tea</code> and <code class=\"language-cpptext\">nat</code>, our hash table would look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">aet <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>eat<span class=\"token punctuation\">,</span> tea<span class=\"token punctuation\">}</span>\nant <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>nat<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Once we have this hash table constructed, all we need to do is grab the values and return our vector of vectors. </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">    vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">groupAnagrams</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> strs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> ans<span class=\"token punctuation\">;</span>\n        unordered_map<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> hashMap<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> strs<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            string curr <span class=\"token operator\">=</span> strs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            string temp <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            hashMap<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> vec <span class=\"token operator\">:</span> hashMap<span class=\"token punctuation\">)</span>\n            ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>vec<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"word-break\"><a href=\"#word-break\" aria-label=\"word break permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Word Break</h3>\n<p><a href=\"https://leetcode.com/problems/word-break/\">Word Break</a></p>\n<p><strong>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</strong></p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Input<span class=\"token operator\">:</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"leetcode\"</span><span class=\"token punctuation\">,</span> wordDict <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"leet\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"code\"</span><span class=\"token punctuation\">]</span>\nOutput<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\nExplanation<span class=\"token operator\">:</span> Return <span class=\"token boolean\">true</span> because <span class=\"token string\">\"leetcode\"</span> can be segmented as <span class=\"token string\">\"leet code\"</span><span class=\"token punctuation\">.</span>\n\nInput<span class=\"token operator\">:</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"catsandog\"</span><span class=\"token punctuation\">,</span> wordDict <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"cats\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"dog\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"sand\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"and\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cat\"</span><span class=\"token punctuation\">]</span>\nOutput<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span></code></pre></div>\n<p>This is quite an interesting problem! Let's see how we can tackle it. Say we're using the 2nd example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Input<span class=\"token operator\">:</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"catsandog\"</span><span class=\"token punctuation\">,</span> wordDict <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"cats\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"dog\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"sand\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"and\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cat\"</span><span class=\"token punctuation\">]</span>\nOutput<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span></code></pre></div>\n<p>So, for our input string, <code class=\"language-cpptext\">catsanddog</code>, we want to see if there's a substring that is found in the word dict. The idea is to note that yes we can make <code class=\"language-cpptext\">cat</code> and <code class=\"language-cpptext\">sand</code> but not <code class=\"language-cpptext\">og</code> from the dict no matter how we break the string. We could've also broken the string by seeing that we can make <code class=\"language-cpptext\">cats</code> and <code class=\"language-cpptext\">and</code> but again are left with <code class=\"language-cpptext\">og</code>. </p>\n<p> At the end of our algorithm, we'll return true if the last substring can also be formed from the dictionary, if not, we'll return false. To keep track of whether it's possible to break the string or not, we'll use an aux array, called <code class=\"language-cpptext\">breakable</code> where each index will determine whether the word ending at that index is breakable or not. If we get to an index that is indeed breakable, we'll check the dictionary to see if we can find another word from it that would allow us to break our string further. </p>\n<p>The size of this aux array will be 1 + size of <code class=\"language-cpptext\">s</code>. That's because our 0th index will always be true since an empty string is always breakable! </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Initially<span class=\"token punctuation\">,</span> aux array is all <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> except aux<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n            _   c   a   t   s   a   n   d   o   g\naux arr<span class=\"token operator\">:</span>    <span class=\"token number\">1</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span></code></pre></div>\n<p>Now, we'll start at index 1 of aux array and check whether the prev index is true. This will always be the case since we've set aux[0] to true. Now, since the word ending at one prev index IS breakable (represented by 1 in aux array), we'll see if we can break the current word by comparing it one by one against the elements in the dict.</p>\n<p>To make the comparison, we'll pull a word from the dict, get its length and compare it against the same number of characters in the string:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">curr dict word<span class=\"token operator\">:</span> cats\n                _____________\n            _   c   a   t   s   a   n   d   o   g\naux arr<span class=\"token operator\">:</span>    <span class=\"token number\">1</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>\n                            <span class=\"token operator\">|</span>\n                        end position\n\ndict word <span class=\"token operator\">==</span> <span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nPut <span class=\"token number\">1</span> at end position</code></pre></div>\n<p>Since the words match, our updated aux array will look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">curr dict word<span class=\"token operator\">:</span> cats\n                _____________\n            _   c   a   t   s   a   n   d   o   g\naux arr<span class=\"token operator\">:</span>    <span class=\"token number\">1</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">1</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>\n                            <span class=\"token operator\">|</span>\n                        end position\n\ndict word <span class=\"token operator\">==</span> <span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nPut <span class=\"token number\">1</span> at end position</code></pre></div>\n<p>Next, we continue looping until we are at an index where we found that the word was breakable:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">                               curr \n                                <span class=\"token operator\">|</span>\n            _   c   a   t   s   a   n   d   o   g\naux arr<span class=\"token operator\">:</span>    <span class=\"token number\">1</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">1</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span></code></pre></div>\n<p>Now, we'll again iterate over the word dict to see if any of the words match:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">curr dict word<span class=\"token operator\">:</span> <span class=\"token operator\">and</span>\n                                _________\n            _   c   a   t   s   a   n   d   o   g\naux arr<span class=\"token operator\">:</span>    <span class=\"token number\">1</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">1</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>   <span class=\"token number\">1</span>   <span class=\"token number\">0</span>   <span class=\"token number\">0</span>\n\ndict word <span class=\"token operator\">==</span> <span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nPut <span class=\"token number\">1</span> at end position</code></pre></div>\n<p>Finally, in the final iteration we find that there's no <code class=\"language-cpptext\">og</code> in the dictionary. So, at the end we return <code class=\"language-cpptext\">breakable[s.length()]</code>. </p>\n<p>Here's the code for this logic:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber 0\" class=\"language-cppcpp line-numbers\"><code class=\"language-cppcpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">wordBreak</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> wordDict<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span> breakable <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    breakable<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> breakable<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>breakable<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> word <span class=\"token operator\">:</span> wordDict<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                string currWord <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>word<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>currWord <span class=\"token operator\">==</span> word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    breakable<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">+</span>word<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> breakable<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>One quick note: we don't break out of the <code class=\"language-cpptext\">if</code> on line 8 as soon as we get a match because maybe the first word does match but if we go with that first we don't get all the way to the end.</p>\n<p>Running time:</p>\n<ul>\n<li>Iterate over the array: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> size of the input string</li>\n<li>Iterate over wordDict: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>D</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(D)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">)</span></span></span></span> size of dict</li>\n</ul>\n<p>Running time: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mi>D</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(SD)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">)</span></span></span></span> </p>","timeToRead":7,"excerpt":"All Anagrams Group Anagrams Word Break All Anagrams All anagrams\nGiven a string s and a non-empty string p, find all the start indices of p…","frontmatter":{"title":"String Problems","date":"2020-10-12T00:00:00.000Z","categories":["Strings"],"extract":"A look at some interesting string problems","thumbnail":"/post-images/string_problems.png","tags":["Data Structures"]},"fields":{"slug":"/string-problems","date":"October 12, 2020"}}},"pageContext":{"slug":"/string-problems","nexttitle":"Greedy Algorithms","nextslug":"/greedy-algorithms","prevtitle":"C++ Standard input","prevslug":"/c-standard-input"}}}