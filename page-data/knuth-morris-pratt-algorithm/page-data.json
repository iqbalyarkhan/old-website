{"componentChunkName":"component---src-templates-post-js","path":"/knuth-morris-pratt-algorithm","result":{"data":{"markdownRemark":{"html":"<h3 id=\"table-of-contents\"><a href=\"#table-of-contents\" aria-label=\"table of contents permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Table of Contents</h3>\n<ol>\n<li><a href=\"#introduction\">Introduction</a></li>\n<li><a href=\"#prefix-array\">Prefix Array</a></li>\n<li><a href=\"#logic\">Logic</a></li>\n<li><a href=\"#code\">Code</a></li>\n<li><a href=\"#analysis\">Analysis</a></li>\n</ol>\n<h3 id=\"introduction\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h3>\n<p>We've looked at why the <a href=\"/substring-search\">brute force algorithm</a> doesn't work. Let's talk about an algorithm that provides a substantial improvement over the naive approach: the KMP algorithm.</p>\n<h3 id=\"prefix-array\"><a href=\"#prefix-array\" aria-label=\"prefix array permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prefix Array</h3>\n<p>The idea behind KMP is simple: every time there's a mismatch, there's no need to go all the way back to the next iteration in for loop. If you've matched a part of the substring, take advantage of that partial match and start at a later index. This way, we don't have to iterate over each and every non-matching character.</p>\n<p>Let's start with the pattern we're searching for. Let's say this is the pattern:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">abababca</code></pre></div>\n<p>In order for us to take advantage of partial matches, we need something to help us know how many characters we've matched and where we should start searching again. To do so, we'll create an prefix/suffix array. The array, as you suspected, would be of the same length as the pattern. So, in our case here's the array (indices at the top and actual entries on the bottom):</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>c</td>\n<td>a</td>\n</tr>\n</tbody>\n</table>\n<p>How do we go about filling in this array? To do so, we need to understand what a <strong>proper prefix</strong> and a <strong>proper suffix</strong> is:</p>\n<p>Say you have a string <code class=\"language-cpptext\">renner</code>. Its prefixes and suffixes are:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\"><span class=\"token property\">prefix</span><span class=\"token punctuation\">:</span> r<span class=\"token punctuation\">,</span>re<span class=\"token punctuation\">,</span>ren<span class=\"token punctuation\">,</span>renn<span class=\"token punctuation\">,</span>renne <span class=\"token punctuation\">(</span>chop off the last character<span class=\"token punctuation\">)</span>\n<span class=\"token property\">suffix</span><span class=\"token punctuation\">:</span> enner<span class=\"token punctuation\">,</span>nner<span class=\"token punctuation\">,</span>ner<span class=\"token punctuation\">,</span>er<span class=\"token punctuation\">,</span>r <span class=\"token punctuation\">(</span>chop off the first character<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now, at a particular cell, we're only interested in the substring up till that point. So, if we're currently at index 3, we're only interested in finding the prefix and suffix of the substring formed up till that point. It only logical to do so since we haven't seen the remaining string. </p>\n<p>Ok, so if we're at index 3, our substring is: <code class=\"language-cpptext\">abab</code>. Its prefixes and suffixes are:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\"><span class=\"token property\">prefix</span><span class=\"token punctuation\">:</span> a<span class=\"token punctuation\">,</span>ab<span class=\"token punctuation\">,</span>aba\n<span class=\"token property\">suffix</span><span class=\"token punctuation\">:</span> bab<span class=\"token punctuation\">,</span>ab<span class=\"token punctuation\">,</span>b</code></pre></div>\n<p>Now, what goes at index 3? The <strong>length</strong> of the longest string that is present in both prefix and suffix. Let's see what's present in both prefix and suffix: <code class=\"language-cpptext\">ab</code>. What is the length of <code class=\"language-cpptext\">ab</code>? 2. So at index 3, we'll have 2. It doesn't matter if we had more matches, we're only interested in the length of the longest substring. That is because the longest substring would capture the smaller ones in it. A completely filled prefix array would look like this for our pattern:</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>c</td>\n<td>a</td>\n</tr>\n</tbody>\n</table>\n<p>How do we code this array building process?</p>\n<p>We'll have 2 pointers, one that goes faster and looks at new characters while a slower pointer that would check if the two characters are the same.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber 0\" class=\"language-cppcpp line-numbers\"><code class=\"language-cppcpp\"><span class=\"token comment\">//the pattern string</span>\nstring pat <span class=\"token operator\">=</span> <span class=\"token string\">\"abababca\"</span>\n\n<span class=\"token comment\">//The array we'll be populating</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">arr</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//A single character has no matches</span>\narr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\">//j is what we'll populate the vector with</span>\n<span class=\"token comment\">//it will also serve as the slow pointer</span>\n<span class=\"token keyword\">int</span> pre <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//m is the length of pattern</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pat<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pat<span class=\"token punctuation\">[</span>pre<span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span>\n        pre<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        pre <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Let's step through the for loop and see it populate our array:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pat<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pat<span class=\"token punctuation\">[</span>pre<span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span>\n        pre<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        pre <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>When pre = 0 and i = 1, pat[pre] and pat[i] are not the same, so we assign 0 to pre and place pre's value at index i</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">pre = 0<span class=\"token punctuation\">;</span>\ni = 1<span class=\"token punctuation\">;</span>\npat[i] != pat[pre]</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>0 -> pre</th>\n<th>1 -> i</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>-1</td>\n<td>-1</td>\n<td>-1</td>\n<td>-1</td>\n<td>-1</td>\n<td>-1</td>\n</tr>\n<tr>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>c</td>\n<td>a</td>\n</tr>\n</tbody>\n</table>\n<p>Now i increments to 2. So, pre = 0 and i = 2, pat[pre] and pat[i] are the same now, so we increment pre to 1 and place pre's value at arr[i]:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">pre = 0<span class=\"token punctuation\">;</span>\ni = 1<span class=\"token punctuation\">;</span>\npat[i] != pat[pre]</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>0 -> pre</th>\n<th>1</th>\n<th>2 -> i</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>-1</td>\n<td>-1</td>\n<td>-1</td>\n<td>-1</td>\n<td>-1</td>\n</tr>\n<tr>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>c</td>\n<td>a</td>\n</tr>\n</tbody>\n</table>\n<p>Now i increments to 3. So, pre = 1 and i = 3, pat[pre] and pat[i] are the same now, so we increment pre to 2 and place pre's value at arr[i]:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">pre = 0<span class=\"token punctuation\">;</span>\ni = 1<span class=\"token punctuation\">;</span>\npat[i] != pat[pre]</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>0 -> pre</th>\n<th>1</th>\n<th>2</th>\n<th>3 -> i</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>-1</td>\n<td>-1</td>\n<td>-1</td>\n<td>-1</td>\n</tr>\n<tr>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>c</td>\n<td>a</td>\n</tr>\n</tbody>\n</table>\n<p>This process continues until we have stepped through the entire array. Finally, we'll have this array:</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>c</td>\n<td>a</td>\n</tr>\n</tbody>\n</table>\n<p> The time it takes to build this array is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is the length of the pattern. </p>\n<h3 id=\"logic\"><a href=\"#logic\" aria-label=\"logic permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Logic</h3>\n<p>Ok, so we've built our prefix array, now how do we use this? Let's say, this is what we have for our text and pattern:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\"><span class=\"token property\">Text</span><span class=\"token punctuation\">:</span>       dddababcabababcaab\n<span class=\"token property\">Pattern</span><span class=\"token punctuation\">:</span>            abababca</code></pre></div>\n<p>and we've already built this prefix array for ourselves:</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>c</td>\n<td>a</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"logic-1\"><a href=\"#logic-1\" aria-label=\"logic 1 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Logic</h3>\n<p>What use is the prefix array for matching? <strong>We use the prefix array to determine how far forward we can move the pattern string while comparing against the text when we get a mismatch.</strong> Let's look at our text and pattern and see how this works:</p>\n<p>We start with comparing <code class=\"language-cpptext\">text[0]</code> with <code class=\"language-cpptext\">pattern[0]</code> and continue doing so until we reach text[4]. The first 3 indices don't match: no character in <code class=\"language-cpptext\">ddd</code> matches <code class=\"language-cpptext\">a</code>. So, when we get to <code class=\"language-cpptext\">text[4]</code>, things get interesting:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">      | \nd d d a b a b c a b a b a b c a a b\n      a b a b a b c a</code></pre></div>\n<p>at <code class=\"language-cpptext\">text[4]</code> we have a match, moving on, we see that there's a match up till <code class=\"language-cpptext\">text[6]</code> and <code class=\"language-cpptext\">text[7]</code> is a mismatch.</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">      | | | | x --> a partial match \nd d d a b a b c a b a b a b c a a b\n      a b a b a b c a</code></pre></div>\n<p>We notice that from our pattern string, we were able to match 4 (let's call this <code class=\"language-cpptext\">numMatches</code>) characters: <code class=\"language-cpptext\">a b a b</code> and the mismatch was on the 5th character. Here's our prefix array again:</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>c</td>\n<td>a</td>\n</tr>\n</tbody>\n</table>\n<p>So, we go to <code class=\"language-cpptext\">prefixArr[numMatches]</code> and see the value = <code class=\"language-cpptext\">3</code>. We then perform this calculation: </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">shiftAmount <span class=\"token operator\">=</span> numMatches <span class=\"token operator\">-</span> value <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token comment\">//shiftAmount = 2</span></code></pre></div>\n<p>The plus 1 is required so that we move to the correct new position. It is because of this <code class=\"language-cpptext\">+ 1</code> that some implementations begin the <code class=\"language-cpptext\">prefixArr</code> at 1 and have <code class=\"language-cpptext\">prefixArr[0] = -1</code>. Ok, so now we've got our shift amount as 2. So we move the pattern 2 positions down based on where we started getting the matches. Notice how the characters now align. The <code class=\"language-cpptext\">ab</code> match which is why we couldn't move down more:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">          | | --> Prevented us from moving down more \nd d d a b a b c a b a b a b c a a b\n          a b a b a b c a</code></pre></div>\n<p>Anyway, we're now at index 5, and we begin matching again:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">          | | x --> Mismatch<span class=\"token punctuation\">,</span> we only matched 2 \nd d d a b a b c a b a b a b c a a b\n          a b a b a b c a</code></pre></div>\n<p>Now, we only matched 2 characters: <code class=\"language-cpptext\">a b</code>. So, we go to <code class=\"language-cpptext\">prefixArr[2]</code> and get 1. 2 - 1 + 1 = 2. So we can set our pattern at the position: 5 + 2 = 7:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">              | -> new position\nd d d a b a b c a b a b a b c a a b\n              a b a b a b c a</code></pre></div>\n<p>We immediately have a mismatch so we move to the next position:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">                | -> new position\nd d d a b a b c a b a b a b c a a b\n                a b a b a b c a</code></pre></div>\n<p>Now, we have a match, let's keep matching:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">                | | | | | | | |-> all matched\nd d d a b a b c a b a b a b c a a b\n                a b a b a b c a</code></pre></div>\n<p>Now, we matched 8 so we go to <code class=\"language-cpptext\">prefixArr[8]</code> which doesn't exist! Which means we matched our pattern. In this case, you can keep going to find all possible matches by moving down the length of the pattern. So, we're at position 8 and the pattern is of length 8 so 8 + 8 = 16 which would be our new start position:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">                                | -> new start position\nd d d a b a b c a b a b a b c a a b\n                a b a b a b c a</code></pre></div>\n<p>And that is how KMP works!</p>\n<h3 id=\"code\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h3>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber 0\" class=\"language-cppcpp line-numbers\"><code class=\"language-cppcpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">KMP</span><span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> prefixArr<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">buildPrefixArr</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> patternLength<span class=\"token punctuation\">;</span>\n    \n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">GetIndex</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">,</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> KMP<span class=\"token operator\">::</span><span class=\"token function\">GetIndex</span><span class=\"token punctuation\">(</span>string text<span class=\"token punctuation\">,</span> string pat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    patternLength <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>pat<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">buildPrefixArr</span><span class=\"token punctuation\">(</span>pat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> ans<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//pattern iterator</span>\n        <span class=\"token keyword\">int</span> patItr <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> txtItr <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pat<span class=\"token punctuation\">[</span>patItr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> numMatched <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">[</span>txtItr<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pat<span class=\"token punctuation\">[</span>patItr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                txtItr<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                patItr<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                numMatched<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            \n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numMatched <span class=\"token operator\">==</span> patternLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">//We've got a full match!</span>\n                ans<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                i <span class=\"token operator\">+=</span> patternLength<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">//Partial match, figure out how much to move</span>\n                i <span class=\"token operator\">=</span> numMatched <span class=\"token operator\">-</span> prefixArr<span class=\"token punctuation\">[</span>numMatched<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> KMP<span class=\"token operator\">::</span><span class=\"token function\">buildPrefixArr</span><span class=\"token punctuation\">(</span>string pat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    prefixArr<span class=\"token punctuation\">.</span><span class=\"token function\">resize</span><span class=\"token punctuation\">(</span>patternLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> pre <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> patternLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pat<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pat<span class=\"token punctuation\">[</span>pre<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            pre<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            pre <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        prefixArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The code above is exactly the same as the logic we discussed. We create a new <code class=\"language-cpptext\">prefixArr</code> for each new request that we get from the client. And our <code class=\"language-cpptext\">GetIndex()</code> function returns a vector with all the starting indices in the text for each match.</p>\n<h3 id=\"analysis\"><a href=\"#analysis\" aria-label=\"analysis permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Analysis</h3>\n<p>So, we precompute the <code class=\"language-cpptext\">prefixArr</code> for each search. This is simply of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is the length of the pattern. Next, we begin our search that would, in the worst case scenario, would run for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is the length of the text. Therefore, the total work that we do is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> and then we do <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> amount of work for a total of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo>+</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(M + N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>. </p>","timeToRead":10,"excerpt":"Table of Contents Introduction Prefix Array Logic Code Analysis Introduction We've looked at why the brute force algorithm doesn't work. Let…","frontmatter":{"title":"Knuth Morris Pratt Algorithm","date":"2020-04-05T00:00:00.000Z","categories":["Strings"],"extract":"An analysis of KMP substring search algorithm","thumbnail":"/post-images/kmp.png","tags":["Data Structures"]},"fields":{"slug":"/knuth-morris-pratt-algorithm","date":"April 05, 2020"}}},"pageContext":{"slug":"/knuth-morris-pratt-algorithm","nexttitle":"Substring Search","nextslug":"/substring-search","prevtitle":"Quick Sort","prevslug":"/quick-sort"}}}