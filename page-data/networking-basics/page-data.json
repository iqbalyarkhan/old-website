{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/networking-basics",
    "result": {"data":{"markdownRemark":{"html":"<h3 id=\"table-of-contents\" style=\"position:relative;\"><a href=\"#table-of-contents\" aria-label=\"table of contents permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Table of Contents</h3>\n<ul>\n<li><a href=\"#intro\">Intro</a></li>\n<li><a href=\"#layer-1---physical\">Layer 1 - Physical</a></li>\n<li><a href=\"#layer-2---data-link-layer\">Layer 2 - Data Link Layer</a></li>\n<li><a href=\"#layer-3---network\">Layer 3 - Network</a>\n<ul>\n<li><a href=\"#packets\">Packets</a></li>\n<li><a href=\"#ip-addressing-v4---ipv4\">IP Addressing (v4) - IPv4</a></li>\n<li><a href=\"#default-gateway\">Default Gateway</a></li>\n<li><a href=\"#subnet-mask\">Subnet Mask</a></li>\n<li><a href=\"#route-table\">Route Table</a></li>\n</ul>\n</li>\n<li><a href=\"#layer-4--5---transport--session\">Layer 4 &#x26; 5 - Transport &#x26; Session</a>\n<ul>\n<li><a href=\"#udp\">UDP</a></li>\n<li><a href=\"#tcp\">TCP</a></li>\n<li><a href=\"#tcp-and-transferring-data\">TCP and transferring data</a></li>\n<li><a href=\"#tcp-3-way-handshakes\">TCP 3-way handshakes</a></li>\n<li><a href=\"#tcp-security\">TCP security</a></li>\n</ul>\n</li>\n<li><a href=\"#network-address-translation\">Network Address Translation</a>\n<ul>\n<li><a href=\"#static-nat\">Static NAT</a></li>\n<li><a href=\"#dynamic-nat\">Dynamic NAT</a></li>\n<li><a href=\"#port-address-translation\">Port Address Translation</a></li>\n</ul>\n</li>\n<li><a href=\"#encryption\">Encryption</a>\n<ul>\n<li><a href=\"#encryption-at-rest\">Encryption at Rest</a></li>\n<li><a href=\"#encryption-in-transit\">Encryption in Transit</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>Before we can fully understand what VPC is and how it operates, it is important to understand fundamentals of networking. As an intro, we'll be going through some of the important layers present in the OSI network model:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.5028901734104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAACZ0lEQVQ4y41U226bQBDl//8mUqs2fcnloVIhxq2MY9Ys7HJdLgbjxImd2M6pZlISK02qjjQa7TAczpmZxcKRHQ4HjipSCGSAr+4XnNgnOHW/4fzXOU7Hp5BhiDAMEUURHh8fuf7p6YmdzNput7i5ucFut3sBvru7Q5qmqIoKtanZy6LkSPnNdoPlcommaY75MKi1Wq0gxBwPDw8g8N1+B1MYmNpgpK8w0iPYysF1NsU4/gnTGBR5wQBJkkBKCXfkIk2zZ4Yks6oqPhRFwV+mj0QqwiycwQ99joEKMJVThCpEv+xZLtWHoYRjO7hdr18BjTF8aNsW6/WaY1VW0IXGVE8hsxDzdI7EJKirGs2iQZZlXPuXZJIZxzEn+r7HZrPh3iyaBXSpMVZjiEzAiydQRqFrOwYjf88sGsb9/T32+x1mM58LSbJSiuUNrvTzmfKkgCTTMAcn5qTWeqV74OlSITEmhl4ywYV/AVva7K4aM0MhBLTWiJMYQRCgyHPEWmO/38M63qHBSDb1tW1a9IseXdO9OOXp+UdmDWAUXxZbKaRJCkfY+OR+xqV3ibPJGa7EFfI0h+/7zJCMWNF75DyUt1MahsOSYg2pJCId/emj5o9Rj2ll3jL9EJD2slu0mOcCfiYQ5HPIQiI0EdpFi7qu+WYJ4eOHbcNxHB4US/4IsDQGIhGYKA9+PMNETXAdX6M0Ja8VbQax9TyP2f6TId0WurNREkFqiSiOoBONOI0533UdR+rff0nml9qOZX6X3+FqFyM1Yvm3q1u4Y5dlD3+o48G+C0i7SD2hOzv4sluyU55+JMf1x4C/Af3st73nvsstAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"OSI-Networking\"\n        title=\"OSI-Networking\"\n        src=\"/static/88c93357e7981ac541cd7ef57a5fd441/1e043/osi-model.png\"\n        srcset=\"/static/88c93357e7981ac541cd7ef57a5fd441/991de/osi-model.png 173w,\n/static/88c93357e7981ac541cd7ef57a5fd441/e4d6b/osi-model.png 345w,\n/static/88c93357e7981ac541cd7ef57a5fd441/1e043/osi-model.png 690w,\n/static/88c93357e7981ac541cd7ef57a5fd441/7fee5/osi-model.png 781w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><a href=\"https://www.geeksforgeeks.org/layers-of-osi-model/\">Image Credit</a></p>\n<p>We'll start at the bottom layer (physical) and make our way up to the top layer (application). All of these layers combined together create your networking stack.</p>\n<p>Layers 1-3 can be thought of as the media layer which deals with sending data from point A to point B.</p>\n<p>Layers 5-7 can be thought of as the host layers which deals with chopping of data and transporting it.</p>\n<h2 id=\"layer-1---physical\" style=\"position:relative;\"><a href=\"#layer-1---physical\" aria-label=\"layer 1   physical permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layer 1 - Physical</h2>\n<p>Let's start with layer 1. If you want to connect 2 machines (laptops, servers etc), you can use the same wifi network or a network cable. Let's assume, we're using a network cable to connect A with B. This network cable is literally your copper cable! Therefore, the signal used to transfer information between A and B would be electrical for our example. We can also use WiFi to connect A to B (where signal would be radio frequency) or a fiber link (where signal would be light).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 626px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/149802e7613d77fdb5eedb5d6047e0a9/af590/physical-layer.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.19653179190751%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABqklEQVQoz22R30/acBTF+79ve5kTF32aifLAj/VhL2YJRh8kgTkQGijQEgoFhC8FR8uPAiUwkM/SgiYunuQkN/eee3J/SOv1Gh+j0YjxeIwQAtd1sW2bl9r/WK1WNJtN0uk0s9kMx3GCvJ+Tlsslm83mVZzJZNg+PwfxzPNYHUx3ux3b7TYw8+F5HqZpvtbWmw01w0BaLBbUDQNd01Dyea4TCQzDoG2aXKdS2K77ZjJfVymXKRYKlEslmqZJVdMo6DplXUfyRU/DIW0hqLdaPApBs9Oh1+9zpygMp9PDFL7hmsZBo6gqPxMJxKBPpycwul20Wg2p2+2SvL/nt6rSsYfkNQ1rMuFx+AfTsnyrN/drDwaBzjf4pSgIx+EumyWdy5F7eNgbapUKfw+3sXo91EKBqt6gpLY5/3bF2dkPTk5kzs+vKBZbPPVHWD2BY9v7Hn8rf/VqFem9L87nc2x7QsMU3NxkSCbzpNIqt7dZjHqHqeu9+33LspDC4TCxWIxIJEI0Gg0oyzKy/J2jo88cH+95evqVUOgLnz5+4PLygng8HvS80O8JhUL8A1OMPEVnyMy5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Physical-Layer\"\n        title=\"Physical-Layer\"\n        src=\"/static/149802e7613d77fdb5eedb5d6047e0a9/af590/physical-layer.png\"\n        srcset=\"/static/149802e7613d77fdb5eedb5d6047e0a9/991de/physical-layer.png 173w,\n/static/149802e7613d77fdb5eedb5d6047e0a9/e4d6b/physical-layer.png 345w,\n/static/149802e7613d77fdb5eedb5d6047e0a9/af590/physical-layer.png 626w\"\n        sizes=\"(max-width: 626px) 100vw, 626px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Layer 1 specs define how data is transmitted where data is raw bit (1s and 0s) streams between 2 devices using a shared physical medium. The specs define what voltage levels will be used, the timing of our signals, the rates etc. It is at this layer where we determine what level of voltage would represent 1 bit and what level would represent 0 bit. Therefore a layer 1 device just understands layer 1 communication methods. While a layer 3 device would understand layers 1, 2 AND 3.</p>\n<p>What if we need more devices connected to each other? Say 4 devices? You can use a hub to connect 4 devices together. A hub's job is to transmit a message received on any port to every other port. However, with hub communication, you can:</p>\n<ul>\n<li>only have 1 device transmitting at a time</li>\n<li>If 2 devices transmit at the same time, the message is corrupted.</li>\n<li>there's no method to control media collision or media access control</li>\n<li>not scalable if we can't handle collision</li>\n</ul>\n<h2 id=\"layer-2---data-link-layer\" style=\"position:relative;\"><a href=\"#layer-2---data-link-layer\" aria-label=\"layer 2   data link layer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layer 2 - Data Link Layer</h2>\n<p>Layer 2 network works on top of layer 1. This means, we'll build on top of what we already had in layer 1. Layer 2 introduces the ideas of:</p>\n<ul>\n<li><strong>frames</strong>: instead of focusing on voltages, frames are used. Frames help \"package data\".</li>\n<li><strong>device addresses</strong>: devices at L2 have unique hardware, MAC, addresses.</li>\n<li><strong>carrier checks</strong>: to prevent collisions on layer 1.</li>\n</ul>\n<p>Layer 2 will provide frames and device addresses which will then be transported via layer 1 mediums. So when layer 1 is transmitting a frame it won't understand what it is transmitting but would still do its job which is to transport data from A to B.</p>\n<p>The frame contains information such as destination MAC address, source MAC address, payload (actual data that we want delivered) and ET (ethernet type). This payload is generally generated by layer 3! Layer 2 frames are generated by the software on the source side. These frames are then transmitted to the destination via layer 1 and received by the destination at layer 1. If there's a carrier flag detected by layer 2 on layer 1, the message is not sent. The carrier flag signifies that another message is currently being transmitted via layer 1. This helps prevent collision. If both sides detect no carrier and send at the same time, we can use collision detection, or CD, to determine that. This triggers a jam signal that triggers a random back off period where all sides stop sending signals and one transmitter at random will start again. If no carrier flag is detected, the frame is then transmitted on to layer 2 on destination side and the frame is interpreted here before the payload is passed on to layer 3 on the destination side.</p>\n<p>Remember we used hub for layer 1? If we use layer 2 devices using a hub, we'd still get lots of collisions and corruption. We can use switches for the transport layer as well where a switch is a layer 2 device. Switches use a MAC address table that keeps track of what port each MAC is on. This allows switches to direct frames to correct machines.</p>\n<h2 id=\"layer-3---network\" style=\"position:relative;\"><a href=\"#layer-3---network\" aria-label=\"layer 3   network permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layer 3 - Network</h2>\n<p>Layer 3 requires a functional layer 2. The job of layer 3 is to move data from source to destination: for example, from youtube server to your local device via the internet.</p>\n<p>Say we have 2 layer 2 local area networks that are geographically separated and isolated (one is in us-east-1 and the other is in us-west-2). Devices can communicate with each other within their LANs but not outside of their local networks. You can use a point-to-point (or P2P) link to connect these 2 LANs but that would be expensive and is not scalable!</p>\n<p>Layer 3 is that common protocol that can be used to connect layer 2 networks that are using different protocols. This adds internet protocol or IP addresses to the LANs and routing to move data between LANs without using direct P2P links. This means that the source and destination have IP addresses and the destination can request for data from source. IP \"packets\" are moved from source to destination via intermediate networks (or internet!) and the information is encapsulated in different frames along the way.</p>\n<h3 id=\"packets\" style=\"position:relative;\"><a href=\"#packets\" aria-label=\"packets permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Packets</h3>\n<p>Packets are simialr to frames but the difference is that the source and destination of a packet can be global whereas frames generally have local destinations and source. Generally during their journey, the packets remain the same. Packets are placed inside frames where each frame is specific to the local network that the packet is moving through. The frames change as the LAN changes while the packet remains unchanged.</p>\n<p>There're 2 versions of IP packet structures: IPv4 and IPv6. Similar to frames, the IP packet contains various different fields. The important ones are:</p>\n<ul>\n<li>source and destination IP address fields. IPv6 source and destination numbers are larger as compared to IPv4 packet.</li>\n<li>protocol: this is the protocol provided by layer 4. Example could be ICMP (pings!), TCP or UDP. The destination layer 3 would then know which layer 4 data protocol to pass the data into.</li>\n<li>ttl or hop limit in IPv6: time to live determines how many hops the packet is allowed to make from network to network in case the packets hops around the world for some reason.</li>\n<li>data!</li>\n</ul>\n<p>Remember, Layer 3 packets have no ordering, no error checking and no association with other packets whatsoever.</p>\n<h3 id=\"ip-addressing-v4---ipv4\" style=\"position:relative;\"><a href=\"#ip-addressing-v4---ipv4\" aria-label=\"ip addressing v4   ipv4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IP Addressing (v4) - IPv4</h3>\n<p>An example IP address: <code class=\"language-cpptext\">133.33.3.7</code>. You could send a packet to this address. Now there could be firewalls or that the destination IP address is offline but you could get the ball rolling on sending this destination a packet. This is known as dotted decimal notation that is 4 numbers separated by dots where each number can be in the range 0-255. The first two numbers, <code class=\"language-cpptext\">133.33</code> define the network and the last two, <code class=\"language-cpptext\">3.7</code> define the host or a device on that network.</p>\n<p>These IP addresses are not how they're used in an actual network. They're converted to decimal for our ease of use. In a network, they're used as an 8-bit representation:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">133 = 10000101\n33  = 00100001\n3   = 00000011\n7   = 00000111</code></pre></div>\n<p>Therefore we'll have 4 sets of 8 bits which means an IP address is 32 bits long.</p>\n<p>This IP address, <code class=\"language-cpptext\">133.33.3.7</code> , has a /16 prefix. Meaning, the first 16 bits, or the first octect, represents the network. The remaining bits are for the hosts. IP addresses on the same network will have the same first 16 bits.</p>\n<h3 id=\"default-gateway\" style=\"position:relative;\"><a href=\"#default-gateway\" aria-label=\"default gateway permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Default Gateway</h3>\n<p>An item configured on network interfaces is a default gateway. Default gateway is nothing but an IP address on the local network to whcih packets are fowarded to generally if the destination is not a local IP address.</p>\n<h3 id=\"subnet-mask\" style=\"position:relative;\"><a href=\"#subnet-mask\" aria-label=\"subnet mask permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Subnet Mask</h3>\n<p>Another item configured is a subnet mask. These are configured on layer 3 interfaces. Subnet masks allow an IP device to know if an IP address which it is communicating with is on the same network or not. A subnet mask is configured on a host device. For example, <code class=\"language-cpptext\">255.255.0.0</code> is the same as <code class=\"language-cpptext\">/16</code> prefix or meaning that the first 16 bits represent the network. Why is this <code class=\"language-cpptext\">/16</code>? Because <code class=\"language-cpptext\">255.255.0.0</code> converted to binary is <code class=\"language-cpptext\">11111111.11111111.00000000.00000000</code>. This is the number of 1s in this adddress = 16. It is called a subnet mask because if you AND it with the subnet mask, you get the network IP address. So, using our example earlier (binary representation of 133.33.3.7 and subnet mask /16):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">10000101.00100001.00000011.00000111\n11111111.11111111.00000000.00000000(AND)\n-----------------------------------\n10000101.00100001.00000000.00000000\n\nNetwork IP:\n133.33.0.0</code></pre></div>\n<p>The subnet mask allows the device to figure out whether to communicate directly on the local network or if it needs to use the default gateway. In your home network, your internet router is likely set as your default gateway. When you try to visit youtube.com from your laptop, and since youtube's IP address is not local, your request packets are forwarded to your router.</p>\n<h3 id=\"route-table\" style=\"position:relative;\"><a href=\"#route-table\" aria-label=\"route table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Route Table</h3>\n<p>When a request created on your laptop for AWS us-east-1 s3 endpoint, it first goes to your home router and next to your ISP where it encounters a route table. The route table has specific <code class=\"language-cpptext\">Next Hop/Target</code> fields for <code class=\"language-cpptext\">Destinations</code>. Meaning, if the packet is for a particular destination, it needs to be sent to the <code class=\"language-cpptext\">Next Hop/Target</code> address. This is where the packet is wrapped in a frame and is forwarded!</p>\n<h2 id=\"layer-4--5---transport--session\" style=\"position:relative;\"><a href=\"#layer-4--5---transport--session\" aria-label=\"layer 4  5   transport  session permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layer 4 &#x26; 5 - Transport &#x26; Session</h2>\n<p>Transport layer runs on top of networking layer. In layer 3 we assumed packet order and delivery is guaranteed! Which is not the case. At times when there's a network outage, the packet could go missing. Also layer 3 has no way of differentiating packets by app or channel. Layer 3 also has no flow control (source emitting faster than destination consuming).</p>\n<p>Layer 4 adds transmission control protocol (TCP) and UDP (User Datagram Protocol) to layer 3. Both of these protocols run on top of IP and both add a collection of features depending on which one is used.</p>\n<h3 id=\"udp\" style=\"position:relative;\"><a href=\"#udp\" aria-label=\"udp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UDP</h3>\n<p>UDP is faster as compared to TCP because it doesn't bother with data order or reliability.</p>\n<h3 id=\"tcp\" style=\"position:relative;\"><a href=\"#tcp\" aria-label=\"tcp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP</h3>\n<p>TCP allows for reliable, error free and ordered data delivery. It is used for important application layer protocols such as HTTP, HTTPS and SSH. TCP is a connection oriented protocol, meaning that you need to first establish a connection between two devices and once set up, it creates a bi-directional channel of communications. Port on the client is said to be random. It is an ephemeral (short-lived), temporary port. However, on the server receiving the TCP connection, the port must be 443.</p>\n<p>Using TCP, we introduce the idea of a \"segment\". Segment is similar to frames and segments are encapsulated within IP packets. Packets carry segments from their source to their destination. Segments don't have source or destination IP addresses because they use IP packets for transit. However, TCP segments add more capabilities to IP packets.</p>\n<ul>\n<li>source and destination ports: allows for multiple connection types: ssh, https (port 443), http etc!</li>\n<li>sequence number: for ordering</li>\n<li>acknowledgements: one side can ack that it has received up to and including up to a certain sequence number. This helps ensure reliability of TCP.</li>\n<li>window: # of bytes you agree to receive bytes from the sender</li>\n</ul>\n<h3 id=\"tcp-and-transferring-data\" style=\"position:relative;\"><a href=\"#tcp-and-transferring-data\" aria-label=\"tcp and transferring data permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP and transferring data</h3>\n<p>Layer 4 takes the data and divides it into segments. These segments contain sequence numbers to maintain order and lost segments can be re-transmitted. Now using the ephemeral port on sender and 443 on receiver, we can establish \"communication\". The receiver port can then send communication back to sender with now 443 as sender port and ephemeral port as the receiver port. Therefore, from a layer 4 perspective, you have 2 sets of segment communication:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">source      destination\n----------------------\nephemeral -> 443\n443       -> ephemeral</code></pre></div>\n<p>This is why you need 2 sets of rules on NACL in AWS (more on this in VPC section).</p>\n<h3 id=\"tcp-3-way-handshakes\" style=\"position:relative;\"><a href=\"#tcp-3-way-handshakes\" aria-label=\"tcp 3 way handshakes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP 3-way handshakes</h3>\n<ol>\n<li>Client creates a segment with SYN and informing server what sequence number (call it cs) it is going to start with</li>\n<li>Server returns a SYN-ACK segment back to client and a separate sequence number (call it ss) where ss = cs + 1</li>\n<li>Client then creates a new segment with ACK, increments ss and cs and sends it back to server.</li>\n</ol>\n<p>At this point, the connection is established and communication can proceed!</p>\n<h3 id=\"tcp-security\" style=\"position:relative;\"><a href=\"#tcp-security\" aria-label=\"tcp security permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP security</h3>\n<p>With TCP communcation, you want to have some sort of security around your sender. You need a firewall for that. You can have a stateless firewall which doesn't understand that you're in a 2 way communication. Therefore, for stateless firewalls, you need to setup rules for both outbound and inbound traffic. This is nothing but NACL in AWS world!</p>\n<p>Another firewall you can have is stateful: it understands that the connection is of type TCP and it understands the state of our TCP segment. So, if you allow outbound traffic from a port, it'll automatically allow inbound traffic to that port. This is a security group in AWS world.</p>\n<h2 id=\"network-address-translation\" style=\"position:relative;\"><a href=\"#network-address-translation\" aria-label=\"network address translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Network Address Translation</h2>\n<p>NAT is used to allow private devices to gain internet access by translating private IP addresses into public IP addresses so that packets can flow over the public internet and then back in from the internet to the private service. Private services have IP addresses usually starting with <code class=\"language-cpptext\">10.0.0.&lt;X></code>. NAT only makes sense for IPv4 since there's a shortage of public IP addresses. There are multiple different types of NATs:</p>\n<h3 id=\"static-nat\" style=\"position:relative;\"><a href=\"#static-nat\" aria-label=\"static nat permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static NAT</h3>\n<p>This is where you have a network of private IPv4 addresses and you can allocate a public IP address for each private IP. This gives the private address access to the public address in both directions. This in AWS world is the Internet Gateway. This allows you to have consisten mapping from private to public.</p>\n<h3 id=\"dynamic-nat\" style=\"position:relative;\"><a href=\"#dynamic-nat\" aria-label=\"dynamic nat permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic NAT</h3>\n<p>Here, you use a pool of public IP addresses to use. In this scenario, there's a shortage of public IP addresses because we're using IPv4.</p>\n<h3 id=\"port-address-translation\" style=\"position:relative;\"><a href=\"#port-address-translation\" aria-label=\"port address translation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Port Address Translation</h3>\n<p>This is where we have MANY private IP addresses translated to a single public IP address. This is what NAT gateways are in the AWS world!</p>\n<h2 id=\"encryption\" style=\"position:relative;\"><a href=\"#encryption\" aria-label=\"encryption permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Encryption</h2>\n<p>Secure Sockets Layer (SSL) and Transport Layer Security (TLS) are what provides encrypted communications for HTTPS and other encrypted connection oriented protocols. This encryption allows for privacy (encrypted communication) and data integrity between client and server. We can have encryption at rest or encryption in transit.</p>\n<h3 id=\"encryption-at-rest\" style=\"position:relative;\"><a href=\"#encryption-at-rest\" aria-label=\"encryption at rest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Encryption at Rest</h3>\n<p>Encryption at rest is where you encrypt (scramble) stored data on a hard disk for example. In order to encrypt data, you use some sort of a \"secret\". Without this secret, encryption data cannot be accessed. In the cloud, this could mean encrypting data in your DynamoDB instance. In encryption at rest, there's just one party involved that \"owns\" the data.</p>\n<h3 id=\"encryption-in-transit\" style=\"position:relative;\"><a href=\"#encryption-in-transit\" aria-label=\"encryption in transit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Encryption in Transit</h3>\n<p>Here you provide a \"tunnel\" around your data as the data is transferred from one party to another.</p>","timeToRead":12,"excerpt":"Table of Contents Intro Layer 1 - Physical Layer 2 - Data Link Layer Layer 3 - Network Packets IP Addressing (v4) - IPv4 Default Gateway…","frontmatter":{"title":"Networking Basics","date":"2021-11-20T00:00:00.000Z","categories":["AWS"],"extract":"Notes for Networking","thumbnail":"/post-images/networking.png","tags":["blog","AWS"]},"fields":{"slug":"/networking-basics","date":"November 20, 2021"}}},"pageContext":{"slug":"/networking-basics","nexttitle":"Cloud Intro","nextslug":"/cloud-intro","prevtitle":"AWS - IAM","prevslug":"/aws-iam"}},
    "staticQueryHashes": ["3969716136"]}