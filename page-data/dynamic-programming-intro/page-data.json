{"componentChunkName":"component---src-templates-post-js","path":"/dynamic-programming-intro","result":{"data":{"markdownRemark":{"html":"<ol>\n<li><a href=\"#introduction\">Introduction</a></li>\n<li><a href=\"#dp-and-recursion\">DP and Recursion</a></li>\n<li>\n<p><a href=\"#0-1-knapsack-problem\">0-1 Knapsack</a></p>\n<ul>\n<li><a href=\"#memoization\">Memoization</a></li>\n<li><a href=\"#tabulation\">Tabulation</a></li>\n</ul>\n</li>\n<li><a href=\"#max-subarray\">Max subarray</a></li>\n<li><a href=\"\">Unique ways to make change</a></li>\n<li><a href=\"#conclusion\">Conclusion</a> </li>\n</ol>\n<h3 id=\"introduction\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h3>\n<p>DP is a general technique for solving optimization, search, and counting problems that can be decomposed into sub-problems. You should consider using DP whenever you have to make choices to arrive at the solution, specifically, when the solution relates to sub-problems.</p>\n<p>Like divide-and-conquer, DP solves the problem by combining the solutions of multiple smaller problems, but what makes DP different is that the same sub-problem may reoccur. Therefore, a key to making DP efficient is caching the results of inter- mediate computations. </p>\n<p>The key to solving a DP problem efficiently is finding a way to break the problem into sub-problems such that</p>\n<ul>\n<li>the original problem can be solved relatively easily once solutions to the subÂ¬ problems are available, and</li>\n<li>these sub-problem solutions are cached. (Usually, but not always, the sub-problems are easy to identify) </li>\n</ul>\n<p>DP can be used to find the total number of ways to do something (for example making a change) and if you optimize how you determine each \"way\", you'd get the optimal solution. Thus, DP can be used to find all combinations AND the optimal solution.</p>\n<p>From the discussion above, it is clear to see that DP is nothing but optimized recursion. Therefore, before jumping into dynamic programming, be sure to go over my <a href=\"/recursion\">recursion</a> post. </p>\n<h3 id=\"dp-and-recursion\"><a href=\"#dp-and-recursion\" aria-label=\"dp and recursion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DP and recursion</h3>\n<p>I said earlier that DP is optimized recursion. What does that mean? It means that while we're recursing to solve a problem, we might run into instances where we're redoing work that was previously done in another recursive call. As a result we're performing work that has already been done which is obviously inefficient. To get rid of this redundancy, we can trade space for time where we use extra space to store results we've already calculated. This technique of storing results is known as dynamic programming. </p>\n<p>While trying to understand the DP, I found various sources on the internet that used the table creation technique. Our aim should not be to create the said table but to understand WHY that table is created. DP doesn't require the creation of a table for every problem! </p>\n<p>So how do we know that DP is required to solve a given problem:</p>\n<ul>\n<li>\n<p>If DP is optimized recursion, any recursive problem is also a DP problem!</p>\n<ul>\n<li>There'll be a <strong>choice</strong> (include or exclude something etc) to make and the subproblems overlap. If there are more than one calls being made in each recursive call, ie the recursive functions is calling itself more than once, there is a good chance that it can be optimized using DP.</li>\n</ul>\n</li>\n<li>\n<p>DP also deals with optimization as in find the least number of steps, or the most profitable method etc</p>\n<ul>\n<li>There might be keywords such as minimum, maximum, etc. Where you're looking to either find the max or the min or the least or the most!</li>\n</ul>\n</li>\n</ul>\n<p>Therefore, to summarize if there's recursion and there are more than 1 calls being made to the recursive function in each recursive call:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">    <span class=\"token keyword\">return</span> <span class=\"token function\">Fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">Fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>then we can use DP to cache the results. Secondly, if it is an optimization problem, then using DP is required. Without a recursive solution, creating a table would result in errors. </p>\n<p>Better approach is to:</p>\n<ul>\n<li>Write a recursive solution</li>\n<li>Perform memoization (storing results)</li>\n<li>Create the table if needed to better visualize the algorithm</li>\n</ul>\n<h3 id=\"0-1-knapsack-problem\"><a href=\"#0-1-knapsack-problem\" aria-label=\"0 1 knapsack problem permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0-1 Knapsack Problem</h3>\n<p><strong>The knapsack problem is a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size knapsack and must fill it with the most valuable items. The problem often arises in resource allocation where the decision makers have to choose from a set of non-divisible projects or tasks under a fixed budget or time constraint, respectively.</strong></p>\n<p>W hy is this a DP problem? because we're being asked to optimize our profit. ie <strong>total value is as large as possible</strong>. In addition, we're also given a bunch of choices: ie <strong>Given a set of items, each with a weight and a value, determine the number of each item to include in a collection</strong></p>\n<p>Let's see what our input will be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">                    Item1   Item2   Item3   Item14\nwt[] in pounds        1       3       4        5    \nval[] in dollars      1       4       5        7\nCapacity: 7       </code></pre></div>\n<p>We'll be given two arrays: a weight array that'll hold the weight of each item and a value array that holds the value of each item in dollars. We'll also be given the capacity of our sack and a value <code class=\"language-cpptext\">n</code> denoting the number of elements in the arrays. </p>\n<p>Let's start writing the recursive solution to this problem:</p>\n<p>Let's say this is our function signature. </p>\n<ul>\n<li>It'll return an integer to denote the <code class=\"language-cpptext\">max</code> profit</li>\n<li>It'll accept the relevant arrays, the capacity and the size of the arrays </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> wt<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> val<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ok, now that we have the signature, let's think about the base case: Remember, the <strong>base case</strong> is nothing but the <strong>smallest valid input</strong>. In our case, the smallest valid input is when <code class=\"language-cpptext\">c</code> (or capacity) = 0 (ie we don't have any more space in the bag) or when there're no more items to consider ie n = 0. Let's add this to our function:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> wt<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> val<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//Base case: there's no more space or no more items</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now, let's think about what we can do. To do so, let's see the choices that we have by looking at our arrays:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">                                               n \n                                               |\n                    Item1   Item2   Item3   Item4\nwt[] in pounds        1       3       4        5    \nval[] in dollars      1       4       5        7\nCapacity: 7       </code></pre></div>\n<p>Say <code class=\"language-cpptext\">n</code> is at the last element. Here, we have a few choices that we can make:</p>\n<p>(1) The nth element's weight > capacity. In this case we cannot choose this element\n(2) The nth element's weight &#x3C;= capacity. In this case we can choose (if we want) this element:\n- Weight is less so we might choose it\n- Weight is less so we might ignore it</p>\n<p>Here's the decision tree:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-cpptext\"><code class=\"language-cpptext\">                            itemN\n                       /             \\   \n                    wt[n] &lt;= c      wt[n] &gt; c\n                   /        \\           |\n                add to bag  don&#39;t add   cannot add</code></pre></div>\n<p>We can either choose itemN or we can ignore it. BUT how do we decide, at the end of the day, which item goes in the bag? The item that goes in the bag needs to maximize our profit. So, we'll choose the max of taking the item and not taking the item:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">       \nmax <span class=\"token punctuation\">(</span> \n        <span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> c <span class=\"token operator\">-</span> w<span class=\"token punctuation\">[</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">//choosing the item, so decrease capacity left by weight of item  </span>\n        <span class=\"token function\">knapsack</span><span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//Not choosing the item so just move to the next item</span></code></pre></div>\n<p>Let's see the code for the case where wt[n] &#x3C;= c:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> wt<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> val<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//Weight can either be &lt;= c or > c</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//Choice 1: choose this item</span>\n        <span class=\"token comment\">//Since we're choosing this item, we add the current item's value to whatever we get from next recursive call</span>\n        <span class=\"token keyword\">int</span> profitWithChoosing <span class=\"token operator\">=</span> val<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> c <span class=\"token operator\">-</span> wt<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//Choice 2: Don't choose this item</span>\n        <span class=\"token comment\">//Since we don't choose this item, we simply ignore its value and move to the next item</span>\n        <span class=\"token keyword\">int</span> profitWithNotChoosing <span class=\"token operator\">=</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//Need to return max profit</span>\n        <span class=\"token comment\">//Finally, based on the two decisions above, we choose the max of the two and return that value</span>\n        <span class=\"token keyword\">return</span> max <span class=\"token punctuation\">(</span>profitWithChoosing<span class=\"token punctuation\">,</span> profitWithNotChoosing<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//weight is > capacity, just continue recursing...</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If you trace the recursive call stack above, you'll notice that there are multiple values being re-calculated. How do I know this? Well, as I said earlier, if a recursive function is making multiple calls to itself, it is guaranteed to have overlapping computations. As a result, the running time of this algorithm is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></span></span></span></span></span></span>. We can do much better! </p>\n<h3 id=\"memoization\"><a href=\"#memoization\" aria-label=\"memoization permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memoization</h3>\n<p>We can actually save values once calculated by either recursive call. As mentioned earlier, this process of saving already calculated values is called <strong>memoization</strong>. To save these results, we need to create a 2D vector. This vector will then hold our intermediate results for us. <strong>This intermediate result is nothing but the max profit up till that point</strong>.</p>\n<p>How do we determine the size of our 2D vector? What would be n and what would be m? To determine that, we need to find out the elements we need to keep track of. For example, in the recursive solution above, there's no point in keeping track of the arrays themselves, they're constant. The only two things changing in the algorithm above are:</p>\n<ul>\n<li><code class=\"language-cpptext\">c</code> capacity that decreases with every addition of element</li>\n<li><code class=\"language-cpptext\">n</code> that moves down the arrays. </li>\n</ul>\n<p>Therefore, our 2D vector would be of size c+1 and n+1 to prevent overflow. We'll call this 2D vector dp: </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> <span class=\"token function\">dp</span><span class=\"token punctuation\">(</span>c<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This vector will be initialized with the value -1 indicating that we're yet to calculate this value. Otherwise, we'll  go ahead and calculate the value and store it in our dp vector. We gave up space to reduce our running time. Therefore, we want to save EACH recursive call's value in the 2D vector (notice how we save before each recursive call) so that we're not going to perform calculations that have already been done. </p>\n<p><strong>Each recursive call is going to return the maximum profit for us which we'll save in the 2D vector.</strong> For example, dp[3][2] would tell us that if our capacity is 3 and we've only looked at the first two elements, then our max profit would be in the entry dp[3][2]. The 2D vector, in essence, is saving our intermediate results or <strong>sub-problems</strong> for us. In this example, I've chosen the first element to represent our capacity and the second element to represent our items. It is not required to have this setup. You can switch it around as well. All you have to be mindful of is which is which.</p>\n<p>Let's add this dp vector as a global variable to our program:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> <span class=\"token function\">dp</span><span class=\"token punctuation\">(</span>c<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> wt<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> val<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        \n    <span class=\"token comment\">//Check if value is aleady saved:</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//Weight can either be &lt;= c or > c</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//Choice 1: choose this item</span>\n        <span class=\"token comment\">//Since we're choosing this item, we add the current item's value to whatever we get from next recursive call</span>\n        <span class=\"token keyword\">int</span> profitWithChoosing <span class=\"token operator\">=</span> val<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> c <span class=\"token operator\">-</span> wt<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//Choice 2: Don't choose this item</span>\n        <span class=\"token comment\">//Since we don't choose this item, we simply ignore its value and move to the next item</span>\n        <span class=\"token keyword\">int</span> profitWithNotChoosing <span class=\"token operator\">=</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//Need to return max profit</span>\n        <span class=\"token comment\">//Finally, based on the two decisions above, we choose the max of the two and return that value</span>\n        <span class=\"token comment\">//Store the max before returning:</span>\n        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> max <span class=\"token punctuation\">(</span>profitWithChoosing<span class=\"token punctuation\">,</span> profitWithNotChoosing<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//weight is > capacity, just continue recursing...</span>\n        <span class=\"token comment\">//Store in dp before returning:</span>\n        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ok, so we've seen how we can use recursion and memoization to reduce our running time. We're always asking ourselves, can we do better? What is the one glaring thing in the solution above that we can improve? We can try and get rid of the recursive calls that we have in this solution since a recursive call stack can get pretty large for larger inputs. </p>\n<p>If we think along these lines a little more, we'll realize that if we remove the recursive calls, we can derive our solution using just the 2D array that we created in the recursive solution. So, the next question we should ask ourselves is how do we create that table without using recursion? </p>\n<p>Before we answer that, let's just summarize what we've done so far:</p>\n<ul>\n<li>Started with a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></span></span></span></span></span></span> recursive solution</li>\n<li>Then added a memoized solution that cached calculated results</li>\n<li>Now, we're looking to omit the recursive calls altogether</li>\n</ul>\n<h3 id=\"tabulation\"><a href=\"#tabulation\" aria-label=\"tabulation permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tabulation</h3>\n<p>Ok, so we've decided we're going to get rid of the recursive calls and directly use a matrix. So, if we're directly starting from the matrix, what would be its dimensions? We said earlier, in the memoized solution that our matrix would be used to keep track of only those values that are changing: <code class=\"language-cpptext\">c</code> ie current capacity and <code class=\"language-cpptext\">n</code> which is the current item we're considering. So, our tabular method will also need a matrix of size c+1 * n+1. </p>\n<p>Ok, we've decided that we're removing the recursive call and using the matrix. Let's see this matrix first (notice how I've switched <code class=\"language-cpptext\">n</code> and <code class=\"language-cpptext\">c</code>):</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><strong>0</strong></th>\n<th><strong>1</strong></th>\n<th><strong>2</strong></th>\n<th><strong>3</strong></th>\n<th><strong>4</strong></th>\n<th><strong>5</strong></th>\n<th><strong>6</strong></th>\n<th><strong>7</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>0</strong></td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td><strong>3</strong></td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td><strong>4</strong></td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>So I've got the capacity, which is 7 going from 0 to 7 and the number of items going top to bottom from 0 to 4. These dimensions are <code class=\"language-cpptext\">c + 1</code> and <code class=\"language-cpptext\">n + 1</code> respectively since we want the answer to be in <code class=\"language-cpptext\">dp[c][n]</code> which is only possible if we have one extra slot in each array.</p>\n<p>Next thing we need to do with the matrix is initialize it with 0s:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> <span class=\"token function\">dp</span><span class=\"token punctuation\">(</span>c<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now why 0s and not -1 like we did earlier? Let's think about it: We've decided to convert our recursive function to an iterative solution. Let's start with the base condition:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token comment\">//Recursive:</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">knapSack</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> wt<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> val<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The recursive solution had the base condition where it said that if there are no items or there is no capacity, return 0. Since we'll be using the 2D matrix to solve this iteratively, we need to somehow capture this information in that 2D matrix. Recursive solution said, if n is 0 or c is 0, we'll return 0. So, in the matrix, where n is 0 or c is 0, we'll save 0:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> dp<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// row where n == 0 save all 0s</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Secondly, since there are no more recursive calls, we're going to use iterative calls to then populate the table.</p>\n<h3 id=\"max-subarray\"><a href=\"#max-subarray\" aria-label=\"max subarray permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Max Subarray</h3>\n<p><strong>Find the maximum sum over all subarrays of a given array of integers.The maximum subarray is one where consecutive entries when added yield the largest sum of all subarrays.</strong> </p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token operator\">&lt;</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token operator\">></span></code></pre></div>\n<p>The maximum sum would be this subarray: 8 + -1 + 5 + 6 = 18 </p>\n<p>Approach 1: Start at first index, add to this index every other element in succession and keep track of the largest sum seen in this sequence. For example, start with 4 then:</p>\n<ul>\n<li>4 + 3</li>\n<li>4 + 3 - 9</li>\n<li>4 + 3 - 9 + 8</li>\n<li>4 + 3 - 9 + 8 -1</li>\n</ul>\n<p> and so on. Repeat this process for every other element and compare the max. This would get you the max in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> time. That is because you'd have to do <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> work for each element when you iterate over every other element. Can we do better?</p>\n<p>Approach 2: We can keep a running sum and start from there. Let's see:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">        <span class=\"token number\">4</span>   <span class=\"token number\">3</span>   <span class=\"token operator\">-</span><span class=\"token number\">9</span>  <span class=\"token number\">8</span>   <span class=\"token operator\">-</span><span class=\"token number\">1</span>  <span class=\"token number\">5</span>   <span class=\"token number\">6</span>   <span class=\"token operator\">-</span><span class=\"token number\">2</span>  <span class=\"token operator\">-</span><span class=\"token number\">9</span>  <span class=\"token number\">7</span>\nsum<span class=\"token operator\">:</span>    <span class=\"token number\">4</span>   <span class=\"token number\">7</span>   <span class=\"token operator\">-</span><span class=\"token number\">2</span>  <span class=\"token number\">6</span>   <span class=\"token number\">5</span>   <span class=\"token number\">10</span>  <span class=\"token number\">16</span>  <span class=\"token number\">14</span>  <span class=\"token number\">5</span>   <span class=\"token number\">12</span></code></pre></div>\n<p>Ok, so the running sum doesn't help but it's a start. Now let's think through it logically. When we look at the running sum, notice that we were good until the third element after which the running sum and the correct answer had no correlation. That makes sense because we have negative integers in the array. Just keeping the sum is not enough. </p>\n<p>We're looking for the largest sum right? So whenever the running sum becomes less than the current element, change the running sum's value to the current element. That is because up to the third index, we were doing the best we could but suddenly a higher number was presented and we can be 100% sure that the max sum in the array CANNOT be before 8. So ditch the running sum, and update it to the current element:</p>\n<p> Formally:</p>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>runningSum</mtext><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mtext>runningSum</mtext><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\textrm{runningSum} = max (A[i],\\textrm{runningSum} + A[i]) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord text\"><span class=\"mord textrm\">runningSum</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">x</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">A</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord text\"><span class=\"mord textrm\">runningSum</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span></span>\n<p>Let's see how this affects our totals:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">        <span class=\"token number\">4</span>   <span class=\"token number\">3</span>   <span class=\"token operator\">-</span><span class=\"token number\">9</span>  <span class=\"token number\">8</span>   <span class=\"token operator\">-</span><span class=\"token number\">1</span>  <span class=\"token number\">5</span>   <span class=\"token number\">6</span>   <span class=\"token operator\">-</span><span class=\"token number\">2</span>  <span class=\"token operator\">-</span><span class=\"token number\">9</span>  <span class=\"token number\">7</span>\nsum<span class=\"token operator\">:</span>    <span class=\"token number\">4</span>   <span class=\"token number\">7</span>   <span class=\"token operator\">-</span><span class=\"token number\">2</span>  <span class=\"token number\">8</span>   <span class=\"token number\">7</span>   <span class=\"token number\">12</span>  <span class=\"token number\">18</span>  <span class=\"token number\">16</span>  <span class=\"token number\">7</span>   <span class=\"token number\">14</span></code></pre></div>\n<p>Now, notice how the max sum, 16, occurs at the end of the sequence! This works because at each index, the max sum has 2 possibilities:</p>\n<ul>\n<li>The max sum is just the element itself</li>\n<li>The max sum is sum so far and the element</li>\n</ul>\n<p>Since there can be only one max, we choose the larger value of the two bullet points above to determine our max.</p>\n<p>To summarize, this algorithm is called <strong>Kadane's Algorithm</strong> where running sum is equal to the max of curr and running sum plus curr.\nCode:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">MaxSum</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> curr <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> sum <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">,</span> ans <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        curr <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        sum <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">,</span>sum <span class=\"token operator\">+</span> curr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ans <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">,</span> sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Running time is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"unique-ways-to-make-change\"><a href=\"#unique-ways-to-make-change\" aria-label=\"unique ways to make change permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unique ways to make change</h3>\n<p><strong>Given an amount and the denominations for the currency, find the total number of unique ways that the amount can be created. For example:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Amount <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\nCoins <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span>\n\nYou can make <span class=\"token number\">5</span> <span class=\"token keyword\">using</span> <span class=\"token number\">4</span> unique combinations<span class=\"token operator\">:</span>\n <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n <span class=\"token number\">5</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span></code></pre></div>\n<p>How do we go about tackling this? Notice the quest</p>\n<h3 id=\"conclusion\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h3>\n<ul>\n<li>DP is applied usually when you need to iterate or find something from ALL combinations of a sequence</li>\n<li>DP can be used when you're looking for a combination out of possible scenarios. These are questions where you need to make decisions based on where you are in the algorithm</li>\n</ul>","timeToRead":15,"excerpt":"Introduction DP and Recursion 0-1 Knapsack Memoization Tabulation Max subarray Unique ways to make change Conclusion  Introduction DP is aâ¦","frontmatter":{"title":"Dynamic Programming Intro","date":"2020-06-26T00:00:00.000Z","categories":["Dynamic Programming"],"extract":"Dynamic programming","thumbnail":"/post-images/dynamic-programming.png","tags":["Dynamic programming"]},"fields":{"slug":"/dynamic-programming-intro","date":"June 26, 2020"}}},"pageContext":{"slug":"/dynamic-programming-intro","nexttitle":"Recursion","nextslug":"/recursion","prevtitle":"C++ Standard input","prevslug":"/c-standard-input"}}}