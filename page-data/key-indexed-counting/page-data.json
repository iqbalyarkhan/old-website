{"componentChunkName":"component---src-templates-post-js","path":"/key-indexed-counting","result":{"data":{"markdownRemark":{"html":"<h3 id=\"table-of-contents\"><a href=\"#table-of-contents\" aria-label=\"table of contents permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Table of Contents</h3>\n<ol>\n<li><a href=\"#introduction\">Introduction</a></li>\n<li><a href=\"#logic\">Logic</a></li>\n<li><a href=\"#insertion\">Insertion</a></li>\n<li>\n<p><a href=\"#code\">Code</a></p>\n<ul>\n<li><a href=\"#put\">Put</a></li>\n<li><a href=\"#find\">Find</a></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"introduction\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h3>\n<p>There are plenty of applications where we need to search through strings. To do so, we can use conventional sorting algorithms such as quick sort and merge sort that run in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N log N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> time, but can we do better? This post will have a look at an approach that allows us to do better.</p>\n<h3 id=\"logic\"><a href=\"#logic\" aria-label=\"logic permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Logic</h3>\n<p>Let's see how we can go about sorting a string without actually using compares. This approach is great for situatios where the keys that we're using to sort are small integers. Say, we have 4 sections in a class and we want to list the names of students in each section but this list needs to be ordered by section number. So, section 1 students should be listed first, then section 2 and so on. Let's say we have this array:</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-cppcss\"><code class=\"language-cppcss\">Name Section\nasd     1\nwew     2\nnas     3\nkop     1\nmnx     2\ngge     1\nwes     4\nmki     3\njds     4\nqqq     2\nfdd     1\nnhy     3\nnij     4\nmih     1\nhhe     2</code></pre></div>\n<p>Here's how the algorithm goes: Create an array equal to 1 more than the number of sections. Let's call this array <code class=\"language-cpptext\">count</code>: [0,0,0,0,0].</p>\n<p>Next, iterate through the data and increment <code class=\"language-cpptext\">count[section+1]</code> for each section encountered. For example, if we get section 2, increment <code class=\"language-cpptext\">count[4]</code>. We'll later see why we need to do this. So, here's what the <code class=\"language-cpptext\">count</code> array would look like if you populated it using the data we looked at earlier:</p>","timeToRead":1,"excerpt":"Table of Contents Introduction Logic Insertion Code Put Find Introduction There are plenty of applications where we need to search throughâ€¦","frontmatter":{"title":"Key Indexed Counting","date":"2020-04-10T00:00:00.000Z","categories":["Strings"],"extract":"An analysis of key index counting of strings","thumbnail":"/post-images/keyindexcounting.png","tags":["Algorithms","Key index counting"]},"fields":{"slug":"/key-indexed-counting","date":"April 10, 2020"}}},"pageContext":{"slug":"/key-indexed-counting","nexttitle":"Quick Sort","nextslug":"/quick-sort","prevtitle":"C++ Standard input","prevslug":"/c-standard-input"}}}