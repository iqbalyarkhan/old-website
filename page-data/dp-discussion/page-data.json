{"componentChunkName":"component---src-templates-post-js","path":"/dp-discussion","result":{"data":{"markdownRemark":{"html":"<ol>\n<li><a href=\"#introduction\">Introduction</a></li>\n<li><a href=\"#longest-increasing-subsequence\">Longest Increasing Subsequence</a></li>\n</ol>\n<h3 id=\"introduction\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h3>\n<p>In this post, we'll be dealing with some interesting problems and we'll understand how to use DP to solve them. Before we deep dive let's see what types of problems can be solved using DP:</p>\n<ul>\n<li>Recursive problems with overlapping structures. This means, any problem in the <a href=\"/recursion\">recursion</a> post that has substructure where we're solving already solved subproblems (factorial, subset sum, common subsequence, common substring, min insertions and deletions, stair case et). I've discussed such approaches in the <a href=\"/unbounded-knapsack\">unbounded knapsack</a> and <a href=\"/0-1-knapsack\">0-1 knapsack</a> posts.</li>\n<li>DP programming can also be used to solve problems where solutions are built on top of previously derived solutions. Let's look at a few such problems:</li>\n</ul>\n<h3 id=\"longest-increasing-subsequence\"><a href=\"#longest-increasing-subsequence\" aria-label=\"longest increasing subsequence permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Longest Increasing Subsequence</h3>\n<p><strong>Given an array, return the length of the longest increasing subsequence</strong>.</p>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">Input<span class=\"token operator\">:</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">60</span><span class=\"token punctuation\">}</span>\nOutput<span class=\"token operator\">:</span> Length of LIS <span class=\"token operator\">=</span> <span class=\"token number\">4</span>\nThe longest increasing subsequence is <span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>You can think of this problem recursively where each element can either be picked or ignored. In that case, our running time would be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(2^N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913309999999998em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> since each element has 2 choices and there are a total of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> elements. A better approach might be possible if we think about the subproblems involved.</p>\n<p>Let's see. The base case is when there just a single element, since an element by itself can be characterized as increasing. Therefore, our LIS length if we're given just a single character would be 1. </p>\n<p>Next, as we move along our array of elements, we need som way to keep track of the LIS so far, we'll use a variable called <code class=\"language-cpptext\">lisSoFar</code>. Initially, this would be 1. Next, we'll also keep track of the position where we changed this value just so that we can keep track of the last increasing value we saw. We'll call this <code class=\"language-cpptext\">lisPos</code>. </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\"><span class=\"token comment\">//Initialization</span>\nlisSoFar <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\nlisPos <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token comment\">//first element</span></code></pre></div>\n<p>Next, we'll start with <code class=\"language-cpptext\">arr[1]</code>, <code class=\"language-cpptext\">i</code> represents our current position:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cppcpp\"><code class=\"language-cppcpp\">lisSoFar <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\nlisPos <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    i\n<span class=\"token number\">50</span>  <span class=\"token number\">3</span>   <span class=\"token number\">10</span>  <span class=\"token number\">7</span>   <span class=\"token number\">40</span>  <span class=\"token number\">2</span>   <span class=\"token number\">60</span></code></pre></div>\n<p>If our <code class=\"language-cpptext\">arr[i]</code> > the last element in the increasing subsequence, we'll increment <code class=\"language-cpptext\">lisSoFar</code> and assign <code class=\"language-cpptext\">i</code> to <code class=\"language-cpptext\">lisPos</code>. However, 3 &#x3C; 50, so we'll not make any updates and </p>","timeToRead":2,"excerpt":"Introduction Longest Increasing Subsequence Introduction In this post, we'll be dealing with some interesting problems and we'll understandâ€¦","frontmatter":{"title":"DP Discussion","date":"2020-08-02T00:00:00.000Z","categories":["Dynamic Programming"],"extract":"A deep dive into DP problems","thumbnail":"/post-images/dynamic-programming.png","tags":["Dynamic programming"]},"fields":{"slug":"/dp-discussion","date":"August 02, 2020"}}},"pageContext":{"slug":"/dp-discussion","nexttitle":"Unbounded Knapsack","nextslug":"/unbounded-knapsack","prevtitle":"C++ Standard input","prevslug":"/c-standard-input"}}}