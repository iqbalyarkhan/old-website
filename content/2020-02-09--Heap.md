---
title: Heap
date: 2020-02-09
draft: true
extract: An analysis of heap structure
categories: 
    - Data Structures
tags:
  - Data Structures
  - Heap
---

### Table of Contents

1. [Introduction](#introduction)

2. [Structure](#structure)

3. [Heaps as Arrays](#heaps-as-arrays)

5. [Conclusion](#conclusion)
### Introduction

In this post I'll talk about a type data structure called heap. A heap can be thought of as an unordered binary tree where the parent is larger (max-heap) or smaller (min heap) than its children. In a heap, the largest (if max-heap) or smallest (if min-heap) element is always at the root (hence the name heap).

### Structure

There are a few properties that must hold for a heap:

- Each node satisfies the heap condition: the parent must be larger (max-heap) or smaller (min-heap) than its children
- It is a complete binary tree: meaning each level is completely filled except for the last level where new nodes are added left to right:

![Complete-Binary-Tree](images/heap/completetree.png) [Image Credit - Complete Binary Tree](https://www.wikiwand.com/en/Binary_tree)

- The height of the tree would always be $O(logN)$ where $N$ is the number of nodes
- A heap can be implemented using an array or a [tree](/binary-search-trees) data structure.

Based on the structure described above, it is easy to see that a heap should be used when the goal is to consistently remove the largest or the smallest value from a set of values.

### Heaps As Arrays

Since our heap is a complete binary tree, if we implement it as an array, we'd realize that there are no "holes" in this array. Holes would arise when there are null nodes in the middle of our tree (which would not happen for heaps). Let's have a look at what our array would look like for a specific tree:


![Tree-As-Array](images/heap/treeasarray.png) [Image Credit - Tree As Array](https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html)

We ignore the first index of the array for the purposes of convenience. If you populate the array, starting at index 1, in breadth first fashion, you'd get the array as shown above for the tree. You can generalize the following relationships between the `index` of the element (except the root) and its left child, right child and parent for 

- `leftChildIndex = index * 2`
- `rightChildIndex = (index * 2)  + 1`
- `parentIndex = index/2` 