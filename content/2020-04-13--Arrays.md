---
title: Arrays
date: 2020-04-13
thumbnail: /post-images/array.png
draft: false
extract: Intro to arrays and sample problems
categories: 
    - Problems
tags:
  - Arrays
---

### Table of Contents

1. [Introduction](#introduction)

2. [Problems](#problems)

    * [Dutch Flag](#dutch-flag)
    * [Plus One](#plus-one)
    * [Remove Duplicates from Sorted Array](#remove-duplicates-from-sorted-array)
    * [Binary Search](#binary-search)
    * [Search sorted array for first occurrence of key](#search-sorted-array-for-first-occurrence-of-key)
    * [Find first occurrence of element greater than key](#find-first-occurrence-of-element-greater-than-key)
    * [Find local minimum in an unsorted array](#find-local-minimum-in-an-unsorted-array)
    * [Find interval enclosing k](#find-interval-enclosing-k)
    * [Search sorted array for entry equal to its index](#search-sorted-array-for-entry-equal-to-its-index)
    * [Search a cyclically sorted array for minimum element](#search-a-cyclically-sorted-array-for-minimum-element)
    * [Compute integer square root](#compute-integer-square-root)
    * [Find Kth largest in array](#find-kth-largest-in-array)
    * [Find array's median](#find-arrays-median)
    
3. [Conclusion](#conclusion)
    
### Introduction

In this post I'll talk about a simple data structure called array (or vector). An array is nothing but a contiguous section of the memory where we can store homogeneous data. Since it is contiguous, we can access elements in an array via subscript notation in $O(1)$ time.

To copy a vector to another vector, you can do:

```cpp
vector<int> a = {1,2,3,4};
vector<int> b = a;
```

This would be a deep copy.

### Dutch Flag

```cpp
Write a program that takes an array A and an index i into the array.
Return the array in the order such that elements less than A[i] appear
before A[i] and elements greater than A[i] appear after A[i].
```

The idea is simple: move, the pivot to the beginning of the array. Start one pointer, `i` at index 1, another, `j` at index size - 1. Keep swapping elements of the two pointers until  `i` and `j` cross over. Then swap pivot with `j`.

```cpp
void DutchFlag(vector<int>& A, int index){
    int pivot = A[index];
    A[index] = A[0];
    A[0] = pivot;
    int i = 1;
    int j = A.size() - 1;
    while (i < j){
        while (A[i] < pivot && i < j)
            i++;
        while (A[j] > pivot && i < j)
            j--;
        
        if (i == j)
            break;
        
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
        i++;
        j--;
    }
    
    A[0] = A[j];
    A[j] = pivot;
    
}
```

This is well and good if there's only 1 value of the pivot present. For example, the above would fail if your input array was something like this:

```cpp
{0,1,2,-1,2,1,5,2,1}
```

and the pivot was 1. To solve it, you need a better approach. Here's the best approach:

Think of the array as having 4 sections:

```cpp
small -> goes from 0 till S-1
equal -> goes from S till eq
unexplored -> goes from i till large
large -> from large + 1 till size -1 
```

Basically what we're doing is shrinking the unknowns from right if value found is larger and from the left if value found is smaller than the pivot. START WITH SOMETHING THAT YOU'RE CERTAIN OF. You're trying to find what values are bigger or smaller BUT you're certain that the middle ones will stay between small and large.

Easiest way to figure out how to approach this is to look at the array when our array is like so:

```cpp
             s      eq      l             
0   -1  -2   1  1   ?   ?   ?   4   6   2       

```

Now, you want to see what `eq` is equal to. It can be:
 
**(1) less than the pivot**:

```cpp
             s      eq       l             
0   -1  -2   1  1   -3   ?   ?   4   6   2       

In this case, we need to swap eq with s and increment eq and s:

                 s       eq  l             
0   -1  -2   -3  1   1   ?   ?   4   6   2   

Notice now, everything less than s is less than the pivot: [0,s)
Everything between [s,eq) is equal to pivot  
Everything between [eq,l] is unexplored
Everything greater than l is greater than the pivot: (l, size-1]
```

**(2) greater than the pivot**:

```cpp
             s      eq       l             
0   -1  -2   1  1   7    ?   ?   4   6   2

Here, you need to swap l with eq and decrement l ONLY:

             s      eq       l             
0   -1  -2   1  1   ?    ?   7   4   6   2

That is because we've swapped an unknown with eq. 
That unknown could be less than, equal to or greater than the pivot 
so we can't move eq BUT we're 100% certain that the newly discovered
item is > pivot so we can decrement l
```

**(3) equal to the pivot**: we just move eq to the right

**POINT TO NOTE**

- Try the above with `s` not pointing to one greater than the smallest element but AT the smallest element
and see how you get errors when you start out your iteration when eq and s both point to the first element which is smaller than the pivot. 

So, this is how it is right now: (with pivot being 1)

```cpp
          s 
[-1,-2,-3,1,1,1,4,5,6]

```

If you have this:

```cpp
        s 
[-1,-2,-3,1,1,1,4,5,6]
```

There'll be A LOT of headache and ugly code!

Usually if you find yourself writing ugly code, try moving the boundaries. Like I did above, I moved the `s` boundary to smallest + 1 index. That way, even if my first element is smaller than the pivot, I don't need to make special modifications or add extra checks to the algorithm

### Plus One
**Given a non-empty array of digits representing a non-negative integer, plus one to the integer.
The digits are stored such that the most significant digit is at the head of the list,
 and each element in the array contain a single digit.
You may assume the integer does not contain any leading zero, except the number 0 itself.**

This is a simple one. The only trick is that if you're given a 999 and you add 1 to make it a 1000, what would you do since you're out of space in the array? Well:

```cpp
999
000
```

That isn't right, so you need to change the first element to 1 and push_back a 0:

```cpp
999
1000
```
```cpp
    vector<int> plusOne(vector<int>& digits) {
        int i = int(digits.size()) - 1;
        bool carry = true;

        while (i >= 0){
            int curr = digits[i];
            if (carry){
                curr += 1;
                if (curr == 10){
                    digits[i] = 0;
                } else {
                    digits[i] = curr;
                    carry = false;
                }
            }
            i--;
        }

        if (carry){
            digits[0] = 1;
            digits.push_back(0);
        }

        return digits;
    }
```

Also, for other similar questions, if the number is too large, converting it to an integer and then performing some operation might not be feasible. So the best approach is to keep the integer in the array and perform operations on it.

### Remove duplicates from sorted array

**Given a sorted array, remove duplicates from the array.** Example: {2,2,3,4,5,5,5,6,6,7} should return {2,3,4,5,6,7}.

Here's a naive approach:

```cpp{numberLines: true}
vector<int> RemoveDupsNaive(vector<int>& A){
    int prev = A[0];
    vector<int> un;
    un.push_back(prev);
    for (int i = 0; i < A.size(); i++){
        while (A[i] == prev)
            i++;
        prev = A[i];
        un.push_back(prev);
    }
    return un;
}
```

In this approach, we simply create a new array called `un` (for unique) and push the first element to it. We then keep iterating over the array until we find all elements that are equal to the recently pushed element. As soon as we find an element from that is different from the recently pushed element, we break and push this new element. We repeat until we're past the end of the original array. We then return the `un` array. This approach takes $O(N)$ time since we iterate over the array once BUT it takes $O(N)$ space for the new array.

A better approach is to keep track of the position where we're going to add the new element. For example, if we have this array:

```cpp
i               
2   2   2   2   3   3   4   4   4   5   6
```

and `i` is at position 0, we start another pointer at `i` and call it `j`. Now, while `A[j]` is equal to `A[i]` (while we're encountering duplicates), we keep incrementing `j`:
 
 ```cpp
 i               j
 2   2   2   2   3   3   4   4   4   5   6
 ```

Once `j` gets to `A[4]`, a new element has been found. We can then place this element in position, `i+1` and increment `i`.

 ```cpp
     i           j
 2   3   2   2   3   3   4   4   4   5   6
    i+1    
 ```

Now, again, while `A[j]` is equal to `A[i]` (while we're encountering duplicates), we keep incrementing `j`. We keep doing this until `j` is at the end of the array. We then erase the all extra elements after `i`. Here's the code:

```cpp
vector<int> RemoveDupsBest(vector<int>& A){
    int i = 0;
    int j = 0;
    while (j < A.size()){
        while (A[i] == A[j] && j < A.size())
            j++;
        if (j > A.size())
            break;
        A[i+1] = A[j];
        i++;
    }
    vector<int>::iterator itr;
    itr = A.begin() + i;
    while (itr != A.end()){
        itr = A.erase(itr);
    }
        
    return A;
}
```

This approach takes $O(N)$ time and $O(1)$ space.

**Variant:Write a program that takes an array of integers and finds the length of a longest subarray all of whose entries are equal.**

Example: {9,9,6,6,6,1,1,1,1} should return 4 since the longest subarray with equal entries is 4 - 1,1,1,1.

```cpp
int LongestSubarrayWithEqualEntries(vector<int>& A){
    int i = 0;
    int max = 0;
    while (i < A.size()){
        int curr = A[i];
        int count = 0;
        while (A[i] == curr && i < A.size()){ //NOTICE THIS EXTRA CHECK
            i++; count++;
        }
        if (count > max)
            max = count;
    }
    
    return max;
}
```

The solution is quite intuitive. It takes $O(N)$ time. Also, notice the extra check. Even though we've got an outer size check, if the array comprises of entries that are ALL the same, we'd run off the end of the array.

### Binary Search

Let's talk about a searching algorithm commonly associated with arrays, called Binary Search. The idea behind binary search is to search whether a value, say `k`, exists in a sorted array. To do so, binary search performs the following tests:

(1) Maintain 3 pointers in an array: `lo`, `mid` and `hi`.

(2) Initially, assign `lo` to 0, `hi` to `A.size() - 1` and calculate mid via this formula:

$$$

mid = lo + ((hi - lo)/2)

$$$

(3) Check what the value of `mid` is:
 
 - If `A[mid] < k` then our value lies somewhere between `mid + 1` and `hi`. We know this for a fact because the array is sorted.
 - If `A[mid] == k` then we've found our value, we can return the index.
 - If `A[mid] > k` then our value lies somewhere between `lo` and `mid - 1`. We know this for a fact because the array is sorted.

(4) We then recalculate the value for `mid` after each search operation and perform the checks in (3) again. We continue this process until we either find the element or until we realize that the array doesn't have the element we're looking for.

### Illustration : Value exists in array
Let's say that this is what our sorted array looks like initially:

```cpp
[2,5,6,9,11,13,21,25,31,49]
```



and we're searching for the element `25` (x = 25) in this array. Initially, our variables (I've substituted `l` for low, `m` for mid and `h` for high) would be calculated like this: (keep in mind that these variables are array indices): 

`low` would be 0 

`high` would be one less than size of array

`mid` would be `low + [(high - low)/2]`

```cpp
[2, 5, 6, 9, 11, 13, 21, 25, 31, 49]
 l           m                    h
```

We realize that `A[mid] < x` so we can discard all elements to the left of `m` and make `m + 1` our new `l`. Our `h` remains unchanged. So, this is what our array looks like now:

```cpp
[2, 5, 6, 9, 11, 13, 21, 25, 31, 49]
                  l               h
```

To calculate `m`, we do: `5 + [(9 - 5)/2]` which equals 7. Therefore, now we have:

```cpp
[2, 5, 6, 9, 11, 13, 21, 25, 31, 49]
                  l      m        h
```

We then compare `A[mid]` with `k` and we find that `m` has the value `k` and we return the value `m` (which is the index 7).

### Illustration : Value not in array

Let's continue our operations and say that we're searching for `x = 39`. Steps up to this point from the previous section still hold for this case. So, as of now, this is what our array looks like:

```cpp
[2, 5, 6, 9, 11, 13, 21, 25, 31, 49]
                  l      m        h
```

We find that `A[mid] < k` so we make `m + 1` our new `l` and recalculate `m` to get this:

```cpp
[2, 5, 6, 9, 11, 13, 21, 25, 31, 49]
                             lm   h
```

We again compare `A[mid]` with `k` and find `A[mid] < k` so we make `m + 1` our new `l` and keep `h` as is. We now have our pointers in the following positions:

```cpp
[2, 5, 6, 9, 11, 13, 21, 25, 31, 49]
                                 lh
```

Now, to calculate `m` we do the following:

`low + [(high - low)/2]`

`9 + [(9 - 9)/2]` which makes `m = 9`. We see that `A[mid] > k` so we make `m - 1` our new `h` and keep `l` as is. This is the first time we've noticed that `h` has become less than `l` because this is what our array looks like now:

```cpp
[2, 5, 6, 9, 11, 13, 21, 25, 31, 49]
                              h   l
```

We've realized that we do not have the element in the array so we can break out. Therefore, our binary search algorithm ends either when we find the element or when `l` becomes greater than `h` and we return the value `-1` indicating that the value doesn't exist in the array.



### Code

You can copy and paste this implementation in your IDE and this should work without any issues but I'd rather you understand what is going on. Here is my version of binary search:

```cpp {numberLines: true}
int BinarySearch(vector<int>& A, int k){
    int lo = 0, hi = int(A.size()) - 1, ans = -1;
    
    while (lo <= hi){
        int mid = lo + ((hi - lo)/2);
        if (A[mid] < k){
            //A[mid] < k so ans lies between mid+1 and hi so move lo up
            lo = mid + 1;
        } else if (A[mid] == k){
            ans = mid;
            break;
        } else {
            //ans lies between lo and mid so move hi down
            hi = mid - 1;
        }
    }
    
    return ans;
}

```

### Explanation

Inside the function we start with initializing the values for `lo`, `hi` and `ans` where `ans` would ultimately hold the value for the index where we found the element or -1 if element not found. 

Next, while `lo <= hi`, we process what's inside the loop:

- calculate mid for each iteration based on where lo and hi are
- compare value in mid and determine what to move: lo up or hi down
- if mid has the value, break and return the index
- continue until the while loop condition holds or value is found

### Analysis

Binary search takes $O(logN)$ time to search. Instead of memorizing this run time, it is easy to see why that is the case:

On each iteration, we're approximately halving the number of elements we need to search. In the [value not in array](#illustration--value-not-in-array) section, we start out with 10 elements. Once we realize that `array[mid] < k`, we discard the left half and search the right half. In doing so, we've reduced our elements from 10 to 5. We could keep going until we only have one element left to inspect or when `low` becomes greater than `high`. 

For better illustration, here is how we reduce our array's size:

```cpp
[2, 5, 6, 9, 11, 13, 21, 25, 31, 49]
 l           m                    h
```

```cpp
[.............., 13, 21, 25, 31, 49]
                  l      m        h
```

```cpp
[.........................., 31, 49]
                             lm   h
```

```cpp
[.............................., 49]
                                 lh
```

So for 10 elements, we halved our array 3 times. We can extrapolate this to see how our halving would pan out with say `n = 32` elements and our elements are numbers 1 till 32 in increasing order. Also assume we're searching for the element 3, then this is how our search would proceed: (asterisks are elements that we've NOT discarded yet)

```cpp
[l,***************,m,****************,h]    32
```

```cpp
[l,******,m,*********,h,...............]    32/2
```

```cpp
[l,****,m,****,h,......................]    16/2
```

```cpp
[l,**,m,**,h,..........................]   8/2
```

```cpp
[l,*,m,*,h,............................]   4/2
```

```cpp
[.,l,m,h,..............................]   2/2
```

Our search is guaranteed to return a result (of either -1 if element not found or index of element if found when we're down to just 1 element). 

Mathematically, we're asking, how many times would we have to halve an array with 32 elements to be guaranteed a result (when the array has only 1 element under consideration)?

$
32 * (1/2)^K = 1 
$

$
32 * 1/2^K = 1
$

$
32 = 2^K
$

Using the following log rule:

$
b = a^n
$


$lg$<sub>$a$</sub>$b = n$

we can conclude:

$lg$<sub>$2$</sub>$32 = K$ thus $K = 5$ 

This means that we'd have to break down our 32 element array at most 5 times to get to an answer. 

Therefore, we can generalize 

$lg$<sub>$2$</sub>$32 = K$ thus $K = 5$ 

to:

$lg$<sub>$2$</sub>$N = K$ where $N$ is the number of elements in our array. 

We can finally conclude that at most, our binary search algorithm would have to run 

$lg$<sub>$2$</sub>$N$ times depending on the number of elements in our array.


### Problems

Before we begin, let's understand the C++ STL implementation and usage for binary search. If allowed, use these functions to perform binary search instead of using your own. (You need to import `algorithm` header)

- Find if element is present: 
```cpp
binary_search(A.begin(), A.end(), target) 
```
returns true if target present, false otherwise

- Find first element >= target:

```cpp
lower_bound(A.begin(), A.end(), target) 
``` 

- Find first element > target:

```cpp
upper_bound(A.begin(), A.end(), target)
```

### Search sorted array for first occurrence of key

**Write a method that takes a sorted array and a key and returns the index of the first occurrence of that key in the array. For example, when applied to the array in figure below your algorithm should return 3 if the given key is 108; if it is 285, your algorithm should return 6.**

```cpp

-14     -10     2       108     108     243     285     285     285     401
A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

Naive approach: start at index 0 and iterate over the array until you find the element. This takes $O(N)$ time and doesn't make use of the fact that the array is sorted. 

Better but still not perfect: Use binary search until you find an element with the value you're searching for. Once you've found that element, keep moving back until you've found the first occurrence. This again takes $O(N)$ time if the entire array is made up of the same element. In both approaches, naive and this approach, we're not making use of the fact that we can go all the way to just a single element by repeatedly making use of binary search's break array in half property.

Best approach: Let's say you're searching for 285 in the array above. Here are the pointers before we begin processing the array:


```cpp
ans = -1
lo                              mid                                     hi
-14     -10     2       108     108     243     285     285     285     401
A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

we notice that `A[mid] < k` so make `lo = mid + 1` and recalculate mid:

```cpp
ans = 7
                                        lo              mid              hi
-14     -10     2       108     108     243     285     285     285     401
A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

in the diagram above, it is clear that we've found the element, BUT, we're searching for the first occurrence. As far as we know, this might be the first occurrence. At this point, we're ONLY concerned with looking for 285 to the LEFT of `mid` because that is where 285's first occurrence would be if there were any. 

So, for now, we record where we found k in the variable ans (`ans = mid`). This is where this better approach differs from approach 2 above. The approach above said, as soon as you find the element, break and keep moving left one element at a time. This better approach says, no, instead of moving one element at a time, keep going down as if you're still searching for `k`.
 
 Therefore, we move `hi` down so that we can search elements preceding `mid` for the first occurrence of `k`. So now, our new pointers would be:
 
 ```cpp
 ans = 7
                                         lo       hi
 -14     -10     2       108     108     243     285     285     285     401
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
 ```
 
Again we recalculate mid which now equals 5:

 ```cpp
 ans = 7
                                         mid
                                         lo       hi
 -14     -10     2       108     108     243     285     285     285     401
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
 ```

Now, `A[mid] < k` so we make `lo = mid + 1`:
 ```cpp
 ans = 7
                                                  lo  
                                         mid      hi
 -14     -10     2       108     108     243     285     285     285     401
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
 ```

We recalculate mid which now equals: 6. At this point our pointers look like so:

 ```cpp
 ans = 7                                          mid
                                                  lo  
                                                  hi
 -14     -10     2       108     108     243     285     285     285     401
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
 ```

Our logic sees that `A[mid] == k` so we update `ans = mid`. Now, again, our logic is that when a match is found and we're looking for the first occurrence, make `hi = mid - 1`. So, we update `hi` while `mid` and `lo` stay as is:

 ```cpp
 ans = 6                                          mid
                                          hi      lo  
 -14     -10     2       108     108     243     285     285     285     401
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
 ```

This is the first time `hi` becomes less than `lo` which invalidates the while loop condition. So we exit the loop and return the updated `ans` value. 

Notice that the number of times we had to operate in the loop equals 4 which is on the order of $O(logN)$ where $N$ is the number of elements. This means, if there were a 1000 sorted elements and we were looking to find the first of a random number in that sorted sequence, at MOST it would take us 10 iterations because $2^{10}$ = $1024$

Here's the implementation:  

```cpp
int FindFirstOfK(vector<int>& A, int k){
    int lo = 0, hi = int(A.size()) - 1, ans = -1;
    
    while (lo <= hi){
        int mid = lo + ((hi - lo)/2);
        if (A[mid] > k){
            //ans lies between lo and mid
            hi = mid - 1;
        } else if (A[mid] == k){
            ans = mid;
            hi = mid - 1;
        } else {
            //A[mid] < k so ans lies between mid+1 and hi
            lo = mid + 1;
        }
    }
    
    return ans;
}
```

Running time: $O(logN)$

### Find first occurrence of element greater than key

**Design an efficient algorithm that takes a sorted array and a key, and finds the index of the first occurrence of an element greater than that key.For example, when applied to the array shown below, your algorithm should return 9 if the key is 285; if it is -13, your algorithm should return 1.**

```cpp

-14     -10     2       108     108     243     285     285     285     401
A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

This problem seems similar to the previous problem but start solving on paper and you'd realize how wrong you are! First notice that this problem states that if the key is -13 (not present in the array), you should return 1. That is because the first element > -13 is 10 which is at `A[1]`. This means that returning a -1 is not an option. Also, the problem says that if key is 285, it should return 9 since 401 is the next largest in the array.

- Naive approach: same as what we had for previous problem. Inefficient
- Better approach: same as what we had for prev problem. We can do better
- Keep halving and searching until lo and hi cross over. Let's look at this in more detail

Let's say we're searching for next largest after 285. The solution is very similar to what we had for the previous problem:

```cpp
int FindFirstOfGreaterThanK(vector<int>& A, int k){
    int lo = 0, hi = int(A.size()) - 1, ans = -1;
    
    while (lo <= hi){
        int mid = lo + ((hi - lo)/2);
        if (A[mid] > k){
            //ans lies between lo and mid
            hi = mid - 1;
        } else if (A[mid] == k){
            ans = mid + 1; //---->CHANGE
            lo = mid + 1; //---->CHANGE
        } else {
            //A[mid] < k so ans lies between mid+1 and hi
            lo = mid + 1;
        }
    }
    
    return ans;
}
```

Notice the change in logic if we find a match. Let's see why that is. Say we're going about looking for `k = 285`. We find that `A[mid] == k` at say index 6. Now, at this point, we're not sure if this is the only 285 present in the array. So, we mark our answer as `mid + 1`. 

Now, we want to search in the half to the RIGHT of mid to see if we can find any more 285s. We're not concerned with the left half because we're looking for the first element GREATER than `k` not less than. If we were looking for less than `k`, we would've looked in the left half. Once we move up our `lo` to `mid + 1` we continue processing. 

Another scenario we haven't considered is the one where the key is not present in the array. For example, k = -13. In that case, the algorithm that we have right now would return -1 which is incorrect. To correct for that, we make a simple observation: when `hi` and `lo` cross over, `lo` would point to the next largest element if the element is not present in the array. You can play around with it on a piece of paper to make sure that is the case! 

Having said that, this is what our final algorithm would look like:

```cpp
int FindFirstOfGreaterThanK(vector<int>& A, int k){
    int lo = 0, hi = int(A.size()) - 1, ans = -1;
    
    while (lo <= hi){
        int mid = lo + ((hi - lo)/2);
        if (A[mid] < k){
            lo = mid + 1;
        } else if (A[mid] == k){
            ans = mid + 1;
            lo = mid + 1;
        } else {
            hi = mid - 1;
        }
    }
    if (ans == -1)
        return lo;
    
    return ans;
}
```

Running time is the same as that of binary search: $O(logN)$

### Find local minimum in an unsorted array
 
 **Let A be an unsorted array of n integers, with A[0] > A[l] and A[n - 2] < A[n - 1]. Call an index i a local minimum if A[i\ is less than or equal to its neighbors. How would you efficiently find a local minimum, if one exists?**
 
 Example:
 
```cpp

 23      -10     12      118     108     23      15      17      19      1
A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

Local minimum in the array above are at A[1], A[6] and A[9]. That is because:
- -10 < 23 and 12
-  15 < 23 and 17
- 1 < 19 and it is at the edge of the array 

Approach 1: First approach that comes to mind is to use 3 pointers, `lo`, `mid`, `hi` that point to A[0], A[1] and A[2] initially. At each step we check to see if `lo` < `mid` and `hi`. If so, we've found our minimum and return `lo`. Otherwise we increment each pointer by 1 position to the right and then perform the check again. Running time: $O(N)$

Approach 2: How can we improve on $O(N)$? Let's see if binary search can help here even though the array is unsorted. Let's have `lo` at A[0] initially, `m` at A[4] and `hi` at A[9]:

```cpp
 lo                               m                                      hi
 23      -10     12      118     108     23      15      17      19      1
A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

- If A[m] > A[m-1] then we MIGHT have our minimum in the left half of the array. That is because we know that A[m-1] < A[m] and A[m-2] might be > A[m-1] making A[m-1] our minimum. So we make `m - 1` our new `hi`.

- If A[m] > A[m+1] then we MIGHT have our minimum in the right half of the array. That is because A[m+2] might be > A[m+1] as well making A[m+1] our minimum. So we make `m + 1` our new `lo`.

In both scenarios above we've discarded half the array. 

Let's step through the example array and see how it pans out:

 ```cpp
  lo                               m                                      hi
  23      -10     12      118     108     23      15      17      19      1
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]

A[m] > A[m+1], make lo = m - 1 and recalculate m:


                           lo                      m                      hi
  23      -10     12      118     108     23      15      17      19      1
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9] 


Is A[m] > A[m-1] ? No, is A[m] > A[m+1]? No, we've found our minimum! Return m 

 ```

Now, we need to figure out when our algorithm should stop, consider this scenario:

```cpp
  lo                               m                                      hi
  1        2       3       4       5      6        7       8      9       10
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]

A[m] > A[m-1], make m - 1 our new hi and recalcuate m:

  lo       m               hi                                              
  1        2       3       4       5      6        7       8      9       10
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]

A[m] > A[m-1], make m - 1 our new hi and recalcuate m:

  m
  hi
  lo                                                           
  1        2       3       4       5      6        7       8      9       10
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]

Now what? There's no A[m-1], so we can break and return m since A[m] < A[m+1] making A[m] the local minimum.

```

This scenario above also applies to the array when it is sorted in decreasing order where our minimum would be A[N]. So, we exit when we've either found a minimum or m-1 < 0 or m+1 > size of our array.

```cpp
int FindLocalMinimum(vector<int>& A){
    int lo = 0;
    int size = int(A.size()) - 1;
    int hi = size;
    int m = lo + ((hi - lo) / 2);
    while ((m - 1) >= 0 && (m + 1) <= size){
        if (A[m] > A[m-1]){
            hi = m - 1;
        } else if (A[m] > A[m+1]){
            lo = m + 1;
        } else {
            break;
        }
        m = lo + ((hi - lo) / 2);
    }
    
    return m;
}
``` 

Running time is the same as binary search $O(lgN)$.

### Find interval enclosing k

**Write a program which takes a sorted array A of integers, and an integer k, and returns the interval enclosing k, i.e., the pair of integers L and U such that L is the first occurrence of k in A and U is the last occurrence of k in A. If k does not appear in A, return [-1,-1], For example if A = (1,2,2,4,4,4,7,11,11,13) and k = 11, you should return [7,8].**

Approach 1: Use binary search to find k, then move left and right until you've found the upper and lower bounds. Running time: $O(N)$

Approach 2: Use binary search to find k, then once k is found, continue using binary search to find upper and lower bounds using binary search. Running time: $O(lgN)$.

Say our array is as shown below and key is `4`:

```cpp
  lo                               m                                      hi   
  1        2       3       4       4      4        4       8      9       10
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

A[m] == key, search for lower bound in left half and upper bound in right half. Let's break the array like so. Left half is from: `lo` till `m-1` and right half is `m+1` till `hi`.

```cpp
  lo                       hi   |            lo                                hi   
  1        2       3       4    |     4      4        4       8      9       10
 A[0]    A[1]    A[2]    A[3]   |   A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

Let's look at the lower half first to find the lower bound. As usual, calculate `m` and see if it is < key. If so, make lo equal `m + 1`. We don't need to check for `m` > key since we know any value to the left has to be equal to or less than the key in the lower half. Keep doing it until lo and hi cross over. Then return the lowest index where you found an occurrence of the key. This will be done via a function called `findLo`:

```cpp
int findLo(int lo, int hi, int k, vector<int>& A){
    //Get the lower bound:
    int ans = -1;
    while (lo <= hi){
        int m = lo + ((hi - lo)/2);
        if (A[m] < k){
            lo = m + 1;
        } else {
            ans = m;
            hi = m - 1;
        }
    }
    
    return ans;
}
```

Do the same in the upper half to find the upper bound. As usual, calculate `m`. If A[m] > key, make hi equal `m - 1` and continue. Once done, return the highest index where you found an occurrence of the key. This will be done via a function called `findHi`:

```cpp
int findHi(int lo, int hi, int k, vector<int>& A){
    //Get the upper bound:
    int ans = -1;
    while (lo <= hi){
        int m = lo + ((hi - lo)/2);
        if (A[m] > k){
            hi = m - 1;
        } else {
            ans = m;
            lo = m + 1;
        }
    }
    
    return ans;
}
```

Finally, putting it all together:

```cpp
vector<int> Interval(vector<int>& A,int k){
    vector<int> ans = {-1,-1};
    int lo = 0;
    int hi = int(A.size()) - 1;
    
    while (lo <= hi){
        int m = lo + ((hi - lo)/2);
        if (A[m] < k){
            lo = m+1;
        } else if (A[m] > k){
            hi = m-1;
        } else {
            //found it, get interval
            ans[0] = m;
            ans[1] = m;
            int lb = findLo(lo, m-1, k, A);
            int ub = findHi(m+1, hi, k, A);
            if (lb != -1){
                ans[0] = lb;
            }
            if (ub != -1){
                ans[1] = ub;
            }
            break;
        }
    }
    return ans;
}
```

Running time is $O(logN)$.

### Search sorted array for entry equal to its index

**Design an efficient algorithm that takes a sorted array of distinct integers, and returns an index i such that the element at index i equals i. For example, when the input is (-2,0,2,3,6,7,9)your algorithm should return 2 or 3.**

Approach 1: Ignoring that the array is already sorted, iterate over the array and keep checking value at each index. As soon as A[i] = i, return. Running time is $O(N)$. 

Approach 2: Array is sorted, we can use binary search: The only thing that changes is the fact that there's no "key" to search for. Instead of a key, we check if A[m] < m or if A[m] > m.

Example:

```cpp
  lo                               m                                      hi   
  -1       0       2       4       5      6        8      18      19      20
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

Here's the logic: Compare value at A[m] and m itself. In the example above, A[m] = 5 and m = 4. So, our answer cannot lie to the right of m since m is already smaller than A[m] and since the array is sorted, A[m] is only going to increase to the right of m. The opposite also holds if A[m] < m.

Translating that to code:

```cpp
int GetIndex(vector<int>& A){
    int ans = -1;
    int lo = 0;
    int hi = int(A.size()) - 1;
    while (lo <= hi){
        int m = lo + ((hi - lo)/ 2);
        if (A[m] < m){
            lo = m + 1;
        } else if (A[m] > m){
            hi = m - 1;
        } else {
            ans = m;
            break;
        }
    }
    return ans;
}
```

Running time: $O(logN)$

### Search a cyclically sorted array for minimum element

**An array is said to be cyclically sorted if it is possible to cyclically shift its entries so that it becomes sorted. Design an $O(logN)$ algorithm for finding the position of the smallest element in a cyclically sorted array. Assume all elements are distinct.**

Example: 

```cpp
  12      22      33      44      54       5       6       9      11      13
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

should return 5 because A[5] has the smallest value. 

Approach 1: Iterate over array and return the smallest element: $O(N)$

Approach 2: The array is cyclically sorted so there is some order in the array and we can take advantage of that. For example, here're our pointers:

```cpp
  lo                              m                                       hi  
  12      22      33      44      54       5       6       9      11      13
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]
```

We can confirm these:

- If A[m] > A[hi] then the lowest element must be somewhere between A[m+1] and A[hi] (A[hi] inclusive). In this case, make `lo = m + 1`
- If A[m] < A[lo] then lowest element must be somewhere between A[lo] and A[m] (A[m] inclusive). In this case make `hi = m`

Repeat until we find the element. Let's walk through the example above:

```cpp
  lo                              m                                       hi  
  12      22      33      44      54       5       6       9      11      13
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]

A[m] > A[hi] look to right of m:

                                           lo                             hi  
  12      22      33      44      54       5       6       9      11      13
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]

recalculate m:

                                           lo              m               hi  
  12      22      33      44      54       5       6       9      11      13
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]    A[9]

A[m] > A[hi] ? No,
A[m] < A[lo] ? No,
Then we've found our answer, it is lo!
Return lo
```

Another example:

```cpp
  lo                              m                                hi 
  10      11      12      13      14      22      33       4       5       
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]

A[m] > A[hi], yes, lowest must be somewhere between A[m+1] and A[hi], make lo = m + 1 and recalculate m:

                                          lo      m                hi 
  10      11      12      13      14      22      33       4       5       
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]

A[m] > A[hi], yes, lowest must be somewhere between A[m+1] and A[hi], make lo = m + 1 and recalculate m:

                                                           m
                                                           lo      hi 
  10      11      12      13      14      22      33       4       5       
 A[0]    A[1]    A[2]    A[3]    A[4]    A[5]    A[6]    A[7]    A[8]


A[m] > A[hi]? No
A[m] < A[lo]? No
We've found our answer, return lo!
```

Code:

```cpp
int Search(vector<int> A){
    int lo = 0;
    int hi = int(A.size()) - 1;
    int ans = -1;
    while (lo <= hi){
        int m = lo + ((hi - lo)/2);
        cout << "lo: " << A[lo] << " m: " << A[m] << " hi: " << A[hi] << endl;
        if (A[m] > A[hi]){
            lo = m + 1;
        } else if (A[m] < A[lo]){
            hi = m;
        } else {
            ans = lo;
            break;
        }
    }
    return ans;
}
```

Running time same as binary search: $O(logN)$.

### Compute integer square root

**Write a program which takes a non-negative integer and returns the largest integer whose square is less than or equal to the given integer. For example, if the input is 16, return 4; if the input is 300, return 17, since 172 = 289 < 300 and 182 = 324 > 300.**

Approach 1: Start at 1 and keep checking if the number squared < key. If so, increment by 1 and perform the check until number squared > key. Then answer is curr - 1. Running time: $O(N^{1/2})$

Approach 2: Start by picking a range from 0 till K and calculate `m`, `lo` and `hi`. 

If $m^{2}$ is less than k, make `lo = m + 1`

If $m^{2}$ is greater than k, make `hi = m - 1`

If $m^{2}$ is equal to k, it means that we were given a perfect square (16,25,49 etc), so return `m`

Finally, if `m` never equals k and `lo` and `hi` cross over, return `hi` as the answer.

```cpp
int getSquareRoot(int k){
    int lo = 0;
    int hi = k;
    int ans = -1;
    while (lo <= hi){
        int m = lo + ((hi - lo)/2);
        long long sq = m * m;
        cout << "lo: " << lo << " m: " << m << " hi: " << hi << " sq: " << sq << endl;
        if (sq > k){
            hi = m - 1;
        } else if (sq < k){
            lo = m + 1;
        } else {
            ans = m;
            break;
        }
    }
    if (ans == - 1)
        ans = hi;
    return ans;
}
```

Running time: $O(logK)$ where `k` is the key passed in.

### Find Kth Largest in array

**Find the Kth largest value in array**.

Example:

```cpp

1   3   2   4   8   7   6   5

1st Largest = 8
2nd Largest = 7
3rd Largest = 6
4th Largest = 5
5th Largest = 4
6th Largest = 3
7th Largest = 2
8th Largest = 1
```

Approach 1: Sort the array and count from end of the array to return kth largest: running time $O(Nlog N)$. Running time is good but is wasteful. For example, if we want to find the 1st largest value, we can just do a single pass of the array and return the largest element: running time is $O(N)$. 

Approach 2: Use min-heap and repeatedly remove element from the heap until you get to the Kth largest. Again, running time $O(NlogN)$ but requires extra space

Approach 3: See if binary search or pivoting can be used. Binary search is of no help since we're unaware of the value against which we must compare. Pivoting? Let's see:

- Say if we choose a pivot. How would we know what to pick? Let's pick a random element from the array and re-arrange the array, like we did for the problem [Dutch Flag](#dutch-flag). Let's use the example array above and say we're searching for the 5th largest element (which is 4). Let's say we randomly pick an element as pivot and that element is 4 as well:

```cpp
1   3   2   4   8   7   6   5
```

Now after we've moved elements around in the array based on the pivot, our array would look like this:

```cpp
1   3   2   4   7   6   5   8
```

Now what? Let's see, we're looking for the 5th largest element right? If the pivot we chose is the 5th largest, it should have K - 1 (5 - 1) elements to its right. This should be quite easy to understand. If 4 is the 5th largest element, then in an array sorted (or pivoted!) around 4 would have 4 elements after 4 and remaining elements before 4:

```
Remaining before 4
---------|
1   2   3   4   5   6   7   8
               |--------------> 4 elements after 4 
``` 

Now, let's say we were actually looking for the 6th largest element. Now, if 4 were the 6th largest element, it would have 6 - 1 = 5 elements to its right. However, 4 has 4 elements to its right after we pivot:

```cpp
1   3   2   4   7   6   5   8
```
Therefore, we can discard all elements to the right of 4 (including 4) since we know the 6th largest element can't be to its right. If we were looking for 2nd largest element, then we can discard all elements to the left of 4 (including 4) since it can't be in that section based off what we know about 4. We then pick a pivot from the middle of our newly determined section and repeat. We repeat until we've found our answer.

On each step, we're roughly halving the size of the array we're searching.

Here's the code `findKthLargestInArray`

```cpp
int PartitionAround(vector<int>& A, int i, int j){
    //Median of three pivot calculation
    int pivot = i + ((j - i)/2);
    int temp = A[i];
    A[i] = A[pivot];
    A[pivot] = temp;
    pivot = i;
    i++;
    
    while (true){
        while (A[i] < A[pivot] && i <= j)
            i++;
        
        while (A[j] > A[pivot] && j >= i)
            j--;
        
        if (i >= j){
            int temp = A[pivot];
            A[pivot] = A[j];
            A[j] = temp;
            break;
        }
        
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
        i++;
        j--;
    }
    cout << "Returning index " << j << " which has: " << A[j] << endl;
    return j;
}


int finalAns(vector<int>& A, int KthLargest){
    int s = 0, l = int(A.size()) - 1;
    int finalAns = -1;
    int size = int(A.size());
    while (true){
        int pivAns = PartitionAround(A, s, l);
        cout << "pivAns: " << pivAns << endl;
        if ((size - pivAns) == KthLargest){
            cout << "Found it!" << endl;
            finalAns = A[pivAns];
            break;
        }
        if ((size - pivAns) > KthLargest){
            //look in right half:
            cout << "looking in right half" << endl;
            s = pivAns + 1;
        } else {
            //look in right half:
            l = pivAns - 1;
        }
    }
    
    return finalAns;
}

int main(int argc, const char * argv[]) {
    // insert code here...
    vector<int> A = {1,5,6,4,3,2,7,8};
    //Pass the array and the value for K here:
    int ans = finalAns(A, 8);
    cout << ans << endl;
    return 0;
}
```

This partition function assumes there might be duplicates in the array. If there are no duplicates, then the partition function is the same as what is used in the [quicksort](/quick-sort#logic) algorithm.

### Find array's median

Same logic and code as the previous problem except that now instead of passing value for `k`, you need to pass the value that equals half of the array's size. Then, return the element instead of the index:

```cpp
int finalAns(vector<int>& A, int KthLargest){
    int s = 0, l = int(A.size()) - 1;
    int finalAns = -1;
    int size = int(A.size());
    while (true){
        int pivAns = PartitionAround(A, s, l);
        cout << "pivAns: " << pivAns << endl;
        cout << "size - pivans = " << size - pivAns << endl;
        if ((size - pivAns) == KthLargest){
            cout << "Found it!" << endl;
            finalAns = pivAns; // Return element instead of index
            break;
        }
        if ((size - pivAns) > KthLargest){
            //look in right half:
            cout << "looking in right half" << endl;
            s = pivAns + 1;
        } else {
            //look in right half:
            l = pivAns - 1;
        }
    }
    
    return finalAns;
}
```

### Conclusion

- If it is an array problem, see if you can use: 
    - Binary search
    - Pivot strategy
- If the array is sorted, you can use binary search to find your element in $O(logN)$ time.
- If the array is NOT sorted, you can still use binary search for various operations that would again reduce your running time from $O(N)$ to $O(logN)$ like in [this](/binary-search#find-local-minimum-in-an-unsorted-array) problem. Whenever there's an array search problem, start out with binary search!
- Binary Search searches in $O(lgN)$ time where $N$ is the number elements in **sorted** array. This means that the search has to perform **1** more step when the input size increases by a power of 2. Which is why, it would take at most 20 operations for binary search to find an element in an array with $1,000,000$ (million) elements since $2^{20}$ is $1,048,576$.
