---
title: TODO Problems
date: 2020-05-14
thumbnail: /post-images/todo.png
draft: false
extract: TODO problems
categories: 
    - General
tags:
    - TODO Problems
---


### TODO
- [Top problems](https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU):

#### Arrays

- [Two Sum](https://leetcode.com/problems/two-sum/)
- [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)
- [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)
- [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)
- [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)
- [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
- [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
- [3Sum](https://leetcode.com/problems/3sum/)
- [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
- [Maximum sum of non-overlapping subarrays](https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)
- [Missing element in sorted array](https://leetcode.com/problems/missing-element-in-sorted-array/)

---

#### Bit Manipulation

- [Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/)
- [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
- [Counting Bits](https://leetcode.com/problems/counting-bits/)
- [Missing Number](https://leetcode.com/problems/missing-number/)
- [Reverse Bits](https://leetcode.com/problems/reverse-bits/)

---

#### Dynamic Programming

- [Frog Jump](https://leetcode.com/contest/leetcode-weekly-contest-5/problems/frog-jump/)
- [Minimum Cost for Tickets](https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/552/week-4-august-22nd-august-28th/3436/)
- [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
- [Coin Change](https://leetcode.com/problems/coin-change/)
- [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)
- Longest Common Subsequence
- [Word Break Problem](https://leetcode.com/problems/word-break/)
- [Combination Sum](https://leetcode.com/problems/combination-sum-iv/)
- [House Robber](https://leetcode.com/problems/house-robber/)
- [House Robber II](https://leetcode.com/problems/house-robber-ii/)
- [Decode Ways](https://leetcode.com/problems/decode-ways/)
- [Unique Paths](https://leetcode.com/problems/unique-paths/)
- [Jump Game](https://leetcode.com/problems/jump-game/)
- Scrambled String
- [Rusian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes/)

---

#### Graph

- [Clone Graph](https://leetcode.com/problems/clone-graph/)
- [Course Schedule](https://leetcode.com/problems/course-schedule/)
- [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)
- [Number of Islands](https://leetcode.com/problems/number-of-islands/)
- [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)
- [Alien Dictionary](https://leetcode.com/problems/alien-dictionary/)
- [Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/)
- [Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)
- [Closest Leaf node](https://leetcode.com/problems/closest-leaf-in-a-binary-tree/)

---

#### Interval

- Render a calendar - 13.6
- [Insert Interval](https://leetcode.com/problems/insert-interval/)
- [Merge Intervals](https://leetcode.com/problems/merge-intervals/)
- [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)
- [Meeting Rooms](https://leetcode.com/problems/meeting-rooms/)
- [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)
- [Interval list intersection](https://leetcode.com/problems/interval-list-intersections/)

---

#### Linked List

- [Reverse a Linked List](https://leetcode.com/problems/reverse-linked-list/)
- [Detect Cycle in a Linked List](https://leetcode.com/problems/linked-list-cycle/)
- [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)
- [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
- [Remove Nth Node From End Of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
- [Reorder List](https://leetcode.com/problems/reorder-list/)

---

#### Matrix

- [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)
- [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)
- [Rotate Image](https://leetcode.com/problems/rotate-image/)
- [Word Search](https://leetcode.com/problems/word-search/)

---

#### String

- [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
- [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)
- [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)
- [Valid Anagram](https://leetcode.com/problems/valid-anagram/)
- [Group Anagrams](https://leetcode.com/problems/group-anagrams/)
- [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)
- [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)
- [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)
- [Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)
- [Encode and Decode Strings](https://leetcode.com/problems/encode-and-decode-strings/)

---

#### Tree

- Construct BST from pre-order data
- Construct a BT from in-order and pre-order traversals
- [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
- [Same Tree](https://leetcode.com/problems/same-tree/)
- [Invert/Flip Binary Tree](https://leetcode.com/problems/invert-binary-tree/)
- [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)
- [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)
- [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)
- [Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)
- [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)
- [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)
- [Lowest Common Ancestor of BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
- [Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)
- [Add and Search Word](https://leetcode.com/problems/add-and-search-word-data-structure-design/)
- [Word Search II](https://leetcode.com/problems/word-search-ii/)
- [Convert BST to sorted doubly linked list](https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)
- [BST Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)
- [Binary Tree level order traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)
- [Binary Tree right side view](https://leetcode.com/problems/binary-tree-right-side-view/)

----

#### Heap

- [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
- [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)
- [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

---

#### Greedy algorithms
- [Task Scheduler](https://leetcode.com/problems/task-scheduler/)

---
- 11.10
- LCA
- LCA with parent pointers
- Previous chapter (stack and queue) problems related to binary tree
- Interval problems
- [Preorder, inorder, postorder without recursion (clean solution)](https://stackoverflow.com/a/31643444/11556612)
- [Num of islands**](https://leetcode.com/problems/number-of-islands/)
- [Accounts merge**](https://leetcode.com/problems/accounts-merge/)
- [Max are of island](https://leetcode.com/problems/max-area-of-island/)
- [battleships on a board](https://leetcode.com/problems/battleships-in-a-board/)

### Some fun problems:

 * [Num of pairs divisible by k](#num-of-pairs-divisible-by-k)
 * [Min difficulty](#min-difficulty)
 
 
### Num of pairs divisible by k 
**Given an array, return the number of pairs that are divisible by k**

Example:

```cpp
[30,20,150,100,40] k = 60
return 3:
30 + 150,
20 + 100,
20 + 40
``` 

The brute force solution is simple to see: create an outer loop to start at 0 and an inner loop to start at 1. Next add element pointed to by the outer loop to the element pointer to by the inner loop. Check to see if the sum % k == 0. If so increment counter, otherwise, move on. This takes $O(N^2)$ time.

A better approach: Let's store the modulo of elements with k. For example, if we're looking to add up to 60, and my current element is 100, I'll add to my hash table the following entry:

```cpp
ht[40] = 1
```

I'll keep incrementing this if I find any more modulo that result in 40. Let's see what my hash table will look like if I have the following input:

 ```cpp
k = 60
[ 30, 20, 150, 100, 40]

ht [ 30 % 60 = 30 ]   = 1
ht [ 20 % 60 = 20 ]   = 1

ht [ 150 % 60 =  30], increment earlier count:
ht [ 30 & 150 % 60 = 30 ]   = 2
ht [ 20 % 60 = 20 ]   = 1  
ht [ 100 % 60 = 40] = 1

ht [ 140 % 60 = 20], increment earlier count:
ht [ 30 & 150 % 60 = 30 ]   = 2
ht [ 20 & 140 % 60 = 20 ]   = 2
ht [ 100 % 60 = 40] = 1
```

Ok, now our hash table has the information above. Now, all we need to do is go through the list and see if we can find the complement of the mod of value we're looking for. For example, if we're at 20, we know we'll need 40 more to add up to 60. So, the question we'll ask is, is there another element that can give us the 40 to add up to 60? Yes! We have 1 other element. A special case: what if we have 60 and 30? Well, in that case, we'll have to see how many 30s and 60s we have. If the number > 1, then we can add to 60. Here's this logic converted to code:

```cpp
int numPairsDivisibleByK(vector<int>& time, int k) {
    unordered_map<int,int> hash;
    int ans = 0;
    for(int  i : time){
        i %= k;
        cout << "Incrementing: " << i << endl;
        hash[i]++;
        if(i == 0 || i == k/2){
            cout << hash[i] << endl;
            ans += hash[i]-1;
        }
        else if(hash.count(60-i)){
            cout << "Found: " << hash[k-i] << " for: " << i << endl;
            ans += hash[k-i];
        }

    }
    return ans;
}
```



### Min Difficulty
**You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the i-th job, you have to finish all the jobs j where 0 <= j < i). You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done in that day.**

Worded differently, this problem asks you to cut the array into `d` pieces such that the sum of max of each piece is as small as possible. Example:

```cpp
Input: jobDifficulty = [6,5,4,3,2,1], d = 2
Output: 7

This cut returns the minimum sum:

[6 5 4 3 2] [1] 6 + 1 = 7

Other cuts would be larger:
[6 5 3 3] [2 1] 6 + 2 = 8 
```

Brute force approach would be to try a cut at every position and getting the min of all max sums. Since this implies finding all combinations, we can use DP! 

We can have a DP table with rows = `d + 1` and columns = `number of jobs`:

|  | 0 | 1 | 2 | 3 | 4 |
| -- | -- | -- | -- | -- | -- |
| **0** | 0 | 0 | 0 | 0 | 0 | 
| **1** | 0 | 0 | 0 | 0 | 0 | 
| **2** | 0 | 0 | 0 | 0 | 0 | 

