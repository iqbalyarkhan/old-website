---
date: 2021-06-09
draft: false
thumbnail: /post-images/graphql.png
title: GraphQL Notes
extract: My notes as I learn GraphQL
categories:
  - React
tags:
  - blog
  - React
---

- [Introduction](#introduction)
  - [GraphQL and Github](#graphql-and-github)
- [Query](#query)
  - [Fragments](#fragments)
  - [Variables](#variables)
  - [Default Variables](#default-variables)
  - [Named Queries](#named-queries)
  - [Nested Objects](#nested-objects)
  - [Directives](#directives)
- [Mutations](#mutations)
- [Pagination](#pagination)

## Introduction

GraphQL is a query language and server-side runtime for APIs that prioritizes giving clients exactly the data they request and no more. GraphQL is designed to make APIs fast, flexible, and developer-friendly. It can even be deployed within an IDE known as GraphiQL. As an alternative to REST, GraphQL lets developers construct requests that pull data from multiple data sources in a single API call.

### GraphQL and Github

To get started, let's use Github's GraphQL API for which you need to generate a personal access token. The access token allows you to read and write data with your username.

There are two common ways to interact with the GitHub GraphQL API:

- First, you can use [GitHub’s GraphQL Explorer](https://docs.github.com/en/graphql/overview/explorer). You only need to sign up with your GitHub account to run GraphQL queries. This is what we'll be using.
- Second, you can use a generic client called `GraphiQL`. It allows you to run GraphQL queries against your github account using the token you generated.

## Query

```graphql
#keyword
query {
  #object
  viewer {
    #field1
    login
    #field2
    url
  }
}
```

output:

```json
{
  "data": {
    "viewer": {
      "login": "iqbalyarkhan",
      "url": "https://github.com/iqbalyarkhan",
      "avatarUrl": "https://xyz.com/u/123"
    }
  }
}
```

Example above starts with keyword `query`. This is similar to `select` statement in SQL. Inside the query, we provider the `viewer` object that can be used to request data about the currently authorized user. Since you are authorized by your personal access token, it should show data about your account.

The viewer is an `object` in GraphQL terms. Objects hold data about an entity.

This data is accessed using a so-called `field` in GraphQL. Fields are used to ask for specific `properties` in objects. For instance, the viewer object exposes a wide range of fields. Two fields for the object–name and url–were used in the query.

To specify a GitHub organization, you can pass an `argument` to fields. In the example below, I've provided `login` as an argument:

```graphql
query {
  organization(login: "SMUCSEG2Consulting") {
    name
    descriptionHTML
    url
  }
}
```

output:

```json
{
  "data": {
    "organization": {
      "name": "SMUCSEG2Consulting",
      "descriptionHTML": "<div></div>",
      "url": "https://github.com/SMUCSEG2Consulting"
    }
  }
}
```

What if you're part of 2 organizations? Simply add 2 queries right?

```graphql
query {
  organization(login: "SMUCSEG2Consulting") {
    name
    descriptionHTML
    url
  }
  organization(login: "SMUCSE2341") {
    name
    descriptionHTML
    url
  }
}
```

output: You’d see an error such as `Field 'organization' has an argument conflict`.

That's because you're requesting 2 objects with the same structure. If you ever wanted to request data about two identical objects, you would have to use `aliases` because GraphQL wouldn’t know how to resolve the two organization objects in a result. Here's how you'd do it. (Note the use of `consulting` and `teaching` as aliases):

```graphql
query {
  consulting: organization(login: "SMUCSEG2Consulting") {
    name
    descriptionHTML
    url
  }
  teaching: organization(login: "SMUCSE2341") {
    name
    descriptionHTML
    url
  }
}
```

output:

```json
{
  "data": {
    "consulting": {
      "name": "SMUCSEG2Consulting",
      "descriptionHTML": "<div></div>",
      "url": "https://github.com/SMUCSEG2Consulting"
    },
    "teaching": {
      "name": "CS 2341 - Data Structures",
      "descriptionHTML": "<div>Github Org for SMU's Data Structures Class</div>",
      "url": "https://github.com/SMUCSE2341"
    }
  }
}
```

### Fragments

Note how we repeated the same fields(name, descriptionHTML and url) over and over in the query above:

```graphql
query {
  consulting: organization(login: "SMUCSEG2Consulting") {
    name
    descriptionHTML
    url
  }
  teaching: organization(login: "SMUCSE2341") {
    name
    descriptionHTML
    url
  }
}
```

We can extract commonly used fields into something called a `fragment`. Fragment specifies 2 pieces of information:

- What fields should form the query
- What type of object can the fragment be used on

Here's how you define a fragment

```graphql
fragment nameOfFragment on nameOfObject {
  field1
  field2
}
```

Now converting our 3 fields into a fragment we get:

```graphql
fragment sharedOrgFields on Organization {
  name
  descriptionHTML
  url
}
```

We can now change our query to:

```graphql
query {
  consulting: organization(login: "SMUCSEG2Consulting") {
    ...sharedOrgFields
  }
  teaching: organization(login: "SMUCSE2341") {
    ...sharedOrgFields
  }
}

fragment sharedOrgFields on Organization {
  name
  descriptionHTML
  url
}
```

### Variables

In the previous queries, you provided arguments that identified an organization to your fields; but you **inlined** these arguments in your query. Think about a query like a function, where it’s important to provide dynamic arguments to it. That’s where the `variable` in GraphQL comes in: it allows arguments to be extracted as variables from queries. Here’s how an organization’s login argument can be extracted to a dynamic variable (let's use a single organization for now):

```graphql
query ($organization: String!) {...}
```

We've provided name of the variable, `organization`, to our query via the `$` sign. We're also providing the **type** of variable which is `String`. Exclamation point `!` means that the argument is required.

Here's the previous example in its entirety using variables (I removed the alias since there's only 1 org now):

```graphql
query ($organization: String!) {
  organization(login: $organization) {
    ...sharedOrgFields
  }
}

fragment sharedOrgFields on Organization {
  name
  descriptionHTML
  url
}
```

To pass in the variables, you'd do so in the query variables section:

```json
{ "organization": "SMUCSE2341" }
```

### Default Variables

What if you have a field that can be provided in some cases and omitted in others? You can use a default variable. To do so, simply make the variable non-required (by removing exclamation) and provide a default value:

```graphql
query ($organization: String = "SMUCSE2341") {
  organization(login: $organization) {
    ...sharedOrgFields
  }
}

fragment sharedOrgFields on Organization {
  name
  descriptionHTML
  url
}
```

### Named Queries

What if you had multiple queries? To keep things clean, we can also name our queries:

```graphql
query getOrgInfo($organization: String = "SMUSCE2341") {
  organization(login: $organization) {
    ...sharedOrgFields
  }
}

fragment sharedOrgFields on Organization {
  name
  descriptionHTML
  url
}
```

### Nested Objects

So far we've only looked at organization info. Let's find out the repos owned by an org. An org has another field called `repository` that can disply info of the repo name passed in.

Let's pass in the repo's name dynamically. Let's remove the default args and make org name and repo name required:

```graphql
query getOrgInfo($organization: String!, $repository: String!) {
  organization(login: $organization) {
    ...sharedOrgFields
    repository(name: $repository) {
      name
    }
  }
}
fragment sharedOrgFields on Organization {
  name
  descriptionHTML
  url
}
```

with the following query variables:

```json
{ "organization": "SMUCSE2341", "repository": "Sprint4Headers" }
```

will return this:

```json
{
  "data": {
    "organization": {
      "name": "CS 2341 - Data Structures",
      "descriptionHTML": "<div>Github Org for SMU's Data Structures Class</div>",
      "url": "https://github.com/SMUCSE2341",
      "repository": {
        "name": "Sprint4Headers"
      }
    }
  }
}
```

### Directives

A directive decorates part of a GraphQL schema or operation with additional configuration. Tools like Apollo Server (and Apollo Client) can read a GraphQL document's directives and perform custom logic as appropriate.

Directives are preceded by the @ character, like so:

```graphql
type ExampleType {
  oldField: String @deprecated(reason: "Use `newField`.")
  newField: String
}
```

This example shows the `@deprecated` directive, which is a default directive (i.e., it's part of the GraphQL specification). It demonstrates the following about directives:

- Directives can take arguments of their own (reason in this case).
- Directives appear after the declaration of what they decorate (the `oldField` field in this case)

Let's use this directive concept with our repository. We'll pass a directive called `withFork` that'll determine if we want to get the `forkCount` for a particular repo. If it's true, we'll display this count, otherwise we won't.

This line determines this logic inside the `repository` object:

```graphql
forkCount @include(if: $withFork)
```

An example:

```graphql
query getOrganizationInfo(
  $organization: String!
  $repository: String!
  $withFork: Boolean!
) {
  organization(login: $organization) {
    name
    url
    descriptionHTML
    repository(name: $repository) {
      name
      forkCount @include(if: $withFork)
    }
  }
}
```

Here're the variables we provide to our query:

with the following query variables:

```json
{
  "organization": "SMUCSE2341",
  "repository": "Sprint4Headers",
  "withFork": true
}
```

Output:

```json
{
  "data": {
    "organization": {
      "name": "CS 2341 - Data Structures",
      "url": "https://github.com/SMUCSE2341",
      "descriptionHTML": "<div>Github Org for SMU's Data Structures Class</div>",
      "repository": {
        "name": "Sprint4Headers",
        "forkCount": 1
      }
    }
  }
}
```

## Mutations

Lets talk about `mutation`: unlike `query`, a `mutation` is used for writing data instead of reading it. The `mutation` shares the same principles as the `query`: it has `fields` and `objects`, `arguments` and `variables`, `fragments` and operation names, as well as directives and nested objects for the returned result. With mutations you can specify data as fields and objects that should be returned after it "mutates" into something acceptable.

Let's check out the documentation for `addStar` mutation:

As arguments it accepts `AddStarInput!`. `AddStarInput` needs these as input:

```graphql
#Required  Starrable ID to star.
starrableId: ID!

#Optional unique identifier for the client performing the mutation.
clientMutationId: String
```

This means you need to have the `starrableId` of the repo that you want to star. To do so, I need to query one such repo:

```graphql
query getRepoId {
  organization(login: "the-road-to-learn-react") {
    name
    url
    repository(name: "the-road-to-learn-react") {
      id
      name
    }
  }
}
```

output:

```json
{
  "data": {
    "organization": {
      "name": "The Road to React",
      "url": "https://github.com/the-road-to-learn-react",
      "repository": {
        "id": "MDEwOlJlcG9zaXRvcnk2MzM1MjkwNw==",
        "name": "the-road-to-learn-react"
      }
    }
  }
}
```

We'll now use the returned ID to create a mutation to like this repo:

```graphql
mutation starRepoWithID($repoID: ID!) {
  addStar(input: { starrableId: $repoID }) {
    starrable {
      id
      viewerHasStarred
    }
  }
}
```

In the mutation above, we have defined return fields as the `starrable` object. We provide this as our query variables:

```json
{ "repoID": "MDEwOlJlcG9zaXRvcnk2MzM1MjkwNw==" }
```

output:

```json
{
  "data": {
    "addStar": {
      "starrable": {
        "id": "MDEwOlJlcG9zaXRvcnk2MzM1MjkwNw==",
        "viewerHasStarred": true
      }
    }
  }
}
```

To un-star, we'll do this:

```graphql
mutation unStarRepoWithID($repoID: ID!) {
  removeStar(input: { starrableId: $repoID }) {
    starrable {
      viewerHasStarred
    }
  }
}
```

output:

```json
{
  "data": {
    "removeStar": {
      "starrable": {
        "viewerHasStarred": false
      }
    }
  }
}
```

## Pagination

Imagine you have a list of repositories in your GitHub organization, but you only want to retrieve a few of them to display in your UI. It could take ages to fetch a list of repositories from a large organization. In GraphQL, you can request paginated data by providing arguments to a list field that says how many items you are expecting from the list:

```graphql
query OrganizationForLearningReact {
  organization(login: "the-road-to-learn-react") {
    name
    url
    repositories(first: 2) {
      edges {
        node {
          name
        }
      }
    }
  }
}
```

`first` argument is passed to the `repositories` list field that specifies how many items from the list are expected in the result. The query shape doesn’t need to follow the `edges` and `node` structure, but it’s one of a few solutions to define paginated data structures and lists with GraphQL.

We still need to figure out how to fetch the next two repositories in the list, however. The first result of the query is the first page of the paginated list, the second query result should be the second page.

Each edge comes with its own cursor field to identify its position in the list:

```graphql
query OrganizationForLearningReact {
  organization(login: "the-road-to-learn-react") {
    name
    url
    repositories(first: 2) {
      edges {
        node {
          name
        }
        cursor
      }
    }
  }
}
```

output:

```json
{
  "data": {
    "organization": {
      "name": "The Road to React",
      "url": "https://github.com/the-road-to-learn-react",
      "repositories": {
        "edges": [
          {
            "node": {
              "name": "the-road-to-learn-react"
            },
            "cursor": "Y3Vyc29yOnYyOpHOA8awSw=="
          },
          {
            "node": {
              "name": "hackernews-client"
            },
            "cursor": "Y3Vyc29yOnYyOpHOBGhimw=="
          }
        ]
      }
    }
  }
}
```

Now, you can use the cursor of the first repository in the list to execute a second query. By using the after argument for the repositories list field, you can specify an entry point to retrieve your next page of paginated data:

```graphql
query OrganizationForLearningReact {
  organization(login: "the-road-to-learn-react") {
    name
    url
    repositories(first: 2, after: "Y3Vyc29yOnYyOpHOA8awSw==") {
      edges {
        node {
          name
        }
        cursor
      }
    }
  }
}
```

In the previous result, only the second item is retrieved, as well as a new third item. The first item isn’t retrieved because you have used its cursor as after argument to retrieve all items after it.
