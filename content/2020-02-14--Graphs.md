---
title: Graphs
date: 2020-02-14
draft: true
extract: An analysis of graphs
categories: 
    - Data Structures
tags:
  - Data Structures
  - Graphs
---

### Table of Contents

1. [Introduction](#introduction)

2. [Definitions](#definitions)

3. [Adjacency Matrix](#adjacency-matrix)
    
    * [Adjacency Matrix code](#adjacency-matrix-code)

    * [Pros and Cons of Adjacency Matrix](#pros-and-cons-of-adjacency-matrix)

4. [Adjacency List](#adjacency-list)

    * [Adjacency List code](#adjacency-list-code)

    * [Pros and Cons of Adjacency List](#pros-and-cons-of-adjacency-list)

5. [Analysis](#analysis)
### Introduction

In this post I'll talk about a type data structure called graph. We've already seen a type of a graph: binary search tree. Graphs can be used to model your data depending on the type of problem you have. Graphs do not have a rigid, well defined shape (unlike trees) and can be created to solve the problem at hand.

### Definitions

- **Vertices**: Similar to nodes in a tree, a vertex could represent a city in our graph.
- **Edges**: Edges connect 2 vertices together. An edge could represent a highway connecting cities.
- **Directed**: A directed graph is one that is represented by arrow heads showing the allowed direction that can be travelled.
- **Undirected**: Undirected graph allows you to travel in any direction (A to B or B to A) as long as the two vertices are connected.
- **Adjacent**: Two vertices are said to be adjacent if they're connected (ie one edge away from one another)

Here is what a sample, undirected graph looks like:

![Undirected-Graph](images/graphs/undirectedgraph.png) [Image Credit - Undirected Graph](http://www.algolist.net/Data_structures/Graph/Internal_representation)

How would we go about representing a graph in our code? As you can notice, there is no defined structure. It is hard to determine what or left and right child is going to be for each node. To represent a graph in memory, we've got 2 methods:

### Adjacency Matrix

A matrix is nothing but a 2D array where the size of each array is equal to the number of vertices in our graph. A value of 1 at a particular index would mean that the vertex is connected to another vertex. A value of 0 would signify that no connection is present. Let's create an adjacency matrix for the image above:


|  | 1 | 2 | 3 | 4 | 5 |
| -- | -- | -- | -- | -- | -- |
| **1** | 0 | 0 | 0 | 0 | 0 | 0 | 
| **2** | 0 | 0 | 0 | 0 | 0 | 0 |
| **3** | 0 | 0 | 0 | 0 | 0 | 0 |
| **4** | 0 | 0 | 0 | 0 | 0 | 0 |
| **5** | 0 | 0 | 0 | 0 | 0 | 0 |

The matrix has a 2D array where each array is of size 5 (5 because our number of vertices are 5). Next, we see that 1 is connected to 4. Since this is an undirected graph, it also means that 4 is connected to 1. So, at indices $(1,4)$ and $(4,1)$ we can put a value of 1:


|  | 1 | 2 | 3 | 4 | 5 |
| -- | -- | -- | -- | -- | -- |
| **1** | 0 | 0 | 0 | 1 | 0 | 0 | 
| **2** | 0 | 0 | 0 | 0 | 0 | 0 |
| **3** | 0 | 0 | 0 | 0 | 0 | 0 |
| **4** | 1 | 0 | 0 | 0 | 0 | 0 |
| **5** | 0 | 0 | 0 | 0 | 0 | 0 |

4 is connected to 1,2 and 5. So we need to add 1s to the following positions:

$$$
(1,4) and (4,1) 
$$$

$$$
(2,4) and (4,2) 
$$$

$$$
(5,4) and (4,5) 
$$$

|  | 1 | 2 | 3 | 4 | 5 |
| -- | -- | -- | -- | -- | -- |
| **1** | 0 | 0 | 0 | 1 | 0 | 
| **2** | 0 | 0 | 0 | 1 | 0 | 
| **3** | 0 | 0 | 0 | 0 | 0 | 
| **4** | 1 | 1 | 0 | 0 | 1 | 
| **5** | 0 | 0 | 0 | 1 | 0 | 

3 and 5 are connected:

|  | 1 | 2 | 3 | 4 | 5 |
| -- | -- | -- | -- | -- | -- |
| **1** | 0 | 0 | 0 | 1 | 0 | 
| **2** | 0 | 0 | 0 | 1 | 0 | 
| **3** | 0 | 0 | 0 | 0 | 1 | 
| **4** | 1 | 1 | 0 | 0 | 1 | 
| **5** | 0 | 0 | 1 | 1 | 0 | 

Finally, 2 is connected to 4 and 5:

|  | 1 | 2 | 3 | 4 | 5 |
| -- | -- | -- | -- | -- | -- |
| **1** | 0 | 0 | 0 | 1 | 0 | 
| **2** | 0 | 0 | 0 | 1 | 1 | 
| **3** | 0 | 0 | 0 | 0 | 1 | 
| **4** | 1 | 1 | 0 | 0 | 1 | 
| **5** | 0 | 1 | 1 | 1 | 0 | 

### Adjacency Matrix code

```cpp{numberLines: true}
class AdjMatrix{
private:
    bool** matrix;
    int vertices = 5;
  
public:
    AdjMatrix();
    void AddEdge(int,int);
    void Print();
    
};

void AdjMatrix::Print(){
    for (int row = 0; row < vertices; row++){
        for (int col = 0; col < vertices; col++){
            cout << matrix[row][col] << " ";
        }
        cout << endl;
    }
    cout << endl;
}

AdjMatrix::AdjMatrix(){
    
    matrix = new bool*[vertices];
    for (int row = 0; row < vertices; row++){
        matrix[row] = new bool[vertices];
        for (int col = 0; col < vertices; col++){
            matrix[row][col] = false;
        }
    }
}

void AdjMatrix::AddEdge(int i, int j){
    matrix[i][j] = true;
    matrix[j][i] = true;
}
```

On lines 3 and 4:

```cpp{numberLines: 3}
   bool** matrix;
   int vertices = 5;
```

we're declaring our matrix and the number of vertices in the graph. In the constructor, we initialize the matrix:

```cpp{numberLines: 23}
AdjMatrix::AdjMatrix(){
    
    matrix = new bool*[vertices];
    for (int row = 0; row < vertices; row++){
        matrix[row] = new bool[vertices];
        for (int col = 0; col < vertices; col++){
            matrix[row][col] = false;
        }
    }
}
```

Line 25 creates an array of boolean pointers  with the size as `vertices`. So now matrix points to an array of pointers:

```   
Each box is a pointer to a boolean and all the 
boxes are part of a single array which is being pointed to by 
the matrix pointer.  
           _
matrix -> |_|
           _
          |_|
           _
          |_|
           _
          |_|
           _
          |_|
```
Then on line 26, we loop through each element of this pointer array and initialize an array of booleans, again the size of number of vertices:

```
           _   _   _   _   _   _ 
matrix -> |_| |_| |_| |_| |_| |_| 
           _   _   _   _   _   _
          |_| |_| |_| |_| |_| |_|     
           _   _   _   _   _   _ 
          |_| |_| |_| |_| |_| |_| 
           _   _   _   _   _   _
          |_| |_| |_| |_| |_| |_|    
           _   _   _   _   _   _
          |_| |_| |_| |_| |_| |_|  
```

### Pros and Cons of Adjacency Matrix

**The good**
- Insertion and deletion is fast due to the fact that we can access any edge in $O(1)$ time. 
- Checking if two vertices are connected is also fast, $O(1)$ thanks to fast lookup using array indices.

**Tha bad**
- Notice in the matrix above, more than half the entries are $0$. Our matrix is a sparse matrix and requires $O(V^2)$ space where $V$ is the number of vertices. Therefore, if we have a large graph, a matrix would take up a lot of space  

### Adjacency List

An adjacency list also tells us what vertices are connected. As the name suggests, it is a linked list of connected items. For our image above, this is what the adjacency list would look like:

```
1 -> 4
2 -> 4 -> 5
3 -> 5
4 -> 1 -> 2 -> 5
5 -> 2 -> 3 -> 4

```

### Adjacency List code

Let's see the code for constructing this undirected graph:

![Undirected-Graph](images/graphs/undirectedgraph.png) [Image Credit - Undirected Graph](http://www.algolist.net/Data_structures/Graph/Internal_representation)

```cpp{numberLines: true}
class AdjList{
private:
    //Adding one more to the num
    //since vectors start at 0 and
    //we want 1-5. So 0 will remain
    //empty
    int vectorSize = 6;
    vector<vector<int>> adjList;
    
public:
    AdjList();
    AdjList(int);
    void AddEdge(int,int);
    void Print();
};

AdjList::AdjList(int vecSize) : vectorSize(vecSize + 1){
    cout << "Number of vertices was passed as: " << vectorSize << endl;
    adjList.resize(vectorSize);
}
AdjList::AdjList(){
    cout << "Number of vertices defaults to 5..." << endl;
    vectorSize = 6;
    adjList.resize(vectorSize);
}

void AdjList::Print(){
    for (int i = 1; i < 6; i++){
        cout << i;
        for (auto j : adjList[i]){
            cout << " -> ";
            cout << j;
        }
        cout << endl;
    }
    cout << endl;
}

void AdjList::AddEdge(int i, int j){
    adjList[i].push_back(j);
    adjList[j].push_back(i);
}
```
To create our list, we're using a vector of vectors declared on line 8. If you're using the default constructor, the number of vertices default to 5. So, if the default constructor is called, we'd have this:

```
0 -> <empty vector>
1 -> <empty vector>
2 -> <empty vector>
3 -> <empty vector>
4 -> <empty vector>
5 -> <empty vector>
```

Where 0-5 is one vector and each element in that vector is also a vector at that position.

Since arrays and vectors start at 0 index, to keep consistent with the graph shown above, we'll add the 0th vector as well but will start adding at index 1. Next, when we call the `AddEdge()` function, we pass in the edge that needs to be created. So, when `AddEdge()` is called with 1 and 4, it performs the following actions:
```cpp{numberLines: 39}
void AdjList::AddEdge(int i, int j){
    adjList[i].push_back(j);
    adjList[j].push_back(i);
}
```

The function goes to the `adjList[1]` and pushes back 4 and conversely, goes to `adjList[4]` and pushes a 1. Since our graph is undirected, it means that if 1 is connected to 4, then 4 is also connected to 1. If it is a directed graph, we'd only add one edge instead of two. If it is a directed weighted graph, we can use `std::pair`. Once the connection is made, our vectors would look like this:

```
0 -> <empty vector>
1 -> <4>
2 -> <empty vector>
3 -> <empty vector>
4 -> <1>
5 -> <empty vector>
```

The process repeats until no more edges are to be added. We do not have a check in our `addEdge()` function to see if an edge already exists because we assume that the client will always pass in distinct edges. Notice how the vectors are only populated as needed ie there is no wasted space. 
 
Client code for this class:

```cpp{numberLines: true}
int main(int argc, const char * argv[]) {
    AdjList l;
    l.AddEdge(1,4);
    l.AddEdge(4,2);
    l.AddEdge(5,4);
    l.AddEdge(5,2);
    l.AddEdge(5,3);
    l.Print();
    return 0;
}

```


### Pros and Cons of Adjacency List

**The good**
- Takes only as much space as needed: $O(E + V)$ where $E$ is the number of edges and $V$ is the number of vertices
- Allows for faster traversal: you only visit edges that exist.

**The bad**
- Takes time to check whether two vertices are connected.
- Edge insertion and deletion also takes more time.