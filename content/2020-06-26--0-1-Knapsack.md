---
title: 0-1 Knapsack
date: 2020-06-26
thumbnail: /post-images/knapsack.png
draft: false
extract: Detailed look at 0-1 Knapsack
categories: 
    - Dynamic Programming
tags:
    - Dynamic programming
---

1. [Introduction](#introduction)
2. [DP and Recursion](#dp-and-recursion)
3. [0-1 Knapsack](#0-1-knapsack-problem)
    * [Memoization](#memoization)
    * [Tabulation](#tabulation)
    * [Summary](#summary)
    * [Bottom up from Scratch](#bottom-up-from-scratch)
4. [Subset Sum](#subset-sum)
    * [Bottom up from scratch](#bottom-up-from-scratch)
    * [Subset Sum Recursive](#subset-sum-recursive)
5. [Equal Sum Partition](#equal-sum-partition)
6. [Count Subsets Adding to Given Sum](#count-subsets-adding-to-given-sum)
12. [Conclusion](#conclusion) 


### Introduction

DP is a general technique for solving optimization, search, and counting problems that can be decomposed into sub-problems. You should consider using DP whenever you have to make choices to arrive at the solution, specifically, when the solution relates to sub-problems.

Like divide-and-conquer, DP solves the problem by combining the solutions of multiple smaller problems, but what makes DP different is that the same sub-problem may reoccur. Therefore, a key to making DP efficient is caching the results of inter- mediate computations. 

The key to solving a DP problem efficiently is finding a way to break the problem into sub-problems such that

- the original problem can be solved relatively easily once solutions to the subÂ¬ problems are available, and
- these sub-problem solutions are cached. (Usually, but not always, the sub-problems are easy to identify) 

DP can be used to find the total number of ways to do something (for example making a change) and if you optimize how you determine each "way", you'd get the optimal solution. Thus, DP can be used to find all combinations AND the optimal solution.

From the discussion above, it is clear to see that DP is nothing but optimized recursion. Therefore, before jumping into dynamic programming, be sure to go over my [recursion](/recursion) post. 

As the title suggests, in this post, we'll be talking about a famous problem called the knapsack problem. This problem has 3 flavors:

(1) **Fractional Knapsack**: Fractional items allowed (items need not be whole numbers). We won't discuss this here since this is a class of greedy algorithms

(2) **0 - 1 Knapsack**: Items need to be included as whole or not included. No fractional items allowed. This is what we'll be mainly concerned with here

(3) **Unbounded Knapsack**: Unlimited supply of items. We'll look at this in [unbounded knapsack](/unbounded-knapsack) post.

In this post, we'll concern ourselves with **0-1 Knapsack**.

### DP and recursion

I said earlier that DP is optimized recursion. What does that mean? It means that while we're recursing to solve a problem, we might run into instances where we're redoing work that was previously done in another recursive call. As a result we're performing work that has already been done which is obviously inefficient. To get rid of this redundancy, we can trade space for time where we use extra space to store results we've already calculated. This technique of storing results is known as dynamic programming. 

While trying to understand the DP, I found various sources on the internet that used the table creation technique. Our aim should not be to create the said table but to understand WHY that table is created. DP doesn't require the creation of a table for every problem! 

So how do we know that DP is required to solve a given problem:
 
- If DP is optimized recursion, any recursive problem is also a DP problem!
    - There'll be a **choice** (include or exclude something etc) to make and the subproblems overlap. If there are more than one calls being made in each recursive call, ie the recursive functions is calling itself more than once, there is a good chance that it can be optimized using DP.
    
- DP also deals with optimization as in find the least number of steps, or the most profitable method etc
    - There might be keywords such as minimum, maximum, etc. Where you're looking to either find the max or the min or the least or the most!
    
Therefore, to summarize if there's recursion and there are more than 1 calls being made to the recursive function in each recursive call:

```cpp
    return Fib(n-1) + Fib(n-2)
```

then we can use DP to cache the results. Secondly, if it is an optimization problem, then using DP is required. Our approach to solving DP problems would be to: 

- Write a recursive solution
- Perform memoization (storing results)
- Create a bottom-up table if needed to better visualize the algorithm

### 0-1 Knapsack Problem
**The knapsack problem is a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size knapsack and must fill it with the most valuable items. The problem often arises in resource allocation where the decision makers have to choose from a set of non-divisible projects or tasks under a fixed budget or time constraint, respectively.**

Why is this a DP problem? because we're being asked to maximize our profit. ie **total value is as large as possible**. In addition, we're also given a bunch of choices: ie **Given a set of items, each with a weight and a value, determine the number of each item to include in a collection**

Let's see what our input will be:

```text
                    Item1   Item2   Item3   Item14
wt[] in pounds        5       4       6        3    
val[] in dollars     10      40       30      50
Capacity: 10       
```
We'll be given two arrays: a weight array that'll hold the weight of each item and a value array that holds the value of each item in dollars. We'll also be given the capacity of our sack and a value `n` denoting the number of elements in the arrays. 

Let's start writing the recursive solution to this problem:

Let's say this is our function signature:

```cpp
int knapSack(vector<int> wt, vector<int> val, int c, int n){
}
```
- It'll accept the relevant arrays, the capacity and the size of the arrays ie the actual size: if there are 4 elements, `n` will be 4 
- It'll return an integer to denote the `max` profit

Ok, now that we have the signature, let's think about the base case: Remember, the **base case** is nothing but the **smallest valid input**. In our case, the smallest valid input is when `c` (or capacity) = 0 (ie we don't have any more space in the bag). Another base case is when there're no more items to consider ie n = 0.  If we have 4 items and we pass the value of `n` as 4, once we get to n = 0, we'll have no more items to process. Therefore, when we're at our base case, our max profit is 0. Let's add this to our function:

```cpp
int knapSack(vector<int> wt, vector<int> val, int c, int n){

    if (c == 0 || n == 0){
        //Base case: there's no more space or no more items
        return 0;
    }
}
```

Now, let's think about what we can do. To do so, let's see the choices that we have by looking at our arrays:


```text         
                                               n 
                                               |
                    Item1   Item2   Item3   Item4
wt[] in pounds        5       4       6        3    
val[] in dollars     10      40       30      50
Capacity: 10       
```

Say `n` is at the last element. Here, we have a few choices that we can make:

(1) The nth element's weight > capacity. In this case we cannot choose this element

(2) The nth element's weight <= capacity. In this case the item is eligible to be picked. Here, we've got two choices:
    
    - We might choose this item
    
    - We might ignore this item

Here's the decision tree:

```text
                            itemN
                       /             \   
                    wt[n] <= c      wt[n] > c
                   /        \           |
                add to bag  don't add   cannot add
```

We can either choose itemN or we can ignore it:

-**Choose**: 

If we choose the item, we'll keep track of its value, reduce the capacity of our bag and continue to recurse:

```cpp
val[n-1] + knapSack(wt, val, c - wt[n-1], n-1);
``` 

Notice, since we've passed in 4, there's no `val[4]` since arrays are 0 based. So, to get the last element, we'll start with `val[n-1]`. To avoid this you can choose to pass `n` as `n-1` to the function but I preferred to keep `n` as is. Similarly, we're reducing our capacity by the weight of the element we just chose by: `c - wt[n-1]`. Then, we reduce `n` since we're done with processing the current element and move on.

-**Ignore**: 

If we ignore the item, we'll do nothing with its value. Since we're not picking it, it won't add to our value and it won't decrease our capacity. We simply ignore it and move to the next item:

````cpp
knapSack(wt,val,c,n-1);
````

How do we decide, at the end of the day, which item goes in the bag? The item that goes in the bag needs to maximize our profit. So, we'll choose the max of **choosing** the item and **ignoring** the item:

```cpp
       
max ( 
        (val[n-1] + knapSack(wt, val, c - w[n-1], n-1), //choosing the item, so decrease capacity left by weight of item  
        knapsack(wt, val, c, n-1)                       //Not choosing the item so just move to the next item 
);  
``` 



Let's see the complete code for the case where wt[n-1] <= c: (Again, n-1 because n is the actual size of the array, so calling wt[n] would be an illegal access which is why the -1).

```cpp
int knapSack(vector<int> wt, vector<int> val, int c, int n){
    if (n == 0 || c == 0)
        return 0;

    //Weight can either be <= c or > c
    if (wt[n-1] <= c){
        //Choice 1: choose this item
        //Since we're choosing this item, we add the current item's value to whatever we get from next recursive call
        int profitWithChoosing = val[n] + knapSack(wt, val, c - wt[n], n-1);

        //Choice 2: Don't choose this item
        //Since we don't choose this item, we simply ignore its value and move to the next item
        int profitWithNotChoosing = knapSack(wt, val, c, n-1);

        //Need to return max profit
        //Finally, based on the two decisions above, we choose the max of the two and return that value
        return max (profitWithChoosing, profitWithNotChoosing);

    } else {
        //weight is > capacity, just continue recursing...
        return knapSack(wt, val, c, n-1);
    }
}
```

If you trace the recursive call stack above, you'll notice that there are multiple values being re-calculated. How do I know this? Well, as I said earlier, if a recursive function is making multiple calls to itself, it is guaranteed to have overlapping computations. In addition, for this solution, we also have the case where we look at each element and for each element we have 2 choices: either we choose the element or we don't. Performing these 2 choice calculations for each element we get running time of this algorithm as $2^N$. We can do much better! 


### Memoization 

We can actually save values once calculated by either recursive call. As mentioned earlier, this process of saving already calculated values is called **memoization**. To save these results, we need to create a 2D vector of size $n * m$. This vector will then hold our intermediate results. **This intermediate result is nothing but the max profit up till that point**. We'll elaborate more on this below.

How do we determine the size of our 2D vector? What would be n and what would be m? To determine that, we need to find out the elements we need to keep track of. For example, in the recursive solution above, there's no point in keeping track of the arrays themselves, they're constant. The only two things changing in the algorithm above are:
- `c` capacity that decreases with every addition of element
- `n` that moves down the arrays. 

Therefore, our 2D vector would be of size c+1 and n+1 to prevent overflow. We'll call this 2D vector dp: 

```cpp
vector<vector<int>> dp(c+1, vector<int> (n+1, -1));
```

This vector will be initialized with the value -1 indicating that we're yet to calculate this value. We'll go ahead and calculate the value and store it in our dp vector. We gave up space to reduce our running time. Therefore, we want to save EACH recursive call's value in the 2D vector so that we're not going to perform calculations that have already been done. 

Let's add this dp vector as a global variable to our program:


```cpp

vector<vector<int>> dp(c+1, vector<int> (n+1, -1));

int knapSack(vector<int> wt, vector<int> val, int c, int n){
    if (n == 0 || c == 0)
        return 0;
        
    //Check if value is aleady saved:
    if (dp[c][n] != -1)
        return dp[c][n];

    //Weight can either be <= c or > c
    if (wt[n-1] <= c){
        //Choice 1: choose this item
        //Since we're choosing this item, we add the current item's value to whatever we get from next recursive call
        int profitWithChoosing = val[n-1] + knapSack(wt, val, c - wt[n-1], n-1);

        //Choice 2: Don't choose this item
        //Since we don't choose this item, we simply ignore its value and move to the next item
        int profitWithNotChoosing = knapSack(wt, val, c, n-1);

        //Need to return max profit
        //Finally, based on the two decisions above, we choose the max of the two and return that value
        //Store the max before returning:
        return dp[c][n] = max (profitWithChoosing, profitWithNotChoosing);

    } else {
        //weight is > capacity, just continue recursing...
        //Store in dp before returning:
        return dp[c][n] = knapSack(wt, val, c, n-1);
    }
}
```
Running time for the memoized version is $O(CN)$ where $C$ is the capacity of the sack and $N$ is the number of items we're asked to process. 

Let's just summarize what we've done so far:
- Started with a $2^N$ recursive solution
- Then added a memoized solution that cached calculated results
- Now, we're looking to omit the recursive calls altogether


Ok, so we've seen how we can use recursion and memoization to reduce our running time. We're always asking ourselves, can we do better? What is the one glaring thing in the solution above that we can improve? We can try and get rid of the recursive calls that we have in this solution since a recursive call stack can get pretty large for larger inputs. 

If we think along these lines a little more, we'll realize that if we remove the recursive calls, we can derive our solution using just the 2D array that we created in the recursive solution. So, the next question we should ask ourselves is how do we create that table without using recursion? 

### Tabulation
Ok, so we've decided we're going to get rid of the recursive calls and directly use the matrix. So, if we're directly starting from the matrix, what would be its dimensions? We said earlier, in the memoized solution that our matrix would be used to keep track of only those values that are changing: `c` ie current capacity and `n` which is the current item we're considering. So, our tabular method will also need a matrix of size c+1 * n+1. 

Ok, we've decided that we're removing the recursive call and using the matrix. Let's see this matrix first (notice how I've switched `n` and `c`):

|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** | **8** | **9** | **10** |
| -- | -- | -- | -- | -- | -- | -- | -- | -- |
| **0** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
| **1** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| **2** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
| **3** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
| **4** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 

Notice the number of rows are n + 1 (there are 4 items but the array size is 5) and the column size is capacity + 1 (capacity is 10 but array size is 11). That is because we have to account for the initialization (base case in recursive solution).

So I've got the capacity, which is 10 going from 0 to 10 and the number of items going top to bottom from 0 to 4. These dimensions are `c + 1` and `n + 1` respectively and the final answer will be in `dp[c][n]`.


Next thing we need to do with the matrix is initialize it with 0s:

```cpp
vector<vector<int>> dp(c+1, vector<int> (n+1, 0));
``` 

Now why 0s and not -1 like we did earlier? Let's think about it: We've decided to convert our recursive function to an iterative solution. Let's start with the base condition:

```cpp
//Recursive:

int knapSack(vector<int> wt, vector<int> val, int c, int n){
    if (n == 0 || c == 0)
        return 0;
```

The recursive solution had the base condition where it said that if there are no items or there is no capacity, return 0. Since we'll be using the 2D matrix to solve this iteratively, we need to somehow capture this information in that 2D matrix. Recursive solution said, if n is 0 or c is 0, we'll return 0. So, in the matrix, where n is 0 or c is 0, we'll save 0:

```cpp
void init(){
    for (int i = 0; i < dp.size(); i++){
        if (i == 0){ // row where n == 0 save all 0s
            for (int j = 0; j < dp[i].size(); j++){
                dp[i][j] = 0;
            }
        } else {
            dp[i][0] = 0;
        }
    }
}
``` 

Secondly, since there are no more recursive calls, we're going to use iterative calls to then populate the table. So, let's have another look at the recursive solution:

```cpp
int knapSack(vector<int> wt, vector<int> val, int c, int n){
    //******* This part is done *******
    if (n == 0 || c == 0)
        return 0;

    //Weight can either be <= c or > c
    if (wt[n-1] <= c){
        //Choice 1: choose this item
        //Since we're choosing this item, we add the current item's value to whatever we get from next recursive call
        //OK: This needs to be edited..... EDIT 1
        int profitWithChoosing = val[n-1] + knapSack(wt, val, c - wt[n-1], n-1);

        //Choice 2: Don't choose this item
        //Since we don't choose this item, we simply ignore its value and move to the next item
        //OK: This needs to be edited..... EDIT 2
        int profitWithNotChoosing = knapSack(wt, val, c, n-1);

        //Need to return max profit
        //Finally, based on the two decisions above, we choose the max of the two and return that value
        //Store the max before returning:
        //OK: This needs to be edited..... EDIT 3
        return max (profitWithChoosing, profitWithNotChoosing);

    } else {
        //weight is > capacity, just continue recursing...
        //Store in dp before returning:
        //OK: This needs to be edited..... EDIT 4
        return knapSack(wt, val, c, n-1);
    }
}
```

**Edit 1**

```cpp
        //OK: This needs to be edited..... EDIT 1
        int profitWithChoosing = val[n-1] + knapSack(wt, val, c - wt[n-1], n-1);
```

This part gets the profit for us if we actually choose the current element. Therefore, we need to remove the recursive call from here. All the information that we need is in the table:

```cpp
        int profitWithChoosing = val[n-1] + dp[n-1][c - wt[n-1]];
```

So, instead of recursing, we grab the value from our 2D matrix. Notice how we grab from `n-1` and `c - wt[n-1]`. That is because we've already calculated these values. Since the table is `dp[n][c]`, any edits we made in the recursive calls to these values, should be kept in that order. If we had `dp[c][n]`, then this same translation would've been:

`dp[c- wt[n]][n-1];`

Ok, so we've made edit 1. Let's make the remaining edits:

**Edit 2**

```cpp
        //OK: This needs to be edited..... EDIT 2
        int profitWithNotChoosing = knapSack(wt, val, c, n-1);
```

This part deals with the decision where we choose NOT to include the current element. 

```cpp
        int profitWithNotChoosing = dp[n-1][c];
```

Similar to how we made edit 1, we grab the value from previously calculated values.

**Edit 3**

```cpp
        //OK: This needs to be edited..... EDIT 3
        return max (profitWithChoosing, profitWithNotChoosing);
```

Here, we're returning the max of our two choices. There's nothing to return since our function will only return once at the end with the max profit. We do, however, need to update our max profits for current cell which is done here, replacing the return call:

```cpp
    dp[n][c] = max (profitWithChoosing, profitWithNotChoosing);

```

**Edit 4**
This call deals with handling the case where the current weight is > capacity, where we just ignore the current item:

```cpp
        //OK: This needs to be edited..... EDIT 4
        return knapSack(wt, val, c, n-1);
```

As was the case with edit 3, we'll simply update the current cell and return nothing:

```cpp
    dp[n][c] = dp[n-1][c];
```

One thing we've done above is that we use `n` and `c` to populate our 2D matrix. However, `n` and `c` already represent some values in our solution ie the number of elements and capacity of our sack. So, we need new variables so that we can iterate over all `n` and `c` values. To do so, we'll use `i` in lieu of `n` and `j` in lieu of `c`. 

Also, remember we had already initialized the first row and first column with our base condition, so we'll start at index (1,1). This is where `i` and `j` will start. So, replace `n` and `c` with `i` and `j` and start `i` and `j` at (1,1) and then fill out your table to get the final solution at the end:

```cpp {numberLines: true}
vector<vector<int>> dp(5, vector<int>(8,0));

int knapSack(vector<int> wt, vector<int> val, int c, int n){
    //Weight can either be <= c or > c
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= c; j++){
            if (wt[i-1] <= j){
                //Choice 1: choose this item
                //Since we're choosing this item, we add the current item's value to whatever we get from next recursive call
        //        int profitWithChoosing = val[n-1] + knapSack(wt, val, c - wt[n-1], n-1);
                int profitWithChoosing = val[i-1] + dp[i-1][j-wt[i-1]];
                
                //Choice 2: Don't choose this item
                //Since we don't choose this item, we simply ignore its value and move to the next item
        //        int profitWithNotChoosing = knapSack(wt, val, c, n-1);
                int profitWithNotChoosing = dp[i-1][j];
                //Need to return max profit
                //Finally, based on the two decisions above, we choose the max of the two and return that value
        //        return = max (profitWithChoosing, profitWithNotChoosing);
                dp[i][j] = max (profitWithChoosing, profitWithNotChoosing);
            } else {
                //weight is > capacity, just continue recursing...
        //        return knapSack(wt, val, c, n-1);
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[n][c];
}


int main(int argc, const char * argv[]) {
    // insert code here...
    vector<int> wt = {5,4,6,3};
    vector<int> val = {10,40,30,50};
    int maxProfit = knapSack(wt, val, 10, 4);
    cout << "Max profit: " << maxProfit << endl;
    return 0;
}
```

On line 7, we're checking `wt[i-1]` because say `i` is 1 (our smallest possible start value), we're actually interested in the weight of 0th element since that is our starting point. Also, `j` is actually the capacity starting from 0, all the way up till actual capacity so there's no capacity array we're indexing into. Therefore, we're looking at one previous index for `i` (which is `n`) and using current `j` value.
Running time: $O(cn)$

So, in this problem, we were given a list of items (with weights and values associated) and we had a bag that had a capacity. We were asked to fill our bag while maximizing profits. To do so, we had choices that could be made based on each item. There are plenty of problems where this type of pattern can be re-applied.
  
### Summary
In the tabular approach: 
- We first created a 2D matrix of size dp[n+1][c+1]
- We then initialized the 2D matrix to whatever the base case was in the recursive solution
- We then replaced each recursive call with a call to the 2D matrix and retrieved already calculated values
- We then iterated over the entire 2D matrix until we go to the last cell, dp[n][c] which then held the final profit for us!

### Bottom up from scratch
We've seen 0-1 being solved using recursion and tabular methods. It is clear that the tabular method is faster and efficient, therefore, why not use that approach directly? This creation of table approach is also called **bottom up** because you start with the smallest possible solution and work your way up to the actual solution.

For the sake of discussion, let's use the following as our input and capacity:

```cpp
 wt = {1,3,4,5}; // weight of each item in pounds
 val = {2,4,6,8}; //value of each item in dollars
 c = 7; //capacity in pounds
```

(1) We know we'll be creating a 2D matrix of size n+1 * c + 1. Why those dimensions? Because we need to keep track of the changing values. Therefore, our rows are the items we're considering and each column represents the capacity of our knapsack

(2) Next, we need to initialize the 2D matrix. If there are no items given to us, ie row 0, then no matter what the capacity of our sack is, our max profit will ALWAYS be 0. Therefore row 0 is all 0s. Next, if our knapsack has no capacity, then no matter how many items I'm given, my max profit will always be 0. Therefore column 0 is all 0s. Remaining 0s need to be filled with correct values.

This will be the only time in our solution where we've manually assigned values. Most tutorials focus on going through the process of filling in the table by hand and then these tutorials drop the recursive formula and expect one to memorize it. Here, we'll see how we can reach a conclusion logically!
 
|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** |
| -- | -- | -- | -- | -- | -- | -- |
| **0** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| **1** (1) | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| **2** (1,3) | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| **3** (1,3,4) | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
| **4** (1,3,4,5) | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

(3) We'll keep track of rows using `i` and columns using `j`. Let's start with i = 1 and j = 1 (the first unfilled position). ie (1,1). This means, we've been given the first item with weight 1 and our capacity is also 1. At this point, we've got 2 choices:

- chose item with weight 1 
- ignore item with weight 1.

**Choose**:

Say I chose this item, then my new capacity is 1 - 1 = 0. And since I've chosen this item, I cannot pick this item again so my available items to be picked falls from 1 to 0. In essence, we've reduced our problem from finding the max profit from 1 item and capacity of 1 to no item and capacity of 0. Now, remember we said that we want to get current value from previously calculated values? Do I know what the max profit is if my items are 0 and capacity is 0? ie do I know what dp[0][0] is? YES! It is 0! But wait, we're not done. Since we've chosen this item, we need to add its value to the value we got from the sub-problem. 

Therefore:
$$$
 \textrm{choose} = \textrm{value of current item} + \textrm{max profit from remaining capacity and from remaining items} 
$$$

Converting this to code, we have:

```cpp
int choose = val[i-1] + dp[i-1][j - wt[i-1]];
```

This comes out to $2 + 0 = 2$

**Ignore**:

If I ignore the current item, I need the max profit from not picking this item. Do I have the information for the max profit I get if my capacity is 1 and my items are everything BUT the current item? Yes! It is in dp[0][1] = 0. We won't add the value for the current item since we're ignoring it. 

Converting this to code, we have:

```cpp
int ignore = dp[i-1][j];
```


Now, that I have the values for the profit if I choose the item and the value if I ignore the item, my max profit would obviously be the **max** of these two vales. Therefore,

```cpp
dp[i][j] = max(choose, ignore);
```

We continue using this logic to fill out our first row. max of 2 and 0 is 2:

|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** |
| -- | -- | -- | -- | -- | -- | -- |
| **0** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| **1** (1) | 0 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
| **2** (1,3) | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| **3** (1,3,4) | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
| **4** (1,3,4,5) | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

Once we're done filling the table, our final answer will be in the position dp[n][capacity].

Running time is $O(N * Target)$


### Subset Sum
Let's look at a derivative of the 0-1 knapsack called the subset sum: **Given an array of values, find if a subset in the array adds up to a given sum. Your function should return true if there exists such a subset, false otherwise.**

```cpp
input array: [10,5,12,7,9]
target: 17
```

Why is this 0-1's derivation? Similar to the knapsack problem, this problem has given us an array of values and we've got the option of either choosing that value or rejecting it. The choices that we have are limited by the array given to us and the goal is to reach a specific value. Therefore, it can be considered a problem similar to 0-1 knapsack.

### Bottom up from scratch
Let's say that you were given the subset sum problem and instead of starting out with the recursive solution, you want to start out with the bottom up solution directly. This is the preferred approach since bottom up is the most efficient solution How would we go about doing that without going through the entire recursive solution? Let's think through this logically.

We've decided to create a table and its dimensions would be based on the number of items we have and the sum we're targeting. Therefore, our rows would represent each item, and columns would represent the target sum. For the sake of an easier example, let's say this is our input and target:

```cpp
input: {2,3,4,1} //lets call this arr
target: 5
```

In that case this is what our 2D matrix dimensions would be: dp[n+1][target+1] = dp[5][6] and we would initialize all values to false initially:
**(We're only given the original input array and the sum we're targeting, therefore, we'll substitute the weight array in our original 0-1 knapsack with this input array and ignore the values array from 0-1 knapsack. Other than that, the entire setup stays the same! So keep in mind: if a single array is given, treat it as the weight array and ignore the values array!)**

```cpp
vector<vector<bool>>dp (n+1, vector<bool> (target+1,false));
```


|  | **0** | **1** | **2** | **3** | **4** | **5** |
| -- | -- | -- | -- | -- | -- | -- |
| **0** | F | F | F | F | F | F |
| **1** (2) | F | F | F | F | F | F |
| **2** (2,3) | F | F | F | F | F | F | 
| **3** (2,3,4) | F | F | F | F | F | F | 
| **4** (2,3,4,1) | F | F | F | F | F | F |

Next, we'll think about the base cases: 
- If the target is 0, ie column 0, then no matter how many inputs we're given, we can achieve the target of 0 by including the empty subset. Therefore column 0 wil have all values as true.
- If the input is 0, then no matter what the target is (except for 0), we cannot achieve that target. Therefore row 0 will have all false values except for (0,0):

|  | **0** | **1** | **2** | **3** | **4** | **5** |
| -- | -- | -- | -- | -- | -- | -- |
| **0**  | T | F | F | F | F | F |
| **1** (2) | T | F | F | F | F | F |
| **2** (2,3) | T | F | F | F | F | F | 
| **3** (2,3,4) | T | F | F | F | F | F | 
| **4** (2,3,4,1) | T | F | F | F | F | F |

Alright, we've handled the initialization. Now, we'll start with (1,1) and see what that means:

|  | **0** | **1** | **2** | **3** | **4** | **5** |
| -- | -- | -- | -- | -- | -- | -- |
| **0** | T | F | F | F | F | F |
| **1** (2) | T | **X** |  |  |  |  |
| **2** (2,3) | T |  |  |  |  |  | 
| **3** (2,3,4) | T |  |  |  |  |  | 
| **4** (2,3,4,1) | T |  |  |  |  |  |

Let's assume our rows are being tracked by variable `i` and columns are being tracked by variable `j`.

What does the value at (1,1) mean? It means that we're given just the first element in our array, ie 2, and the target is 1. Now with this given element, we have two choices, we either pick the element, or we ignore it. In either choice, our aim is to see if we can get to the target sum of our current position (ie 1, which is the column we're in. Remember the columns represent intermediate sums). 

- If we ignore this element, it means our array has no elements: `{}`. What happens if the target is 1 and we have no elements? Do we have this information somewhere? YES! It is one row above our current position staying in the same column: ie (0,1). We filled that row during initialization. Ok, if we ignore 2, we have a false: `int ignore = dp[i-1][j]` This means we move back up one row but stay in the same column to get result of ignoring this element.

- If we choose this element, it means our array has this: {2}. What happens if the target is 1 and we have only one element that is greater than our target? ie arr[i] > j. This means that we cannot make this sum since the element we're considering is already greater than the sum we want,so false. What if we choose this element and the target is greater than the element? We'll look at another example down the line to see how we decide for it.

Now if either one of our decisions: ignore or choose, result in a true we can conclude that we can get to the sum. Now, we're deciding for dp[i][j] or (1,1): We've got the answers for our two choices in variables `ignore` and `choose`. How do we decide which one goes at dp[i][j]? If we can get to the sum by either ignoring the current element OR choosing it, we can conclude that we can get to the target sum. Therefore, we'll OR the two answers. 

Let's conclude this section with the code we've seen:

```cpp
//ignore:
int ignore = dp[i-1][j];

//Choose:
//TODO!

//What to do after we have our choose and ignore elements? OR them:
dp[i][j] = ignore || choose;
``` 

Based on the discussion above, we have this:

|  | **0** | **1** | **2** | **3** | **4** | **5** |
| -- | -- | -- | -- | -- | -- | -- |
| **0** | T | F | F | F | F | F |
| **1** (2) | T | **F** |  |  |  |  |
| **2** (2,3) | T |  |  |  |  |  | 
| **3** (2,3,4) | T |  |  |  |  |  | 
| **4** (2,3,4,1) | T |  |  |  |  |  |
  
What about (1,2) ie we're filling position dp[1][2]? Can we get a sum of 2 with the given array as [2]? This is where we'll look to decide how to pick the `choose` variable now that our target is <= the element. Ok, so we've got the element as 2 and our target is also 2. We've got two options:

- ignore: `int ignore = dp[i-1][j];` which is dp[0][2] which is false.

- choose: Ok, we now choose this element since it is NOT greater than the sum. We can see that by picking 2, we can get to the sum but again **the idea is to come to a decision using ONLY the information we have so far**. 

Therefore, if we pick 2, what do we do? Think about it, if we pick 2, our new target sum now becomes: 2 - 2 = 0. We were initially going to check if we can get to target 2 using only elements:  `{2}`. Now if we've chosen to pick this element, our new sum becomes 0 because subtracting 2 from the target brings us to 0. Now, we've picked 2 but our target is 0. **If we've picked 2, it is gone from our input array right because we've chosen the element and it is no longer available to be picked.** This is an important idea to get our head around. Since this is 0-1 knapsack, we've picked the element and cannot pick it again so it is gone from our available input. Therefore, we fall back to previous row, ie row 0. Now, in row 0, which element do we look at? We look at element 0. Why is that? Because our new sum, after including current element 2 became 0: 2 - 2 = 0. 

Let me repeat what we did: 
- We first chose the current element and got the new sum: 
```cpp
int newSum = currentSum - valueOfChosenElement;
```
`currentSum` is nothing but the value of `j` because remember `j` is keeping track of the column or the sum we're solving for.

- We then proceeded to remove the element from our array since we've chosen it meaning:
```cpp
int newRow = currentRow - 1;
```
`currentRow` is nothing but the value of `i` because remember `i` is keeping track of the current row we're in.

Finally, we extract the value from:
```cpp
dp[newRow][newSum];
```

Therefore, putting it all together:

```cpp
int newRow = i - 1;
int newSum = j - valueOfChosenElement;
int choose = dp[newRow][j - valueOfChosenElement];
```

Therefore, here's the code for our options when we can choose an element or ignore it and assign the relevant value to dp[i][j]:

```cpp
int ignore = dp[i-1[j];
int choose = dp[i-1][j - valueOfChosenElement];
dp[i][j] = ignore || choose;
```   

Ok, so we've got this much so far:


|  | **0** | **1** | **2** | **3** | **4** | **5** |
| -- | -- | -- | -- | -- | -- | -- |
| **0** | T | F | F | F | F | F |
| **1** (2) | T | F | **T** |  |  |  |
| **2** (2,3) | T |  |  |  |  |  | 
| **3** (2,3,4) | T |  |  |  |  |  | 
| **4** (2,3,4,1) | T |  |  |  |  |  |
  
It is then easy to see how we'd fill up row number 1:
Say we're now filling dp[1][3]:

```cpp

//Is element > sum? ie is 2 > 3 No, so we can proceed with either choosing or ignoring the element 
int ignore = dp[i-1][j] // dp[0][3] which is false
int choose = dp[i-1][j - valueChosen] // dp[0][3-2] = dp[0][1] which is false
dp[i][j] = ignore || choose; //false
```

|  | **0** | **1** | **2** | **3** | **4** | **5** |
| -- | -- | -- | -- | -- | -- | -- |
| **0** | T | F | F | F | F | F |
| **1** (2) | T | F | T | **F** |  |  |
| **2** (2,3) | T |  |  |  |  |  | 
| **3** (2,3,4) | T |  |  |  |  |  | 
| **4** (2,3,4,1) | T |  |  |  |  |  |

Now we can easily fill out the table! The point of dynamic programming is to get current solution from previously calculated solutions! Here's the complete code for tabular solution:


```cpp{numberLines: true}
bool isPresent(vector<int> vals, int target, vector<vector<bool>> dp){
    for (int i = 0; i < dp.size(); i++){
        //Initialization
        dp[i][0] = true;
    }
    int n = vals.size();
    for (int i = 1; i <= vals.size(); i++){
        for (int j = 1; j <= target; j++){
            if (vals[i - 1] <= j){
                bool picked = dp[i-1][j - vals[i-1]];
                bool ignore = dp[i-1][j];
                dp[i][j] = picked || ignore;
            } else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[n][target];
}
```
A few caveats to the solution above:

- notice on line 9, we're looking at `vals[i-1]`. That is because we're starting to fill out the table from (1,1) however we're considering elements starting at 0 in our values array. That is why we check `vals[i-1]` instead of `vals[i]`. Why do I not do the same thing for `j`? because `j` is tracking the sum from 0 to target so it doesn't makes sense!

Running time: $O(N * Target)$ 

For the sake of completeness, we can also look at recursive solution:  

### Subset Sum Recursive

Function signature: So the problem asks us to return true or false so boolean would be our return type. We'll accept the values array, the target and the size of the values array:

```cpp{numberLines: true}
bool isPossible(vector<int> vals, int target, int n){}
```

Base case: We can think about the smallest valid input where:
- target is 0: we can choose no elements from the array and get to 0
- array is 0: no matter what target we're given, we won't be able to get to the target with no elements.

Here's the code for the base case:

```cpp{numberLines: true}
bool isPossible(vector<int> vals, int target, int n){
    if (target == 0)
        return true;
    if (n < 0)
        return false;
}
```

Next, what if the value is greater than the target? Simply ignore it and move on to the next value in the array:

```cpp{numberLines: true}
bool isPossible(vector<int> vals, int target, int n){
    if (target == 0)
        return true;
    if (n < 0)
        return false;
    if (vals[n-1] > target)
        return isPossible(vals, target, n-1);
}
```  

Next, what if the value is less than target? Ok, in that case we have 2 choices: pick the element, or ignore the element:

```cpp{numberLines: true}
bool isPossible(vector<int> vals, int target, int n){
    if (target == 0)
        return true;
    if (n < 0)
        return false;
    if (vals[n-1] > target)
        return isPossible(vals, target, n-1);
    
    bool picked = isPossible(vals, target - vals[n-1], n-1); // choose element
    if (picked){
        //Found that it adds to target
        return true;
    }
    bool ignore = isPossible(vals, target,n-1);
    if (ignore){
        //Found it adds to target
        return true;
    }
    //none of the above hold
    return false; 
}
```  

Running time for this approach is $O(2^N)$.

### Equal Sum Partition
This is another interesting problem: **Given an array, determine if the values in the array can be partitioned into two sets that have equal sums.**

Example: {2,3,7,8,10}
Answer: True: {2,3,10} and {8,7}

This problem is similar to subset sum where were trying to find if a subset adds up to a given sum. Here however, we need to make an observation:
- If the sum in the array is even, then and only then will we be able to partition it into two equal subsets

If the sum in the array is even, we know we can divide the sum by 2 and then check to see if there's a subset in the array that adds to that sum. If so, then obviously remaining elements would add up to the remaining half of the sum. Let's look at the example we used above:

```cpp
Example: {2,3,7,8,10}
Answer: True: {2,3,10} and {8,7}
```

If I had the array as: {2,3,7,8,12} then even though the sum turns out to be even, it cannot be broken into two partitions based on the elements provided. Therefore, all we need to do is check if the sum is even and then call the logic for subset sum with the target as sum/2. 

Here's the code:

```cpp

bool canBePartitioned(vector<int> vals, int target, int n){
    vector<vector<bool>> dp (n+1, vector<bool>(target+1, false));
    for (int i = 0; i < dp.size(); i++){
        dp[i][0] = true;
    }
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= target; j++){
            if (vals[i-1] > j){
                dp[i][j] = dp[i-1][j];
            } else {
                bool chosen = dp[i-1][j - vals[i-1]];
                bool ignored = dp[i-1][j];
                dp[i][j] = chosen || ignored;
            }
        }
    }
    return dp[n][target];
}

int main(int argc, const char * argv[]) {
    // insert code here...
    vector<int> vals = {2,3,7,8,12};
    int sum = 0;
    for (int i = 0; i < vals.size(); i++){
        sum += vals[i];
    }
    
    if (sum % 2 == 0){
        bool ans = canBePartitioned(vals, sum/2, int(vals.size()));
        if (ans){
            cout << "Yes!" << endl;
        } else {
            cout << "No!" << endl;
        }
    } else {
        cout << "No!" << endl;
    }
    return 0;
}
```

Running time: $O(N*Target)$

### Count Subsets Adding to Given Sum
**Given an array, count the number of subsets that add up to a given target. Your function should return the number of subsets found.**

Example: {2,3,5,8,10} Target: 10
{2,3,5}
{2,8}
{10}
So return 3

Why does this qualify as a 0-1 knapsack? Again because we've got limited items to choose from and for each item we need to make a decision: whether we choose that item or ignore it.

Ok, this sounds similar to the subset sum problem. Let's revisit it: in that problem, we were asked to see if there existed a given subset that would add up to a target. All we had to return was true or false:

```cpp
bool subsetSum(vector<int> vals, int target, int n){
    vector<vector<bool>> dp (n+1, vector<bool>(target+1, false));
    for (int i = 0; i < dp.size(); i++){
        dp[i][0] = true;
    }
    
    //n = i and target = j
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= target; j++){
            if (dp[i-1][j] > target)
                dp[i][j] = dp[i-1][j];
            else {
                bool choose = dp[i-1][j - vals[i-1]];
                bool ignored = dp[i-1][j];
                dp[i][j] = choose || ignore;
            }
        }
    }
    return dp[n][target];
}
```

In the code above, all we did was initialize our 2d matrix, and check to see if the sum was by choosing OR ignoring the value. As soon as we got either one to be true, we just added true for the current sub-problem and moved on.

In our current problem, we can't just check if the sum can be formed or not. We also need to keep a count for the number of subsets found. The logic remains the same but a few things need to change:
- Return type from our function
- What to do when we actually find a subset?

Let's answer these one by one:

**Return type from our function**
Obviously, we can't return true when we're being asked to get the count of subsets, so we'll return an int.

**What to do when we actually find a subset?**
Ok, so what do we change this logic to? Here's what subset sum had:

```cpp
                bool choose = dp[i-1][j - vals[i-1]];
                bool ignored = dp[i-1][j];
                dp[i][j] = choose || ignore;
```

Ok, let's think through this. If we've already found a subset earlier, all we need to do is add it to the current sum:

```cpp
                int choose = dp[i-1][j - vals[i-1]];
                int ignored = dp[i-1][j];
                dp[i][j] = choose + ignore;
```

That's it! Here's the complete code:

```cpp
int totalCount(vector<int> vals, int target, int n){
    vector<vector<int>> dp(n+1, vector<int>(target+1, 0));
    
    for (int i = 0; i < dp.size(); i++){
        dp[i][0] = 1;
    }
    
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= target; j++){
            if (vals[i-1] > j){
                dp[i][j] = dp[i-1][j];
            } else {
                //choose
                int chosen = dp[i-1][j - vals[i-1]];
                int ignored = dp[i-1][j];
                dp[i][j] = chosen + ignored;
            }
        }
    }
    return dp[n][target];
}
```

Running time: $O(N*Target)$


### Conclusion
- 0-1 Knapsack is applied when you're given a limited supply of items and you can either pick an element or ignore it **in its entirety**: there are no fractional picks
- To solve such problems:
    - We first create a 2D matrix of size dp[n+1][c+1]
    - We then initialize a 2D matrix to whatever the base case was in the recursive solution
    - We then replace each recursive call with a call to the 2D matrix and retrieve already calculated values
    - We then iterate over the entire 2D matrix until we go to the last cell, dp[n][c] which holds the final value for us!
- Best approach is to start with the bottom up approach and think through the choices (choose or ignore) and the decision that needs to be made based on the results we get from those choices.
- DP is applied usually when you need to iterate or find something from ALL combinations of a sequence
- It can be used for optimization problems (find minimum or maximum)
- DP can be used when you're looking for a combination out of possible scenarios. These are questions where you need to make decisions based on where you are in the algorithm