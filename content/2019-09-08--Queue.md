---
title: Queue
date: 2019-09-08
categories: 
    - Data Structures
tags:
  - Data Structures
  - C++

---

Yet another queue implementation!
<!-- end -->

### Introduction

In this post I'll talk about a very common data structure called queue. The idea behind queue is simple. As the name suggests, it represents a data structure where elements are processed in the order they're received: **first in first out** or FIFO. Common operations supported by a queue data structure would be **Enqueue** (adding to end of queue - akin to someone getting in line), **Dequeue** (removing from front of queue - someone being processed from our line), **Print** (to print our queue), and **GetSize** (to get size of our queue). We'll be using an implementation of my LinkedList class that I described in [this](/post/linked-lists#code) section.

### Code

```cpp{numberLines}
#ifndef Queue_h
#define Queue_h

#include <iostream>

template<typename T>
struct Node{
    T element;
    Node* next;
};

template<typename T>
class Queue{
private:
    Node<T>* head;
    Node<T>* tail;
    int size;
    
public:
    Queue();
    ~Queue();
    void Print();
    
    T Dequeue();
    void Enqueue(T num);
    
    int GetSize();
};

//Constructor that initializes our head and tail pointers
//and sets our size to 0.
template<typename T>
Queue<T>::Queue(){
    head = nullptr;
    tail = nullptr;
    size = 0;
}

//Destructor to clean up our list
template<typename T>
Queue<T>::~Queue(){
    Node<T>* curr = head;
    while (curr != 0){
        Node<T>* temp = curr;
        curr = curr->next;
        delete temp;
        temp = curr;
    }
    head = nullptr;
    tail = nullptr;
    
}

//Function to print our queue starting at head
template<typename T>
void Queue<T>::Print(){
    Node<T>* itr = head;
    while(itr != 0){
        std::cout << itr->element << " ";
        itr = itr->next;
    }
    std::cout << std::endl;
}

//Function to enqueue: insert at end
template<typename T>
void Queue<T>::Enqueue(T num){
    Node<T>* n = new Node<T>;
    n->element = num;
    n->next = nullptr;
    
    if (size == 0){
        head = n;
        tail = n;
        size++;
    } else {
        tail->next = n;
        tail = n;
        size++;
    }
}

//Function to remove from head of queue
template<typename T>
T Queue<T>::Dequeue(){
    Node<T>* temp = head;
    head = head->next;
    
    temp->next = nullptr;
    T element = temp->element;
    delete temp;
    size--;
    return element;
}

template<typename T>
int Queue<T>::GetSize(){
    return size;
}
#endif /* Queue_h */
```

### Explanation

Code is quite simple to understand. Let's start with the the `Enqueue` function:

```cpp{numberLines:65}
//Function to enqueue: insert at end
template<typename T>
void Queue<T>::Enqueue(T num){
    Node<T>* n = new Node<T>;
    n->element = num;
    n->next = nullptr;
    
    if (size == 0){
        head = n;
        tail = n;
        size++;
    } else {
        tail->next = n;
        tail = n;
        size++;
    }
}
```

This function is exactly the same as `InsertAtTail` function in my LinkedList post. All we're doing here is adding a new element to the end of the queue. Once inserted, we increment the size of the queue and update our `tail` pointer.


Let's have a look at our `Dequeue` function:
```cpp{numberLines:83}
//Function to remove from head of queue
template<typename T>
T Queue<T>::Dequeue(){
    Node<T>* temp = head;
    head = head->next;
    
    temp->next = nullptr;
    T element = temp->element;
    delete temp;
    size--;
    return element;
}
```

Here, we're removing an element from the front of the queue, decrementing the size of our queue and updating the `head` pointer. One thing to note here is that we're also freeing up the memory that was being used by the node. The `Dequeue` function returns the value held in the node so we save the value in the `element` variable before returning to the calling function. 

Each of the two functions above keep track of our private `size` variable that is then returned whenever the client calls our `GetSize()` method.

### Analysis

Insertion into a queue takes $O(1)$ time and so does deletion. That is because we've got pointers to both the head (for removal) and tail (for insertion). 

### Conclusion

The code is quite simple once you get the hang of pointers. It is better if you draw out what's going in the `Enqueue` and `Dequeue` functions. We'll be building on top of the [`LinkedList`](/post/linked-lists#code) again when we talk about another data structure called stack.